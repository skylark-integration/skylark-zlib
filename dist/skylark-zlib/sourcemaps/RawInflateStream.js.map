{"version":3,"sources":["RawInflateStream.js"],"names":["define","Zlib","Huffman","RawInflateStream","USE_TYPEDARRAY","table","buildHuffmanTable","input","ip","opt_buffersize","this","blocks","bufferSize","totalpos","bitsbuf","bitsbuflen","Uint8Array","output","Array","op","bfinal","blockLength","resize","litlenTable","distTable","sp","status","Status","INITIALIZED","ip_","bitsbuflen_","bitsbuf_","BlockType","UNCOMPRESSED","FIXED","DYNAMIC","BLOCK_HEADER_START","BLOCK_HEADER_END","BLOCK_BODY_START","BLOCK_BODY_END","DECODE_BLOCK_START","DECODE_BLOCK_END","prototype","decompress","newInput","stop","readBlockHeader","currentBlockType","readUncompressedBlockHeader","parseFixedHuffmanBlock","parseDynamicHuffmanBlock","parseUncompressedBlock","decodeHuffman","concatBuffer","MaxBackwardLength","MaxCopyLength","Order","Uint16Array","LengthCodeTable","LengthExtraTable","DistCodeTable","DistExtraTable","FixedLiteralLengthTable","i","il","lengths","length","FixedDistanceTable","hdr","save_","readBits","restore_","Error","octet","readCodeByTable","codeWithLength","codeLength","codeTable","maxCodeLength","len","expandBuffer","fixRatio","hlit","hdist","hclen","codeLengthsTable","codeLengths","bits","code","repeat","lengthTable","prev","subarray","slice","call","e","ti","codeDist","litlen","dist","olength","opt_param","buffer","newSize","maxInflateSize","ratio","addRatio","set","tmp"],"mappings":"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","file":"../RawInflateStream.js","sourcesContent":["define([\n  \"./zlib\",\n  \"./huffman\",\n  \"./RawInflateStream\"\n],function(Zlib,Huffman,RawInflateStream) {\n  const USE_TYPEDARRAY = true;\n\n  //-----------------------------------------------------------------------------\n\n  /** @define {number} buffer block size. */\n  var ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE = 0x8000;\n\n  //-----------------------------------------------------------------------------\n\n  var buildHuffmanTable = Huffman.buildHuffmanTable;\n\n  /**\n   * @param {!(Uint8Array|Array.<number>)} input input buffer.\n   * @param {number} ip input buffer pointer.\n   * @param {number=} opt_buffersize buffer block size.\n   * @constructor\n   */\n  var RawInflateStream = function(input, ip, opt_buffersize) {\n    /** @type {!Array.<(Array|Uint8Array)>} */\n    this.blocks = [];\n    /** @type {number} block size. */\n    this.bufferSize =\n      opt_buffersize ? opt_buffersize : ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE;\n    /** @type {!number} total output buffer pointer. */\n    this.totalpos = 0;\n    /** @type {!number} input buffer pointer. */\n    this.ip = ip === void 0 ? 0 : ip;\n    /** @type {!number} bit stream reader buffer. */\n    this.bitsbuf = 0;\n    /** @type {!number} bit stream reader buffer size. */\n    this.bitsbuflen = 0;\n    /** @type {!(Array|Uint8Array)} input buffer. */\n    this.input = USE_TYPEDARRAY ? new Uint8Array(input) : input;\n    /** @type {!(Uint8Array|Array)} output buffer. */\n    this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(this.bufferSize);\n    /** @type {!number} output buffer pointer. */\n    this.op = 0;\n    /** @type {boolean} is final block flag. */\n    this.bfinal = false;\n    /** @type {number} uncompressed block length. */\n    this.blockLength;\n    /** @type {boolean} resize flag for memory size optimization. */\n    this.resize = false;\n    /** @type {Array} */\n    this.litlenTable;\n    /** @type {Array} */\n    this.distTable;\n    /** @type {number} */\n    this.sp = 0; // stream pointer\n    /** @type {RawInflateStream.Status} */\n    this.status = RawInflateStream.Status.INITIALIZED;\n\n    //\n    // backup\n    //\n    /** @type {!number} */\n    this.ip_;\n    /** @type {!number} */\n    this.bitsbuflen_;\n    /** @type {!number} */\n    this.bitsbuf_;\n  };\n\n  /**\n   * @enum {number}\n   */\n  RawInflateStream.BlockType = {\n    UNCOMPRESSED: 0,\n    FIXED: 1,\n    DYNAMIC: 2\n  };\n\n  /**\n   * @enum {number}\n   */\n  RawInflateStream.Status = {\n    INITIALIZED: 0,\n    BLOCK_HEADER_START: 1,\n    BLOCK_HEADER_END: 2,\n    BLOCK_BODY_START: 3,\n    BLOCK_BODY_END: 4,\n    DECODE_BLOCK_START: 5,\n    DECODE_BLOCK_END: 6\n  };\n\n  /**\n   * decompress.\n   * @return {!(Uint8Array|Array)} inflated buffer.\n   */\n  RawInflateStream.prototype.decompress = function(newInput, ip) {\n    /** @type {boolean} */\n    var stop = false;\n\n    if (newInput !== void 0) {\n      this.input = newInput;\n    }\n\n    if (ip !== void 0) {\n      this.ip = ip;\n    }\n\n    // decompress\n    while (!stop) {\n      switch (this.status) {\n        // block header\n        case RawInflateStream.Status.INITIALIZED:\n        case RawInflateStream.Status.BLOCK_HEADER_START:\n          if (this.readBlockHeader() < 0) {\n            stop = true;\n          }\n          break;\n        // block body\n        case RawInflateStream.Status.BLOCK_HEADER_END: /* FALLTHROUGH */\n        case RawInflateStream.Status.BLOCK_BODY_START:\n          switch(this.currentBlockType) {\n            case RawInflateStream.BlockType.UNCOMPRESSED:\n              if (this.readUncompressedBlockHeader() < 0) {\n                stop = true;\n              }\n              break;\n            case RawInflateStream.BlockType.FIXED:\n              if (this.parseFixedHuffmanBlock() < 0) {\n                stop = true;\n              }\n              break;\n            case RawInflateStream.BlockType.DYNAMIC:\n              if (this.parseDynamicHuffmanBlock() < 0) {\n                stop = true;\n              }\n              break;\n          }\n          break;\n        // decode data\n        case RawInflateStream.Status.BLOCK_BODY_END:\n        case RawInflateStream.Status.DECODE_BLOCK_START:\n          switch(this.currentBlockType) {\n            case RawInflateStream.BlockType.UNCOMPRESSED:\n              if (this.parseUncompressedBlock() < 0) {\n                stop = true;\n              }\n              break;\n            case RawInflateStream.BlockType.FIXED: /* FALLTHROUGH */\n            case RawInflateStream.BlockType.DYNAMIC:\n              if (this.decodeHuffman() < 0) {\n                stop = true;\n              }\n              break;\n          }\n          break;\n        case RawInflateStream.Status.DECODE_BLOCK_END:\n          if (this.bfinal) {\n            stop = true;\n          } else {\n            this.status = RawInflateStream.Status.INITIALIZED;\n          }\n          break;\n      }\n    }\n\n    return this.concatBuffer();\n  };\n\n  /**\n   * @const\n   * @type {number} max backward length for LZ77.\n   */\n  RawInflateStream.MaxBackwardLength = 32768;\n\n  /**\n   * @const\n   * @type {number} max copy length for LZ77.\n   */\n  RawInflateStream.MaxCopyLength = 258;\n\n  /**\n   * huffman order\n   * @const\n   * @type {!(Array.<number>|Uint8Array)}\n   */\n  RawInflateStream.Order = (function(table) {\n    return USE_TYPEDARRAY ? new Uint16Array(table) : table;\n  })([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n\n  /**\n   * huffman length code table.\n   * @const\n   * @type {!(Array.<number>|Uint16Array)}\n   */\n  RawInflateStream.LengthCodeTable = (function(table) {\n    return USE_TYPEDARRAY ? new Uint16Array(table) : table;\n  })([\n    0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,\n    0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,\n    0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,\n    0x00e3, 0x0102, 0x0102, 0x0102\n  ]);\n\n  /**\n   * huffman length extra-bits table.\n   * @const\n   * @type {!(Array.<number>|Uint8Array)}\n   */\n  RawInflateStream.LengthExtraTable = (function(table) {\n    return USE_TYPEDARRAY ? new Uint8Array(table) : table;\n  })([\n    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,\n    5, 5, 0, 0, 0\n  ]);\n\n  /**\n   * huffman dist code table.\n   * @const\n   * @type {!(Array.<number>|Uint16Array)}\n   */\n  RawInflateStream.DistCodeTable = (function(table) {\n    return USE_TYPEDARRAY ? new Uint16Array(table) : table;\n  })([\n    0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,\n    0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,\n    0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,\n    0x3001, 0x4001, 0x6001\n  ]);\n\n  /**\n   * huffman dist extra-bits table.\n   * @const\n   * @type {!(Array.<number>|Uint8Array)}\n   */\n  RawInflateStream.DistExtraTable = (function(table) {\n    return USE_TYPEDARRAY ? new Uint8Array(table) : table;\n  })([\n    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,\n    11, 12, 12, 13, 13\n  ]);\n\n  /**\n   * fixed huffman length code table\n   * @const\n   * @type {!Array}\n   */\n  RawInflateStream.FixedLiteralLengthTable = (function(table) {\n    return table;\n  })((function() {\n    var lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(288);\n    var i, il;\n\n    for (i = 0, il = lengths.length; i < il; ++i) {\n      lengths[i] =\n        (i <= 143) ? 8 :\n        (i <= 255) ? 9 :\n        (i <= 279) ? 7 :\n        8;\n    }\n\n    return buildHuffmanTable(lengths);\n  })());\n\n  /**\n   * fixed huffman distance code table\n   * @const\n   * @type {!Array}\n   */\n  RawInflateStream.FixedDistanceTable = (function(table) {\n    return table;\n  })((function() {\n    var lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(30);\n    var i, il;\n\n    for (i = 0, il = lengths.length; i < il; ++i) {\n      lengths[i] = 5;\n    }\n\n    return buildHuffmanTable(lengths);\n  })());\n\n  /**\n   * parse deflated block.\n   */\n  RawInflateStream.prototype.readBlockHeader = function() {\n    /** @type {number} header */\n    var hdr;\n\n    this.status = RawInflateStream.Status.BLOCK_HEADER_START;\n\n    this.save_();\n    if ((hdr = this.readBits(3)) < 0) {\n      this.restore_();\n      return -1;\n    }\n\n    // BFINAL\n    if (hdr & 0x1) {\n      this.bfinal = true;\n    }\n\n    // BTYPE\n    hdr >>>= 1;\n    switch (hdr) {\n      case 0: // uncompressed\n        this.currentBlockType = RawInflateStream.BlockType.UNCOMPRESSED;\n        break;\n      case 1: // fixed huffman\n        this.currentBlockType = RawInflateStream.BlockType.FIXED;\n        break;\n      case 2: // dynamic huffman\n        this.currentBlockType = RawInflateStream.BlockType.DYNAMIC;\n        break;\n      default: // reserved or other\n        throw new Error('unknown BTYPE: ' + hdr);\n    }\n\n    this.status = RawInflateStream.Status.BLOCK_HEADER_END;\n  };\n\n  /**\n   * read inflate bits\n   * @param {number} length bits length.\n   * @return {number} read bits.\n   */\n  RawInflateStream.prototype.readBits = function(length) {\n    var bitsbuf = this.bitsbuf;\n    var bitsbuflen = this.bitsbuflen;\n    var input = this.input;\n    var ip = this.ip;\n\n    /** @type {number} input and output byte. */\n    var octet;\n\n    // not enough buffer\n    while (bitsbuflen < length) {\n      // input byte\n      if (input.length <= ip) {\n        return -1;\n      }\n      octet = input[ip++];\n\n      // concat octet\n      bitsbuf |= octet << bitsbuflen;\n      bitsbuflen += 8;\n    }\n\n    // output byte\n    octet = bitsbuf & /* MASK */ ((1 << length) - 1);\n    bitsbuf >>>= length;\n    bitsbuflen -= length;\n\n    this.bitsbuf = bitsbuf;\n    this.bitsbuflen = bitsbuflen;\n    this.ip = ip;\n\n    return octet;\n  };\n\n  /**\n   * read huffman code using table\n   * @param {Array} table huffman code table.\n   * @return {number} huffman code.\n   */\n  RawInflateStream.prototype.readCodeByTable = function(table) {\n    var bitsbuf = this.bitsbuf;\n    var bitsbuflen = this.bitsbuflen;\n    var input = this.input;\n    var ip = this.ip;\n\n    /** @type {!(Array|Uint8Array)} huffman code table */\n    var codeTable = table[0];\n    /** @type {number} */\n    var maxCodeLength = table[1];\n    /** @type {number} input byte */\n    var octet;\n    /** @type {number} code length & code (16bit, 16bit) */\n    var codeWithLength;\n    /** @type {number} code bits length */\n    var codeLength;\n\n    // not enough buffer\n    while (bitsbuflen < maxCodeLength) {\n      if (input.length <= ip) {\n        return -1;\n      }\n      octet = input[ip++];\n      bitsbuf |= octet << bitsbuflen;\n      bitsbuflen += 8;\n    }\n\n    // read max length\n    codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];\n    codeLength = codeWithLength >>> 16;\n\n    if (codeLength > bitsbuflen) {\n      throw new Error('invalid code length: ' + codeLength);\n    }\n\n    this.bitsbuf = bitsbuf >> codeLength;\n    this.bitsbuflen = bitsbuflen - codeLength;\n    this.ip = ip;\n\n    return codeWithLength & 0xffff;\n  };\n\n  /**\n   * read uncompressed block header\n   */\n  RawInflateStream.prototype.readUncompressedBlockHeader = function() {\n    /** @type {number} block length */\n    var len;\n    /** @type {number} number for check block length */\n    var nlen;\n\n    var input = this.input;\n    var ip = this.ip;\n\n    this.status = RawInflateStream.Status.BLOCK_BODY_START;\n\n    if (ip + 4 >= input.length) {\n      return -1;\n    }\n\n    len = input[ip++] | (input[ip++] << 8);\n    nlen = input[ip++] | (input[ip++] << 8);\n\n    // check len & nlen\n    if (len === ~nlen) {\n      throw new Error('invalid uncompressed block header: length verify');\n    }\n\n    // skip buffered header bits\n    this.bitsbuf = 0;\n    this.bitsbuflen = 0;\n\n    this.ip = ip;\n    this.blockLength = len;\n    this.status = RawInflateStream.Status.BLOCK_BODY_END;\n  };\n\n  /**\n   * parse uncompressed block.\n   */\n  RawInflateStream.prototype.parseUncompressedBlock = function() {\n    var input = this.input;\n    var ip = this.ip;\n    var output = this.output;\n    var op = this.op;\n    var len = this.blockLength;\n\n    this.status = RawInflateStream.Status.DECODE_BLOCK_START;\n\n    // copy\n    // XXX: とりあえず素直にコピー\n    while (len--) {\n      if (op === output.length) {\n        output = this.expandBuffer({fixRatio: 2});\n      }\n\n      // not enough input buffer\n      if (ip >= input.length) {\n        this.ip = ip;\n        this.op = op;\n        this.blockLength = len + 1; // コピーしてないので戻す\n        return -1;\n      }\n\n      output[op++] = input[ip++];\n    }\n\n    if (len < 0) {\n      this.status = RawInflateStream.Status.DECODE_BLOCK_END;\n    }\n\n    this.ip = ip;\n    this.op = op;\n\n    return 0;\n  };\n\n  /**\n   * parse fixed huffman block.\n   */\n  RawInflateStream.prototype.parseFixedHuffmanBlock = function() {\n    this.status = RawInflateStream.Status.BLOCK_BODY_START;\n\n    this.litlenTable = RawInflateStream.FixedLiteralLengthTable;\n    this.distTable = RawInflateStream.FixedDistanceTable;\n\n    this.status = RawInflateStream.Status.BLOCK_BODY_END;\n\n    return 0;\n  };\n\n  /**\n   * オブジェクトのコンテキストを別のプロパティに退避する.\n   * @private\n   */\n  RawInflateStream.prototype.save_ = function() {\n    this.ip_ = this.ip;\n    this.bitsbuflen_ = this.bitsbuflen;\n    this.bitsbuf_ = this.bitsbuf;\n  };\n\n  /**\n   * 別のプロパティに退避したコンテキストを復元する.\n   * @private\n   */\n  RawInflateStream.prototype.restore_ = function() {\n    this.ip = this.ip_;\n    this.bitsbuflen = this.bitsbuflen_;\n    this.bitsbuf = this.bitsbuf_;\n  };\n\n  /**\n   * parse dynamic huffman block.\n   */\n  RawInflateStream.prototype.parseDynamicHuffmanBlock = function() {\n    /** @type {number} number of literal and length codes. */\n    var hlit;\n    /** @type {number} number of distance codes. */\n    var hdist;\n    /** @type {number} number of code lengths. */\n    var hclen;\n    /** @type {!(Uint8Array|Array)} code lengths. */\n    var codeLengths =\n      new (USE_TYPEDARRAY ? Uint8Array : Array)(RawInflateStream.Order.length);\n    /** @type {!Array} code lengths table. */\n    var codeLengthsTable;\n    /** @type {!(Uint32Array|Array)} literal and length code lengths. */\n    var litlenLengths;\n    /** @type {!(Uint32Array|Array)} distance code lengths. */\n    var distLengths;\n\n    this.status = RawInflateStream.Status.BLOCK_BODY_START;\n\n    this.save_();\n    hlit = this.readBits(5) + 257;\n    hdist = this.readBits(5) + 1;\n    hclen = this.readBits(4) + 4;\n    if (hlit < 0 || hdist < 0 || hclen < 0) {\n      this.restore_();\n      return -1;\n    }\n\n    try {\n      parseDynamicHuffmanBlockImpl.call(this);\n    } catch(e) {\n      this.restore_();\n      return -1;\n    }\n\n    function parseDynamicHuffmanBlockImpl() {\n      /** @type {number} */\n      var bits;\n      var code;\n      var prev = 0;\n      var repeat;\n      /** @type {!(Uint8Array|Array.<number>)} code length table. */\n      var lengthTable;\n      /** @type {number} loop counter. */\n      var i;\n      /** @type {number} loop limit. */\n      var il;\n\n      // decode code lengths\n      for (i = 0; i < hclen; ++i) {\n        if ((bits = this.readBits(3)) < 0) {\n          throw new Error('not enough input');\n        }\n        codeLengths[RawInflateStream.Order[i]] = bits;\n      }\n\n      // decode length table\n      codeLengthsTable = buildHuffmanTable(codeLengths);\n      lengthTable = new (USE_TYPEDARRAY ? Uint8Array : Array)(hlit + hdist);\n      for (i = 0, il = hlit + hdist; i < il;) {\n        code = this.readCodeByTable(codeLengthsTable);\n        if (code < 0) {\n          throw new Error('not enough input');\n        }\n        switch (code) {\n          case 16:\n            if ((bits = this.readBits(2)) < 0) {\n              throw new Error('not enough input');\n            }\n            repeat = 3 + bits;\n            while (repeat--) { lengthTable[i++] = prev; }\n            break;\n          case 17:\n            if ((bits = this.readBits(3)) < 0) {\n              throw new Error('not enough input');\n            }\n            repeat = 3 + bits;\n            while (repeat--) { lengthTable[i++] = 0; }\n            prev = 0;\n            break;\n          case 18:\n            if ((bits = this.readBits(7)) < 0) {\n              throw new Error('not enough input');\n            }\n            repeat = 11 + bits;\n            while (repeat--) { lengthTable[i++] = 0; }\n            prev = 0;\n            break;\n          default:\n            lengthTable[i++] = code;\n            prev = code;\n            break;\n        }\n      }\n\n      // literal and length code\n      litlenLengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(hlit);\n\n      // distance code\n      distLengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(hdist);\n\n      this.litlenTable = USE_TYPEDARRAY\n        ? buildHuffmanTable(lengthTable.subarray(0, hlit))\n        : buildHuffmanTable(lengthTable.slice(0, hlit));\n      this.distTable = USE_TYPEDARRAY\n        ? buildHuffmanTable(lengthTable.subarray(hlit))\n        : buildHuffmanTable(lengthTable.slice(hlit));\n    }\n\n    this.status = RawInflateStream.Status.BLOCK_BODY_END;\n\n    return 0;\n  };\n\n  /**\n   * decode huffman code (dynamic)\n   * @return {(number|undefined)} -1 is error.\n   */\n  RawInflateStream.prototype.decodeHuffman = function() {\n    var output = this.output;\n    var op = this.op;\n\n    /** @type {number} huffman code. */\n    var code;\n    /** @type {number} table index. */\n    var ti;\n    /** @type {number} huffman code distination. */\n    var codeDist;\n    /** @type {number} huffman code length. */\n    var codeLength;\n\n    var litlen = this.litlenTable;\n    var dist = this.distTable;\n\n    var olength = output.length;\n    var bits;\n\n    this.status = RawInflateStream.Status.DECODE_BLOCK_START;\n\n    while (true) {\n      this.save_();\n\n      code = this.readCodeByTable(litlen);\n      if (code < 0) {\n        this.op = op;\n        this.restore_();\n        return -1;\n      }\n\n      if (code === 256) {\n        break;\n      }\n\n      // literal\n      if (code < 256) {\n        if (op === olength) {\n          output = this.expandBuffer();\n          olength = output.length;\n        }\n        output[op++] = code;\n\n        continue;\n      }\n\n      // length code\n      ti = code - 257;\n      codeLength = RawInflateStream.LengthCodeTable[ti];\n      if (RawInflateStream.LengthExtraTable[ti] > 0) {\n        bits = this.readBits(RawInflateStream.LengthExtraTable[ti]);\n        if (bits < 0) {\n          this.op = op;\n          this.restore_();\n          return -1;\n        }\n        codeLength += bits;\n      }\n\n      // dist code\n      code = this.readCodeByTable(dist);\n      if (code < 0) {\n        this.op = op;\n        this.restore_();\n        return -1;\n      }\n      codeDist = RawInflateStream.DistCodeTable[code];\n      if (RawInflateStream.DistExtraTable[code] > 0) {\n        bits = this.readBits(RawInflateStream.DistExtraTable[code]);\n        if (bits < 0) {\n          this.op = op;\n          this.restore_();\n          return -1;\n        }\n        codeDist += bits;\n      }\n\n      // lz77 decode\n      if (op + codeLength >= olength) {\n        output = this.expandBuffer();\n        olength = output.length;\n      }\n\n      while (codeLength--) {\n        output[op] = output[(op++) - codeDist];\n      }\n\n      // break\n      if (this.ip === this.input.length) {\n        this.op = op;\n        return -1;\n      }\n    }\n\n    while (this.bitsbuflen >= 8) {\n      this.bitsbuflen -= 8;\n      this.ip--;\n    }\n\n    this.op = op;\n    this.status = RawInflateStream.Status.DECODE_BLOCK_END;\n  };\n\n  /**\n   * expand output buffer. (dynamic)\n   * @param {Object=} opt_param option parameters.\n   * @return {!(Array|Uint8Array)} output buffer pointer.\n   */\n  RawInflateStream.prototype.expandBuffer = function(opt_param) {\n    /** @type {!(Array|Uint8Array)} store buffer. */\n    var buffer;\n    /** @type {number} expantion ratio. */\n    var ratio = (this.input.length / this.ip + 1) | 0;\n    /** @type {number} maximum number of huffman code. */\n    var maxHuffCode;\n    /** @type {number} new output buffer size. */\n    var newSize;\n    /** @type {number} max inflate size. */\n    var maxInflateSize;\n\n    var input = this.input;\n    var output = this.output;\n\n    if (opt_param) {\n      if (typeof opt_param.fixRatio === 'number') {\n        ratio = opt_param.fixRatio;\n      }\n      if (typeof opt_param.addRatio === 'number') {\n        ratio += opt_param.addRatio;\n      }\n    }\n\n    // calculate new buffer size\n    if (ratio < 2) {\n      maxHuffCode =\n        (input.length - this.ip) / this.litlenTable[2];\n      maxInflateSize = (maxHuffCode / 2 * 258) | 0;\n      newSize = maxInflateSize < output.length ?\n        output.length + maxInflateSize :\n        output.length << 1;\n    } else {\n      newSize = output.length * ratio;\n    }\n\n    // buffer expantion\n    if (USE_TYPEDARRAY) {\n      buffer = new Uint8Array(newSize);\n      buffer.set(output);\n    } else {\n      buffer = output;\n    }\n\n    this.output = buffer;\n\n    return this.output;\n  };\n\n  /**\n   * concat output buffer. (dynamic)\n   * @return {!(Array|Uint8Array)} output buffer.\n   */\n  RawInflateStream.prototype.concatBuffer = function() {\n    /** @type {!(Array|Uint8Array)} output buffer. */\n    var buffer;\n    /** @type {number} */\n    var op = this.op;\n    /** @type {Uint8Array} */\n    var tmp;\n\n    if (this.resize) {\n      if (USE_TYPEDARRAY) {\n        buffer = new Uint8Array(this.output.subarray(this.sp, op));\n      } else {\n        buffer = this.output.slice(this.sp, op);\n      }\n    } else {\n      buffer =\n        USE_TYPEDARRAY ? this.output.subarray(this.sp, op) : this.output.slice(this.sp, op);\n    }\n\n    this.sp = op;\n\n    // compaction\n    if (op > RawInflateStream.MaxBackwardLength + this.bufferSize) {\n      this.op = this.sp = RawInflateStream.MaxBackwardLength;\n      if (USE_TYPEDARRAY) {\n        tmp = /** @type {Uint8Array} */(this.output);\n        this.output = new Uint8Array(this.bufferSize + RawInflateStream.MaxBackwardLength);\n        this.output.set(tmp.subarray(op - RawInflateStream.MaxBackwardLength, op));\n      } else {\n        this.output = this.output.slice(op - RawInflateStream.MaxBackwardLength);\n      }\n    }\n\n    return buffer;\n  };\n\n  return Zlib.RawInflateStream = RawInflateStream;\n  \n});\n\n\n"]}