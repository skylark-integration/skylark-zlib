{"version":3,"sources":["Zip.js"],"names":["define","Zlib","CRC32","RawDeflate","Zip","opt_params","this","files","comment","password","CompressionMethod","STORE","DEFLATE","OperatingSystem","MSDOS","UNIX","MACINTOSH","Flags","ENCRYPT","DESCRIPTOR","UTF8","FileHeaderSignature","LocalFileHeaderSignature","CentralDirectorySignature","prototype","addFile","input","compressed","size","length","crc32","Array","Uint8Array","calc","deflateWithOption","Error","push","buffer","option","encrypted","setPassword","compress","file","output","op1","op2","op3","endOfCentralDirectorySize","offset","needVersion","flags","compressionMethod","date","plainSize","filenameLength","extraFieldLength","commentLength","filename","extraField","tmp","key","i","il","j","jl","localFileSize","centralDirectorySize","createEncryptionKey","set","encode","Math","random","Date","getMinutes","getSeconds","getHours","getMonth","getDate","getFullYear","getByte","n","updateKeys","single","Uint32Array"],"mappings":"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","file":"../Zip.js","sourcesContent":["define([\n  \"./zlib\",\n  \"./crc32\",\n  \"./RawDeflate\"\n],function(Zlib,CRC32,RawDeflate) {\n  const USE_TYPEDARRAY = true;\n\n  /**\n   * @param {Object=} opt_params options.\n   * @constructor\n   */\n  Zip = function(opt_params) {\n    opt_params = opt_params || {};\n    /** @type {Array.<{\n     *   buffer: !(Array.<number>|Uint8Array),\n     *   option: Object,\n     *   compressed: boolean,\n     *   encrypted: boolean,\n     *   size: number,\n     *   crc32: number\n     * }>} */\n    this.files = [];\n    /** @type {(Array.<number>|Uint8Array)} */\n    this.comment = opt_params['comment'];\n    /** @type {(Array.<number>|Uint8Array)} */\n    this.password;\n  };\n\n\n  /**\n   * @enum {number}\n   */\n  Zip.CompressionMethod = {\n    STORE: 0,\n    DEFLATE: 8\n  };\n\n  /**\n   * @enum {number}\n   */\n  Zip.OperatingSystem = {\n    MSDOS: 0,\n    UNIX: 3,\n    MACINTOSH: 7\n  };\n\n  /**\n   * @enum {number}\n   */\n  Zip.Flags = {\n    ENCRYPT:    0x0001,\n    DESCRIPTOR: 0x0008,\n    UTF8:       0x0800\n  };\n\n  /**\n   * @type {Array.<number>}\n   * @const\n   */\n  Zip.FileHeaderSignature = [0x50, 0x4b, 0x01, 0x02];\n\n  /**\n   * @type {Array.<number>}\n   * @const\n   */\n  Zip.LocalFileHeaderSignature = [0x50, 0x4b, 0x03, 0x04];\n\n  /**\n   * @type {Array.<number>}\n   * @const\n   */\n  Zip.CentralDirectorySignature = [0x50, 0x4b, 0x05, 0x06];\n\n  /**\n   * @param {Array.<number>|Uint8Array} input\n   * @param {Object=} opt_params options.\n   */\n  Zip.prototype.addFile = function(input, opt_params) {\n    opt_params = opt_params || {};\n    /** @type {string} */\n    var filename = '' || opt_params['filename'];\n    /** @type {boolean} */\n    var compressed;\n    /** @type {number} */\n    var size = input.length;\n    /** @type {number} */\n    var crc32 = 0;\n\n    if (USE_TYPEDARRAY && input instanceof Array) {\n      input = new Uint8Array(input);\n    }\n\n    // default\n    if (typeof opt_params['compressionMethod'] !== 'number') {\n      opt_params['compressionMethod'] = Zip.CompressionMethod.DEFLATE;\n    }\n\n    // その場で圧縮する場合\n    if (opt_params['compress']) {\n      switch (opt_params['compressionMethod']) {\n        case Zip.CompressionMethod.STORE:\n          break;\n        case Zip.CompressionMethod.DEFLATE:\n          crc32 = CRC32.calc(input);\n          input = this.deflateWithOption(input, opt_params);\n          compressed = true;\n          break;\n        default:\n          throw new Error('unknown compression method:' + opt_params['compressionMethod']);\n      }\n    }\n\n    this.files.push({\n      buffer: input,\n      option: opt_params,\n      compressed: compressed,\n      encrypted: false,\n      size: size,\n      crc32: crc32\n    });\n  };\n\n  /**\n   * @param {(Array.<number>|Uint8Array)} password\n   */\n  Zip.prototype.setPassword = function(password) {\n    this.password = password;\n  };\n\n  Zip.prototype.compress = function() {\n    /** @type {Array.<{\n     *   buffer: !(Array.<number>|Uint8Array),\n     *   option: Object,\n     *   compressed: boolean,\n     *   encrypted: boolean,\n     *   size: number,\n     *   crc32: number\n     * }>} */\n    var files = this.files;\n    /** @type {{\n     *   buffer: !(Array.<number>|Uint8Array),\n     *   option: Object,\n     *   compressed: boolean,\n     *   encrypted: boolean,\n     *   size: number,\n     *   crc32: number\n     * }} */\n    var file;\n    /** @type {!(Array.<number>|Uint8Array)} */\n    var output;\n    /** @type {number} */\n    var op1;\n    /** @type {number} */\n    var op2;\n    /** @type {number} */\n    var op3;\n    /** @type {number} */\n    var localFileSize = 0;\n    /** @type {number} */\n    var centralDirectorySize = 0;\n    /** @type {number} */\n    var endOfCentralDirectorySize;\n    /** @type {number} */\n    var offset;\n    /** @type {number} */\n    var needVersion;\n    /** @type {number} */\n    var flags;\n    /** @type {Zip.CompressionMethod} */\n    var compressionMethod;\n    /** @type {Date} */\n    var date;\n    /** @type {number} */\n    var crc32;\n    /** @type {number} */\n    var size;\n    /** @type {number} */\n    var plainSize;\n    /** @type {number} */\n    var filenameLength;\n    /** @type {number} */\n    var extraFieldLength;\n    /** @type {number} */\n    var commentLength;\n    /** @type {(Array.<number>|Uint8Array)} */\n    var filename;\n    /** @type {(Array.<number>|Uint8Array)} */\n    var extraField;\n    /** @type {(Array.<number>|Uint8Array)} */\n    var comment;\n    /** @type {(Array.<number>|Uint8Array)} */\n    var buffer;\n    /** @type {*} */\n    var tmp;\n    /** @type {Array.<number>|Uint32Array|Object} */\n    var key;\n    /** @type {number} */\n    var i;\n    /** @type {number} */\n    var il;\n    /** @type {number} */\n    var j;\n    /** @type {number} */\n    var jl;\n\n    // ファイルの圧縮\n    for (i = 0, il = files.length; i < il; ++i) {\n      file = files[i];\n      filenameLength =\n        (file.option['filename']) ? file.option['filename'].length : 0;\n      extraFieldLength =\n        (file.option['extraField']) ? file.option['extraField'].length : 0;\n      commentLength =\n        (file.option['comment']) ? file.option['comment'].length : 0;\n\n      // 圧縮されていなかったら圧縮\n      if (!file.compressed) {\n        // 圧縮前に CRC32 の計算をしておく\n        file.crc32 = CRC32.calc(file.buffer);\n\n        switch (file.option['compressionMethod']) {\n          case Zip.CompressionMethod.STORE:\n            break;\n          case Zip.CompressionMethod.DEFLATE:\n            file.buffer = this.deflateWithOption(file.buffer, file.option);\n            file.compressed = true;\n            break;\n          default:\n            throw new Error('unknown compression method:' + file.option['compressionMethod']);\n        }\n      }\n\n      // encryption\n      if (file.option['password'] !== void 0|| this.password !== void 0) {\n        // init encryption\n        key = this.createEncryptionKey(file.option['password'] || this.password);\n\n        // add header\n        buffer = file.buffer;\n        if (USE_TYPEDARRAY) {\n          tmp = new Uint8Array(buffer.length + 12);\n          tmp.set(buffer, 12);\n          buffer = tmp;\n        } else {\n          buffer.unshift(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n        }\n\n        for (j = 0; j < 12; ++j) {\n          buffer[j] = this.encode(\n            key,\n            i === 11 ? (file.crc32 & 0xff) : (Math.random() * 256 | 0)\n          );\n        }\n\n        // data encryption\n        for (jl = buffer.length; j < jl; ++j) {\n          buffer[j] = this.encode(key, buffer[j]);\n        }\n        file.buffer = buffer;\n      }\n\n      // 必要バッファサイズの計算\n      localFileSize +=\n        // local file header\n        30 + filenameLength +\n        // file data\n        file.buffer.length;\n\n      centralDirectorySize +=\n        // file header\n        46 + filenameLength + commentLength;\n    }\n\n    // end of central directory\n    endOfCentralDirectorySize = 22 + (this.comment ? this.comment.length : 0);\n    output = new (USE_TYPEDARRAY ? Uint8Array : Array)(\n      localFileSize + centralDirectorySize + endOfCentralDirectorySize\n    );\n    op1 = 0;\n    op2 = localFileSize;\n    op3 = op2 + centralDirectorySize;\n\n    // ファイルの圧縮\n    for (i = 0, il = files.length; i < il; ++i) {\n      file = files[i];\n      filenameLength =\n        file.option['filename'] ? file.option['filename'].length :  0;\n      extraFieldLength = 0; // TODO\n      commentLength =\n        file.option['comment'] ? file.option['comment'].length : 0;\n\n      //-------------------------------------------------------------------------\n      // local file header & file header\n      //-------------------------------------------------------------------------\n\n      offset = op1;\n\n      // signature\n      // local file header\n      output[op1++] = Zip.LocalFileHeaderSignature[0];\n      output[op1++] = Zip.LocalFileHeaderSignature[1];\n      output[op1++] = Zip.LocalFileHeaderSignature[2];\n      output[op1++] = Zip.LocalFileHeaderSignature[3];\n      // file header\n      output[op2++] = Zip.FileHeaderSignature[0];\n      output[op2++] = Zip.FileHeaderSignature[1];\n      output[op2++] = Zip.FileHeaderSignature[2];\n      output[op2++] = Zip.FileHeaderSignature[3];\n\n      // compressor info\n      needVersion = 20;\n      output[op2++] = needVersion & 0xff;\n      output[op2++] =\n        /** @type {Zip.OperatingSystem} */\n        (file.option['os']) ||\n        Zip.OperatingSystem.MSDOS;\n\n      // need version\n      output[op1++] = output[op2++] =  needVersion       & 0xff;\n      output[op1++] = output[op2++] = (needVersion >> 8) & 0xff;\n\n      // general purpose bit flag\n      flags = 0;\n      if (file.option['password'] || this.password) {\n        flags |= Zip.Flags.ENCRYPT;\n      }\n      output[op1++] = output[op2++] =  flags       & 0xff;\n      output[op1++] = output[op2++] = (flags >> 8) & 0xff;\n\n      // compression method\n      compressionMethod =\n        /** @type {Zip.CompressionMethod} */\n        (file.option['compressionMethod']);\n      output[op1++] = output[op2++] =  compressionMethod       & 0xff;\n      output[op1++] = output[op2++] = (compressionMethod >> 8) & 0xff;\n\n      // date\n      date = /** @type {(Date|undefined)} */(file.option['date']) || new Date();\n      output[op1++] = output[op2++] =\n        ((date.getMinutes() & 0x7) << 5) |\n        (date.getSeconds() / 2 | 0);\n      output[op1++] = output[op2++] =\n        (date.getHours()   << 3) |\n        (date.getMinutes() >> 3);\n      //\n      output[op1++] = output[op2++] =\n        ((date.getMonth() + 1 & 0x7) << 5) |\n        (date.getDate());\n      output[op1++] = output[op2++] =\n        ((date.getFullYear() - 1980 & 0x7f) << 1) |\n        (date.getMonth() + 1 >> 3);\n\n      // CRC-32\n      crc32 = file.crc32;\n      output[op1++] = output[op2++] =  crc32        & 0xff;\n      output[op1++] = output[op2++] = (crc32 >>  8) & 0xff;\n      output[op1++] = output[op2++] = (crc32 >> 16) & 0xff;\n      output[op1++] = output[op2++] = (crc32 >> 24) & 0xff;\n\n      // compressed size\n      size = file.buffer.length;\n      output[op1++] = output[op2++] =  size        & 0xff;\n      output[op1++] = output[op2++] = (size >>  8) & 0xff;\n      output[op1++] = output[op2++] = (size >> 16) & 0xff;\n      output[op1++] = output[op2++] = (size >> 24) & 0xff;\n\n      // uncompressed size\n      plainSize = file.size;\n      output[op1++] = output[op2++] =  plainSize        & 0xff;\n      output[op1++] = output[op2++] = (plainSize >>  8) & 0xff;\n      output[op1++] = output[op2++] = (plainSize >> 16) & 0xff;\n      output[op1++] = output[op2++] = (plainSize >> 24) & 0xff;\n\n      // filename length\n      output[op1++] = output[op2++] =  filenameLength       & 0xff;\n      output[op1++] = output[op2++] = (filenameLength >> 8) & 0xff;\n\n      // extra field length\n      output[op1++] = output[op2++] =  extraFieldLength       & 0xff;\n      output[op1++] = output[op2++] = (extraFieldLength >> 8) & 0xff;\n\n      // file comment length\n      output[op2++] =  commentLength       & 0xff;\n      output[op2++] = (commentLength >> 8) & 0xff;\n\n      // disk number start\n      output[op2++] = 0;\n      output[op2++] = 0;\n\n      // internal file attributes\n      output[op2++] = 0;\n      output[op2++] = 0;\n\n      // external file attributes\n      output[op2++] = 0;\n      output[op2++] = 0;\n      output[op2++] = 0;\n      output[op2++] = 0;\n\n      // relative offset of local header\n      output[op2++] =  offset        & 0xff;\n      output[op2++] = (offset >>  8) & 0xff;\n      output[op2++] = (offset >> 16) & 0xff;\n      output[op2++] = (offset >> 24) & 0xff;\n\n      // filename\n      filename = file.option['filename'];\n      if (filename) {\n        if (USE_TYPEDARRAY) {\n          output.set(filename, op1);\n          output.set(filename, op2);\n          op1 += filenameLength;\n          op2 += filenameLength;\n        } else {\n          for (j = 0; j < filenameLength; ++j) {\n            output[op1++] = output[op2++] = filename[j];\n          }\n        }\n      }\n\n      // extra field\n      extraField = file.option['extraField'];\n      if (extraField) {\n        if (USE_TYPEDARRAY) {\n          output.set(extraField, op1);\n          output.set(extraField, op2);\n          op1 += extraFieldLength;\n          op2 += extraFieldLength;\n        } else {\n          for (j = 0; j < commentLength; ++j) {\n            output[op1++] = output[op2++] = extraField[j];\n          }\n        }\n      }\n\n      // comment\n      comment = file.option['comment'];\n      if (comment) {\n        if (USE_TYPEDARRAY) {\n          output.set(comment, op2);\n          op2 += commentLength;\n        } else {\n          for (j = 0; j < commentLength; ++j) {\n            output[op2++] = comment[j];\n          }\n        }\n      }\n\n      //-------------------------------------------------------------------------\n      // file data\n      //-------------------------------------------------------------------------\n\n      if (USE_TYPEDARRAY) {\n        output.set(file.buffer, op1);\n        op1 += file.buffer.length;\n      } else {\n        for (j = 0, jl = file.buffer.length; j < jl; ++j) {\n          output[op1++] = file.buffer[j];\n        }\n      }\n    }\n\n    //-------------------------------------------------------------------------\n    // end of central directory\n    //-------------------------------------------------------------------------\n\n    // signature\n    output[op3++] = Zip.CentralDirectorySignature[0];\n    output[op3++] = Zip.CentralDirectorySignature[1];\n    output[op3++] = Zip.CentralDirectorySignature[2];\n    output[op3++] = Zip.CentralDirectorySignature[3];\n\n    // number of this disk\n    output[op3++] = 0;\n    output[op3++] = 0;\n\n    // number of the disk with the start of the central directory\n    output[op3++] = 0;\n    output[op3++] = 0;\n\n    // total number of entries in the central directory on this disk\n    output[op3++] =  il       & 0xff;\n    output[op3++] = (il >> 8) & 0xff;\n\n    // total number of entries in the central directory\n    output[op3++] =  il       & 0xff;\n    output[op3++] = (il >> 8) & 0xff;\n\n    // size of the central directory\n    output[op3++] =  centralDirectorySize        & 0xff;\n    output[op3++] = (centralDirectorySize >>  8) & 0xff;\n    output[op3++] = (centralDirectorySize >> 16) & 0xff;\n    output[op3++] = (centralDirectorySize >> 24) & 0xff;\n\n    // offset of start of central directory with respect to the starting disk number\n    output[op3++] =  localFileSize        & 0xff;\n    output[op3++] = (localFileSize >>  8) & 0xff;\n    output[op3++] = (localFileSize >> 16) & 0xff;\n    output[op3++] = (localFileSize >> 24) & 0xff;\n\n    // .ZIP file comment length\n    commentLength = this.comment ? this.comment.length : 0;\n    output[op3++] =  commentLength       & 0xff;\n    output[op3++] = (commentLength >> 8) & 0xff;\n\n    // .ZIP file comment\n    if (this.comment) {\n      if (USE_TYPEDARRAY) {\n        output.set(this.comment, op3);\n        op3 += commentLength;\n      } else {\n        for (j = 0, jl = commentLength; j < jl; ++j) {\n          output[op3++] = this.comment[j];\n        }\n      }\n    }\n\n    return output;\n  };\n\n  /**\n   * @param {!(Array.<number>|Uint8Array)} input\n   * @param {Object=} opt_params options.\n   * @return {!(Array.<number>|Uint8Array)}\n   */\n  Zip.prototype.deflateWithOption = function(input, opt_params) {\n    /** @type {RawDeflate} */\n    var deflator = new RawDeflate(input, opt_params['deflateOption']);\n\n    return deflator.compress();\n  };\n\n  /**\n   * @param {(Array.<number>|Uint32Array)} key\n   * @return {number}\n   */\n  Zip.prototype.getByte = function(key) {\n    /** @type {number} */\n    var tmp = ((key[2] & 0xffff) | 2);\n\n    return ((tmp * (tmp ^ 1)) >> 8) & 0xff;\n  };\n\n  /**\n   * @param {(Array.<number>|Uint32Array|Object)} key\n   * @param {number} n\n   * @return {number}\n   */\n  Zip.prototype.encode = function(key, n) {\n    /** @type {number} */\n    var tmp = this.getByte(/** @type {(Array.<number>|Uint32Array)} */(key));\n\n    this.updateKeys(/** @type {(Array.<number>|Uint32Array)} */(key), n);\n\n    return tmp ^ n;\n  };\n\n  /**\n   * @param {(Array.<number>|Uint32Array)} key\n   * @param {number} n\n   */\n  Zip.prototype.updateKeys = function(key, n) {\n    key[0] = CRC32.single(key[0], n);\n    key[1] =\n      (((((key[1] + (key[0] & 0xff)) * 20173 >>> 0) * 6681) >>> 0) + 1) >>> 0;\n    key[2] = CRC32.single(key[2], key[1] >>> 24);\n  };\n\n  /**\n   * @param {(Array.<number>|Uint8Array)} password\n   * @return {!(Array.<number>|Uint32Array|Object)}\n   */\n  Zip.prototype.createEncryptionKey = function(password) {\n    /** @type {!(Array.<number>|Uint32Array)} */\n    var key = [305419896, 591751049, 878082192];\n    /** @type {number} */\n    var i;\n    /** @type {number} */\n    var il;\n\n    if (USE_TYPEDARRAY) {\n      key = new Uint32Array(key);\n    }\n\n    for (i = 0, il = password.length; i < il; ++i) {\n      this.updateKeys(key, password[i] & 0xff);\n    }\n\n    return key;\n  };\n\n  return Zlib.Zip = Zip;\n});\n\n"]}