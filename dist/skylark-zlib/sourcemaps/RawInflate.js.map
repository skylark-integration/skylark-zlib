{"version":3,"sources":["RawInflate.js"],"names":["define","Zlib","table","buildHuffmanTable","Huffman","RawInflate","input","opt_params","this","buffer","blocks","bufferSize","totalpos","ip","bitsbuf","bitsbuflen","Uint8Array","output","op","bfinal","bufferType","BufferType","ADAPTIVE","resize","BLOCK","MaxBackwardLength","MaxCopyLength","expandBuffer","expandBufferAdaptive","concatBuffer","concatBufferDynamic","decodeHuffman","decodeHuffmanAdaptive","Error","prototype","decompress","parseBlock","Order","Uint16Array","LengthCodeTable","LengthExtraTable","DistCodeTable","DistExtraTable","FixedLiteralLengthTable","i","il","lengths","length","FixedDistanceTable","hdr","readBits","parseUncompressedBlock","parseFixedHuffmanBlock","parseDynamicHuffmanBlock","octet","inputLength","readCodeByTable","codeWithLength","codeLength","codeTable","maxCodeLength","len","preCopy","olength","set","subarray","fixRatio","codeLengthsTable","litlenTable","distTable","lengthTable","code","prev","repeat","hlit","hdist","hclen","codeLengths","litlen","dist","currentLitlenTable","ti","codeDist","opt_param","backward","push","newSize","maxInflateSize","ratio","addRatio","block","j","jl","pos","limit"],"mappings":"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","file":"../RawInflate.js","sourcesContent":["define([\n  \"./zlib\"\n],function(Zlib) {\n  const USE_TYPEDARRAY = true;\n\n  //-----------------------------------------------------------------------------\n\n  /** @define {number} buffer block size. */\n  var ZLIB_RAW_INFLATE_BUFFER_SIZE = 0x8000; // [ 0x8000 >= ZLIB_BUFFER_BLOCK_SIZE ]\n\n  //-----------------------------------------------------------------------------\n\n  var buildHuffmanTable = Huffman.buildHuffmanTable;\n\n  /**\n   * @constructor\n   * @param {!(Uint8Array|Array.<number>)} input input buffer.\n   * @param {Object} opt_params option parameter.\n   *\n   * opt_params は以下のプロパティを指定する事ができます。\n   *   - index: input buffer の deflate コンテナの開始位置.\n   *   - blockSize: バッファのブロックサイズ.\n   *   - bufferType: RawInflate.BufferType の値によってバッファの管理方法を指定する.\n   *   - resize: 確保したバッファが実際の大きさより大きかった場合に切り詰める.\n   */\n  var RawInflate = function(input, opt_params) {\n    /** @type {!(Array.<number>|Uint8Array)} inflated buffer */\n    this.buffer;\n    /** @type {!Array.<(Array.<number>|Uint8Array)>} */\n    this.blocks = [];\n    /** @type {number} block size. */\n    this.bufferSize = ZLIB_RAW_INFLATE_BUFFER_SIZE;\n    /** @type {!number} total output buffer pointer. */\n    this.totalpos = 0;\n    /** @type {!number} input buffer pointer. */\n    this.ip = 0;\n    /** @type {!number} bit stream reader buffer. */\n    this.bitsbuf = 0;\n    /** @type {!number} bit stream reader buffer size. */\n    this.bitsbuflen = 0;\n    /** @type {!(Array.<number>|Uint8Array)} input buffer. */\n    this.input = USE_TYPEDARRAY ? new Uint8Array(input) : input;\n    /** @type {!(Uint8Array|Array.<number>)} output buffer. */\n    this.output;\n    /** @type {!number} output buffer pointer. */\n    this.op;\n    /** @type {boolean} is final block flag. */\n    this.bfinal = false;\n    /** @type {RawInflate.BufferType} buffer management. */\n    this.bufferType = RawInflate.BufferType.ADAPTIVE;\n    /** @type {boolean} resize flag for memory size optimization. */\n    this.resize = false;\n\n    // option parameters\n    if (opt_params || !(opt_params = {})) {\n      if (opt_params['index']) {\n        this.ip = opt_params['index'];\n      }\n      if (opt_params['bufferSize']) {\n        this.bufferSize = opt_params['bufferSize'];\n      }\n      if (opt_params['bufferType']) {\n        this.bufferType = opt_params['bufferType'];\n      }\n      if (opt_params['resize']) {\n        this.resize = opt_params['resize'];\n      }\n    }\n\n    // initialize\n    switch (this.bufferType) {\n      case RawInflate.BufferType.BLOCK:\n        this.op = RawInflate.MaxBackwardLength;\n        this.output =\n          new (USE_TYPEDARRAY ? Uint8Array : Array)(\n            RawInflate.MaxBackwardLength +\n            this.bufferSize +\n            RawInflate.MaxCopyLength\n          );\n        break;\n      case RawInflate.BufferType.ADAPTIVE:\n        this.op = 0;\n        this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(this.bufferSize);\n        this.expandBuffer = this.expandBufferAdaptive;\n        this.concatBuffer = this.concatBufferDynamic;\n        this.decodeHuffman = this.decodeHuffmanAdaptive;\n        break;\n      default:\n        throw new Error('invalid inflate mode');\n    }\n  };\n\n  /**\n   * @enum {number}\n   */\n  RawInflate.BufferType = {\n    BLOCK: 0,\n    ADAPTIVE: 1\n  };\n\n  /**\n   * decompress.\n   * @return {!(Uint8Array|Array.<number>)} inflated buffer.\n   */\n  RawInflate.prototype.decompress = function() {\n    while (!this.bfinal) {\n      this.parseBlock();\n    }\n\n    return this.concatBuffer();\n  };\n\n  /**\n   * @const\n   * @type {number} max backward length for LZ77.\n   */\n  RawInflate.MaxBackwardLength = 32768;\n\n  /**\n   * @const\n   * @type {number} max copy length for LZ77.\n   */\n  RawInflate.MaxCopyLength = 258;\n\n  /**\n   * huffman order\n   * @const\n   * @type {!(Array.<number>|Uint8Array)}\n   */\n  RawInflate.Order = (function(table) {\n    return USE_TYPEDARRAY ? new Uint16Array(table) : table;\n  })([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n\n  /**\n   * huffman length code table.\n   * @const\n   * @type {!(Array.<number>|Uint16Array)}\n   */\n  RawInflate.LengthCodeTable = (function(table) {\n    return USE_TYPEDARRAY ? new Uint16Array(table) : table;\n  })([\n    0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,\n    0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,\n    0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,\n    0x00e3, 0x0102, 0x0102, 0x0102\n  ]);\n\n  /**\n   * huffman length extra-bits table.\n   * @const\n   * @type {!(Array.<number>|Uint8Array)}\n   */\n  RawInflate.LengthExtraTable = (function(table) {\n    return USE_TYPEDARRAY ? new Uint8Array(table) : table;\n  })([\n    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,\n    5, 5, 0, 0, 0\n  ]);\n\n  /**\n   * huffman dist code table.\n   * @const\n   * @type {!(Array.<number>|Uint16Array)}\n   */\n  RawInflate.DistCodeTable = (function(table) {\n    return USE_TYPEDARRAY ? new Uint16Array(table) : table;\n  })([\n    0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,\n    0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,\n    0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,\n    0x3001, 0x4001, 0x6001\n  ]);\n\n  /**\n   * huffman dist extra-bits table.\n   * @const\n   * @type {!(Array.<number>|Uint8Array)}\n   */\n  RawInflate.DistExtraTable = (function(table) {\n    return USE_TYPEDARRAY ? new Uint8Array(table) : table;\n  })([\n    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,\n    11, 12, 12, 13, 13\n  ]);\n\n  /**\n   * fixed huffman length code table\n   * @const\n   * @type {!Array}\n   */\n  RawInflate.FixedLiteralLengthTable = (function(table) {\n    return table;\n  })((function() {\n    var lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(288);\n    var i, il;\n\n    for (i = 0, il = lengths.length; i < il; ++i) {\n      lengths[i] =\n        (i <= 143) ? 8 :\n        (i <= 255) ? 9 :\n        (i <= 279) ? 7 :\n        8;\n    }\n\n    return buildHuffmanTable(lengths);\n  })());\n\n  /**\n   * fixed huffman distance code table\n   * @const\n   * @type {!Array}\n   */\n  RawInflate.FixedDistanceTable = (function(table) {\n    return table;\n  })((function() {\n    var lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(30);\n    var i, il;\n\n    for (i = 0, il = lengths.length; i < il; ++i) {\n      lengths[i] = 5;\n    }\n\n    return buildHuffmanTable(lengths);\n  })());\n\n  /**\n   * parse deflated block.\n   */\n  RawInflate.prototype.parseBlock = function() {\n    /** @type {number} header */\n    var hdr = this.readBits(3);\n\n    // BFINAL\n    if (hdr & 0x1) {\n      this.bfinal = true;\n    }\n\n    // BTYPE\n    hdr >>>= 1;\n    switch (hdr) {\n      // uncompressed\n      case 0:\n        this.parseUncompressedBlock();\n        break;\n      // fixed huffman\n      case 1:\n        this.parseFixedHuffmanBlock();\n        break;\n      // dynamic huffman\n      case 2:\n        this.parseDynamicHuffmanBlock();\n        break;\n      // reserved or other\n      default:\n        throw new Error('unknown BTYPE: ' + hdr);\n    }\n  };\n\n  /**\n   * read inflate bits\n   * @param {number} length bits length.\n   * @return {number} read bits.\n   */\n  RawInflate.prototype.readBits = function(length) {\n    var bitsbuf = this.bitsbuf;\n    var bitsbuflen = this.bitsbuflen;\n    var input = this.input;\n    var ip = this.ip;\n\n    /** @type {number} */\n    var inputLength = input.length;\n    /** @type {number} input and output byte. */\n    var octet;\n\n    // not enough buffer\n    while (bitsbuflen < length) {\n      // input byte\n      if (ip >= inputLength) {\n        throw new Error('input buffer is broken');\n      }\n\n      // concat octet\n      bitsbuf |= input[ip++] << bitsbuflen;\n      bitsbuflen += 8;\n    }\n\n    // output byte\n    octet = bitsbuf & /* MASK */ ((1 << length) - 1);\n    bitsbuf >>>= length;\n    bitsbuflen -= length;\n\n    this.bitsbuf = bitsbuf;\n    this.bitsbuflen = bitsbuflen;\n    this.ip = ip;\n\n    return octet;\n  };\n\n  /**\n   * read huffman code using table\n   * @param {!(Array.<number>|Uint8Array|Uint16Array)} table huffman code table.\n   * @return {number} huffman code.\n   */\n  RawInflate.prototype.readCodeByTable = function(table) {\n    var bitsbuf = this.bitsbuf;\n    var bitsbuflen = this.bitsbuflen;\n    var input = this.input;\n    var ip = this.ip;\n\n    /** @type {number} */\n    var inputLength = input.length;\n    /** @type {!(Array.<number>|Uint8Array)} huffman code table */\n    var codeTable = table[0];\n    /** @type {number} */\n    var maxCodeLength = table[1];\n    /** @type {number} code length & code (16bit, 16bit) */\n    var codeWithLength;\n    /** @type {number} code bits length */\n    var codeLength;\n\n    // not enough buffer\n    while (bitsbuflen < maxCodeLength) {\n      if (ip >= inputLength) {\n        break;\n      }\n      bitsbuf |= input[ip++] << bitsbuflen;\n      bitsbuflen += 8;\n    }\n\n    // read max length\n    codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];\n    codeLength = codeWithLength >>> 16;\n\n    if (codeLength > bitsbuflen) {\n      throw new Error('invalid code length: ' + codeLength);\n    }\n\n    this.bitsbuf = bitsbuf >> codeLength;\n    this.bitsbuflen = bitsbuflen - codeLength;\n    this.ip = ip;\n\n    return codeWithLength & 0xffff;\n  };\n\n  /**\n   * parse uncompressed block.\n   */\n  RawInflate.prototype.parseUncompressedBlock = function() {\n    var input = this.input;\n    var ip = this.ip;\n    var output = this.output;\n    var op = this.op;\n\n    /** @type {number} */\n    var inputLength = input.length;\n    /** @type {number} block length */\n    var len;\n    /** @type {number} number for check block length */\n    var nlen;\n    /** @type {number} output buffer length */\n    var olength = output.length;\n    /** @type {number} copy counter */\n    var preCopy;\n\n    // skip buffered header bits\n    this.bitsbuf = 0;\n    this.bitsbuflen = 0;\n\n    // len\n    if (ip + 1 >= inputLength) {\n      throw new Error('invalid uncompressed block header: LEN');\n    }\n    len = input[ip++] | (input[ip++] << 8);\n\n    // nlen\n    if (ip + 1 >= inputLength) {\n      throw new Error('invalid uncompressed block header: NLEN');\n    }\n    nlen = input[ip++] | (input[ip++] << 8);\n\n    // check len & nlen\n    if (len === ~nlen) {\n      throw new Error('invalid uncompressed block header: length verify');\n    }\n\n    // check size\n    if (ip + len > input.length) { throw new Error('input buffer is broken'); }\n\n    // expand buffer\n    switch (this.bufferType) {\n      case RawInflate.BufferType.BLOCK:\n        // pre copy\n        while (op + len > output.length) {\n          preCopy = olength - op;\n          len -= preCopy;\n          if (USE_TYPEDARRAY) {\n            output.set(input.subarray(ip, ip + preCopy), op);\n            op += preCopy;\n            ip += preCopy;\n          } else {\n            while (preCopy--) {\n              output[op++] = input[ip++];\n            }\n          }\n          this.op = op;\n          output = this.expandBuffer();\n          op = this.op;\n        }\n        break;\n      case RawInflate.BufferType.ADAPTIVE:\n        while (op + len > output.length) {\n          output = this.expandBuffer({fixRatio: 2});\n        }\n        break;\n      default:\n        throw new Error('invalid inflate mode');\n    }\n\n    // copy\n    if (USE_TYPEDARRAY) {\n      output.set(input.subarray(ip, ip + len), op);\n      op += len;\n      ip += len;\n    } else {\n      while (len--) {\n        output[op++] = input[ip++];\n      }\n    }\n\n    this.ip = ip;\n    this.op = op;\n    this.output = output;\n  };\n\n  /**\n   * parse fixed huffman block.\n   */\n  RawInflate.prototype.parseFixedHuffmanBlock = function() {\n    this.decodeHuffman(\n      RawInflate.FixedLiteralLengthTable,\n      RawInflate.FixedDistanceTable\n    );\n  };\n\n  /**\n   * parse dynamic huffman block.\n   */\n  RawInflate.prototype.parseDynamicHuffmanBlock = function() {\n    /** @type {number} number of literal and length codes. */\n    var hlit = this.readBits(5) + 257;\n    /** @type {number} number of distance codes. */\n    var hdist = this.readBits(5) + 1;\n    /** @type {number} number of code lengths. */\n    var hclen = this.readBits(4) + 4;\n    /** @type {!(Uint8Array|Array.<number>)} code lengths. */\n    var codeLengths =\n      new (USE_TYPEDARRAY ? Uint8Array : Array)(RawInflate.Order.length);\n    /** @type {!Array} code lengths table. */\n    var codeLengthsTable;\n    /** @type {!(Uint8Array|Array.<number>)} literal and length code table. */\n    var litlenTable;\n    /** @type {!(Uint8Array|Array.<number>)} distance code table. */\n    var distTable;\n    /** @type {!(Uint8Array|Array.<number>)} code length table. */\n    var lengthTable;\n    /** @type {number} */\n    var code;\n    /** @type {number} */\n    var prev;\n    /** @type {number} */\n    var repeat;\n    /** @type {number} loop counter. */\n    var i;\n    /** @type {number} loop limit. */\n    var il;\n\n    // decode code lengths\n    for (i = 0; i < hclen; ++i) {\n      codeLengths[RawInflate.Order[i]] = this.readBits(3);\n    }\n    if (!USE_TYPEDARRAY) {\n      for (i = hclen, hclen = codeLengths.length; i < hclen; ++i) {\n        codeLengths[RawInflate.Order[i]] = 0;\n      }\n    }\n\n    // decode length table\n    codeLengthsTable = buildHuffmanTable(codeLengths);\n    lengthTable = new (USE_TYPEDARRAY ? Uint8Array : Array)(hlit + hdist);\n    for (i = 0, il = hlit + hdist; i < il;) {\n      code = this.readCodeByTable(codeLengthsTable);\n      switch (code) {\n        case 16:\n          repeat = 3 + this.readBits(2);\n          while (repeat--) { lengthTable[i++] = prev; }\n          break;\n        case 17:\n          repeat = 3 + this.readBits(3);\n          while (repeat--) { lengthTable[i++] = 0; }\n          prev = 0;\n          break;\n        case 18:\n          repeat = 11 + this.readBits(7);\n          while (repeat--) { lengthTable[i++] = 0; }\n          prev = 0;\n          break;\n        default:\n          lengthTable[i++] = code;\n          prev = code;\n          break;\n      }\n    }\n\n    litlenTable = USE_TYPEDARRAY\n      ? buildHuffmanTable(lengthTable.subarray(0, hlit))\n      : buildHuffmanTable(lengthTable.slice(0, hlit));\n    distTable = USE_TYPEDARRAY\n      ? buildHuffmanTable(lengthTable.subarray(hlit))\n      : buildHuffmanTable(lengthTable.slice(hlit));\n\n    this.decodeHuffman(litlenTable, distTable);\n  };\n\n  /**\n   * decode huffman code\n   * @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.\n   * @param {!(Array.<number>|Uint8Array)} dist distination code table.\n   */\n  RawInflate.prototype.decodeHuffman = function(litlen, dist) {\n    var output = this.output;\n    var op = this.op;\n\n    this.currentLitlenTable = litlen;\n\n    /** @type {number} output position limit. */\n    var olength = output.length - RawInflate.MaxCopyLength;\n    /** @type {number} huffman code. */\n    var code;\n    /** @type {number} table index. */\n    var ti;\n    /** @type {number} huffman code distination. */\n    var codeDist;\n    /** @type {number} huffman code length. */\n    var codeLength;\n\n    while ((code = this.readCodeByTable(litlen)) !== 256) {\n      // literal\n      if (code < 256) {\n        if (op >= olength) {\n          this.op = op;\n          output = this.expandBuffer();\n          op = this.op;\n        }\n        output[op++] = code;\n\n        continue;\n      }\n\n      // length code\n      ti = code - 257;\n      codeLength = RawInflate.LengthCodeTable[ti];\n      if (RawInflate.LengthExtraTable[ti] > 0) {\n        codeLength += this.readBits(RawInflate.LengthExtraTable[ti]);\n      }\n\n      // dist code\n      code = this.readCodeByTable(dist);\n      codeDist = RawInflate.DistCodeTable[code];\n      if (RawInflate.DistExtraTable[code] > 0) {\n        codeDist += this.readBits(RawInflate.DistExtraTable[code]);\n      }\n\n      // lz77 decode\n      if (op >= olength) {\n        this.op = op;\n        output = this.expandBuffer();\n        op = this.op;\n      }\n      while (codeLength--) {\n        output[op] = output[(op++) - codeDist];\n      }\n    }\n\n    while (this.bitsbuflen >= 8) {\n      this.bitsbuflen -= 8;\n      this.ip--;\n    }\n    this.op = op;\n  };\n\n  /**\n   * decode huffman code (adaptive)\n   * @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.\n   * @param {!(Array.<number>|Uint8Array)} dist distination code table.\n   */\n  RawInflate.prototype.decodeHuffmanAdaptive = function(litlen, dist) {\n    var output = this.output;\n    var op = this.op;\n\n    this.currentLitlenTable = litlen;\n\n    /** @type {number} output position limit. */\n    var olength = output.length;\n    /** @type {number} huffman code. */\n    var code;\n    /** @type {number} table index. */\n    var ti;\n    /** @type {number} huffman code distination. */\n    var codeDist;\n    /** @type {number} huffman code length. */\n    var codeLength;\n\n    while ((code = this.readCodeByTable(litlen)) !== 256) {\n      // literal\n      if (code < 256) {\n        if (op >= olength) {\n          output = this.expandBuffer();\n          olength = output.length;\n        }\n        output[op++] = code;\n\n        continue;\n      }\n\n      // length code\n      ti = code - 257;\n      codeLength = RawInflate.LengthCodeTable[ti];\n      if (RawInflate.LengthExtraTable[ti] > 0) {\n        codeLength += this.readBits(RawInflate.LengthExtraTable[ti]);\n      }\n\n      // dist code\n      code = this.readCodeByTable(dist);\n      codeDist = RawInflate.DistCodeTable[code];\n      if (RawInflate.DistExtraTable[code] > 0) {\n        codeDist += this.readBits(RawInflate.DistExtraTable[code]);\n      }\n\n      // lz77 decode\n      if (op + codeLength > olength) {\n        output = this.expandBuffer();\n        olength = output.length;\n      }\n      while (codeLength--) {\n        output[op] = output[(op++) - codeDist];\n      }\n    }\n\n    while (this.bitsbuflen >= 8) {\n      this.bitsbuflen -= 8;\n      this.ip--;\n    }\n    this.op = op;\n  };\n\n  /**\n   * expand output buffer.\n   * @param {Object=} opt_param option parameters.\n   * @return {!(Array.<number>|Uint8Array)} output buffer.\n   */\n  RawInflate.prototype.expandBuffer = function(opt_param) {\n    /** @type {!(Array.<number>|Uint8Array)} store buffer. */\n    var buffer =\n      new (USE_TYPEDARRAY ? Uint8Array : Array)(\n          this.op - RawInflate.MaxBackwardLength\n      );\n    /** @type {number} backward base point */\n    var backward = this.op - RawInflate.MaxBackwardLength;\n    /** @type {number} copy index. */\n    var i;\n    /** @type {number} copy limit */\n    var il;\n\n    var output = this.output;\n\n    // copy to output buffer\n    if (USE_TYPEDARRAY) {\n      buffer.set(output.subarray(RawInflate.MaxBackwardLength, buffer.length));\n    } else {\n      for (i = 0, il = buffer.length; i < il; ++i) {\n        buffer[i] = output[i + RawInflate.MaxBackwardLength];\n      }\n    }\n\n    this.blocks.push(buffer);\n    this.totalpos += buffer.length;\n\n    // copy to backward buffer\n    if (USE_TYPEDARRAY) {\n      output.set(\n        output.subarray(backward, backward + RawInflate.MaxBackwardLength)\n      );\n    } else {\n      for (i = 0; i < RawInflate.MaxBackwardLength; ++i) {\n        output[i] = output[backward + i];\n      }\n    }\n\n    this.op = RawInflate.MaxBackwardLength;\n\n    return output;\n  };\n\n  /**\n   * expand output buffer. (adaptive)\n   * @param {Object=} opt_param option parameters.\n   * @return {!(Array.<number>|Uint8Array)} output buffer pointer.\n   */\n  RawInflate.prototype.expandBufferAdaptive = function(opt_param) {\n    /** @type {!(Array.<number>|Uint8Array)} store buffer. */\n    var buffer;\n    /** @type {number} expantion ratio. */\n    var ratio = (this.input.length / this.ip + 1) | 0;\n    /** @type {number} maximum number of huffman code. */\n    var maxHuffCode;\n    /** @type {number} new output buffer size. */\n    var newSize;\n    /** @type {number} max inflate size. */\n    var maxInflateSize;\n\n    var input = this.input;\n    var output = this.output;\n\n    if (opt_param) {\n      if (typeof opt_param.fixRatio === 'number') {\n        ratio = opt_param.fixRatio;\n      }\n      if (typeof opt_param.addRatio === 'number') {\n        ratio += opt_param.addRatio;\n      }\n    }\n\n    // calculate new buffer size\n    if (ratio < 2) {\n      maxHuffCode =\n        (input.length - this.ip) / this.currentLitlenTable[2];\n      maxInflateSize = (maxHuffCode / 2 * 258) | 0;\n      newSize = maxInflateSize < output.length ?\n        output.length + maxInflateSize :\n        output.length << 1;\n    } else {\n      newSize = output.length * ratio;\n    }\n\n    // buffer expantion\n    if (USE_TYPEDARRAY) {\n      buffer = new Uint8Array(newSize);\n      buffer.set(output);\n    } else {\n      buffer = output;\n    }\n\n    this.output = buffer;\n\n    return this.output;\n  };\n\n  /**\n   * concat output buffer.\n   * @return {!(Array.<number>|Uint8Array)} output buffer.\n   */\n  RawInflate.prototype.concatBuffer = function() {\n    /** @type {number} buffer pointer. */\n    var pos = 0;\n    /** @type {number} buffer pointer. */\n    var limit = this.totalpos + (this.op - RawInflate.MaxBackwardLength);\n    /** @type {!(Array.<number>|Uint8Array)} output block array. */\n    var output = this.output;\n    /** @type {!Array} blocks array. */\n    var blocks = this.blocks;\n    /** @type {!(Array.<number>|Uint8Array)} output block array. */\n    var block;\n    /** @type {!(Array.<number>|Uint8Array)} output buffer. */\n    var buffer = new (USE_TYPEDARRAY ? Uint8Array : Array)(limit);\n    /** @type {number} loop counter. */\n    var i;\n    /** @type {number} loop limiter. */\n    var il;\n    /** @type {number} loop counter. */\n    var j;\n    /** @type {number} loop limiter. */\n    var jl;\n\n    // single buffer\n    if (blocks.length === 0) {\n      return USE_TYPEDARRAY ?\n        this.output.subarray(RawInflate.MaxBackwardLength, this.op) :\n        this.output.slice(RawInflate.MaxBackwardLength, this.op);\n    }\n\n    // copy to buffer\n    for (i = 0, il = blocks.length; i < il; ++i) {\n      block = blocks[i];\n      for (j = 0, jl = block.length; j < jl; ++j) {\n        buffer[pos++] = block[j];\n      }\n    }\n\n    // current buffer\n    for (i = RawInflate.MaxBackwardLength, il = this.op; i < il; ++i) {\n      buffer[pos++] = output[i];\n    }\n\n    this.blocks = [];\n    this.buffer = buffer;\n\n    return this.buffer;\n  };\n\n  /**\n   * concat output buffer. (dynamic)\n   * @return {!(Array.<number>|Uint8Array)} output buffer.\n   */\n  RawInflate.prototype.concatBufferDynamic = function() {\n    /** @type {Array.<number>|Uint8Array} output buffer. */\n    var buffer;\n    var op = this.op;\n\n    if (USE_TYPEDARRAY) {\n      if (this.resize) {\n        buffer = new Uint8Array(op);\n        buffer.set(this.output.subarray(0, op));\n      } else {\n        buffer = this.output.subarray(0, op);\n      }\n    } else {\n      if (this.output.length > op) {\n        this.output.length = op;\n      }\n      buffer = this.output;\n    }\n\n    this.buffer = buffer;\n\n    return this.buffer;\n  };\n\n  return Zlib.RawInflate = RawInflate;\n});\n\n\n\n"]}