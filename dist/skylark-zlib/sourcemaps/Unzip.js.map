{"version":3,"sources":["Unzip.js"],"names":["define","Zlib","RawInflate","Zip","Unzip","input","opt_params","this","Array","Uint8Array","ip","eocdrOffset","numberOfThisDisk","startDisk","totalEntriesThisDisk","totalEntries","centralDirectorySize","centralDirectoryOffset","commentLength","comment","fileHeaderList","filenameToIndex","verify","password","CompressionMethod","FileHeaderSignature","LocalFileHeaderSignature","CentralDirectorySignature","FileHeader","offset","length","version","os","needVersion","flags","compression","time","date","crc32","compressedSize","plainSize","fileNameLength","extraFieldLength","fileCommentLength","diskNumberStart","internalFileAttributes","externalFileAttributes","relativeOffset","filename","extraField","prototype","parse","Error","String","fromCharCode","apply","subarray","LocalFileHeader","Flags","searchEndOfCentralDirectoryRecord","parseEndOfCentralDirectoryRecord","parseFileHeader","fileHeader","i","il","filelist","filetable","getFileData","index","localFileHeader","buffer","key","ENCRYPT","createDecryptionKey","decode","STORE","DEFLATE","bufferSize","decompress","CRC32","calc","toString","getFilenames","filenameList","setPassword","n","getByte","updateKeys","createEncryptionKey"],"mappings":"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","file":"../Unzip.js","sourcesContent":["define([\n  \"./zlib\",\n  \"./crc32\",\n  \"./RawInflate\",\n  \"./Zip\"\n],function(Zlib,RawInflate,Zip) {\n  const USE_TYPEDARRAY = true;\n\n  /**\n   * @param {!(Array.<number>|Uint8Array)} input input buffer.\n   * @param {Object=} opt_params options.\n   * @constructor\n   */\n  var Unzip = function(input, opt_params) {\n    opt_params = opt_params || {};\n    /** @type {!(Array.<number>|Uint8Array)} */\n    this.input =\n      (USE_TYPEDARRAY && (input instanceof Array)) ?\n      new Uint8Array(input) : input;\n    /** @type {number} */\n    this.ip = 0;\n    /** @type {number} */\n    this.eocdrOffset;\n    /** @type {number} */\n    this.numberOfThisDisk;\n    /** @type {number} */\n    this.startDisk;\n    /** @type {number} */\n    this.totalEntriesThisDisk;\n    /** @type {number} */\n    this.totalEntries;\n    /** @type {number} */\n    this.centralDirectorySize;\n    /** @type {number} */\n    this.centralDirectoryOffset;\n    /** @type {number} */\n    this.commentLength;\n    /** @type {(Array.<number>|Uint8Array)} */\n    this.comment;\n    /** @type {Array.<Unzip.FileHeader>} */\n    this.fileHeaderList;\n    /** @type {Object.<string, number>} */\n    this.filenameToIndex;\n    /** @type {boolean} */\n    this.verify = opt_params['verify'] || false;\n    /** @type {(Array.<number>|Uint8Array)} */\n    this.password = opt_params['password'];\n  };\n\n  Unzip.CompressionMethod = Zip.CompressionMethod;\n\n  /**\n   * @type {Array.<number>}\n   * @const\n   */\n  Unzip.FileHeaderSignature = Zip.FileHeaderSignature;\n\n  /**\n   * @type {Array.<number>}\n   * @const\n   */\n  Unzip.LocalFileHeaderSignature = Zip.LocalFileHeaderSignature;\n\n  /**\n   * @type {Array.<number>}\n   * @const\n   */\n  Unzip.CentralDirectorySignature = Zip.CentralDirectorySignature;\n\n  /**\n   * @param {!(Array.<number>|Uint8Array)} input input buffer.\n   * @param {number} ip input position.\n   * @constructor\n   */\n  Unzip.FileHeader = function(input, ip) {\n    /** @type {!(Array.<number>|Uint8Array)} */\n    this.input = input;\n    /** @type {number} */\n    this.offset = ip;\n    /** @type {number} */\n    this.length;\n    /** @type {number} */\n    this.version;\n    /** @type {number} */\n    this.os;\n    /** @type {number} */\n    this.needVersion;\n    /** @type {number} */\n    this.flags;\n    /** @type {number} */\n    this.compression;\n    /** @type {number} */\n    this.time;\n    /** @type {number} */\n    this.date;\n    /** @type {number} */\n    this.crc32;\n    /** @type {number} */\n    this.compressedSize;\n    /** @type {number} */\n    this.plainSize;\n    /** @type {number} */\n    this.fileNameLength;\n    /** @type {number} */\n    this.extraFieldLength;\n    /** @type {number} */\n    this.fileCommentLength;\n    /** @type {number} */\n    this.diskNumberStart;\n    /** @type {number} */\n    this.internalFileAttributes;\n    /** @type {number} */\n    this.externalFileAttributes;\n    /** @type {number} */\n    this.relativeOffset;\n    /** @type {string} */\n    this.filename;\n    /** @type {!(Array.<number>|Uint8Array)} */\n    this.extraField;\n    /** @type {!(Array.<number>|Uint8Array)} */\n    this.comment;\n  };\n\n  Unzip.FileHeader.prototype.parse = function() {\n    /** @type {!(Array.<number>|Uint8Array)} */\n    var input = this.input;\n    /** @type {number} */\n    var ip = this.offset;\n\n    // central file header signature\n    if (input[ip++] !== Unzip.FileHeaderSignature[0] ||\n        input[ip++] !== Unzip.FileHeaderSignature[1] ||\n        input[ip++] !== Unzip.FileHeaderSignature[2] ||\n        input[ip++] !== Unzip.FileHeaderSignature[3]) {\n      throw new Error('invalid file header signature');\n    }\n\n    // version made by\n    this.version = input[ip++];\n    this.os = input[ip++];\n\n    // version needed to extract\n    this.needVersion = input[ip++] | (input[ip++] << 8);\n\n    // general purpose bit flag\n    this.flags = input[ip++] | (input[ip++] << 8);\n\n    // compression method\n    this.compression = input[ip++] | (input[ip++] << 8);\n\n    // last mod file time\n    this.time = input[ip++] | (input[ip++] << 8);\n\n    //last mod file date\n    this.date = input[ip++] | (input[ip++] << 8);\n\n    // crc-32\n    this.crc32 = (\n      (input[ip++]      ) | (input[ip++] <<  8) |\n      (input[ip++] << 16) | (input[ip++] << 24)\n    ) >>> 0;\n\n    // compressed size\n    this.compressedSize = (\n      (input[ip++]      ) | (input[ip++] <<  8) |\n      (input[ip++] << 16) | (input[ip++] << 24)\n    ) >>> 0;\n\n    // uncompressed size\n    this.plainSize = (\n      (input[ip++]      ) | (input[ip++] <<  8) |\n      (input[ip++] << 16) | (input[ip++] << 24)\n    ) >>> 0;\n\n    // file name length\n    this.fileNameLength = input[ip++] | (input[ip++] << 8);\n\n    // extra field length\n    this.extraFieldLength = input[ip++] | (input[ip++] << 8);\n\n    // file comment length\n    this.fileCommentLength = input[ip++] | (input[ip++] << 8);\n\n    // disk number start\n    this.diskNumberStart = input[ip++] | (input[ip++] << 8);\n\n    // internal file attributes\n    this.internalFileAttributes = input[ip++] | (input[ip++] << 8);\n\n    // external file attributes\n    this.externalFileAttributes =\n      (input[ip++]      ) | (input[ip++] <<  8) |\n      (input[ip++] << 16) | (input[ip++] << 24);\n\n    // relative offset of local header\n    this.relativeOffset = (\n      (input[ip++]      ) | (input[ip++] <<  8) |\n      (input[ip++] << 16) | (input[ip++] << 24)\n    ) >>> 0;\n\n    // file name\n    this.filename = String.fromCharCode.apply(null, USE_TYPEDARRAY ?\n      input.subarray(ip, ip += this.fileNameLength) :\n      input.slice(ip, ip += this.fileNameLength)\n    );\n\n    // extra field\n    this.extraField = USE_TYPEDARRAY ?\n      input.subarray(ip, ip += this.extraFieldLength) :\n      input.slice(ip, ip += this.extraFieldLength);\n\n    // file comment\n    this.comment = USE_TYPEDARRAY ?\n      input.subarray(ip, ip + this.fileCommentLength) :\n      input.slice(ip, ip + this.fileCommentLength);\n\n    this.length = ip - this.offset;\n  };\n\n  /**\n   * @param {!(Array.<number>|Uint8Array)} input input buffer.\n   * @param {number} ip input position.\n   * @constructor\n   */\n  Unzip.LocalFileHeader = function(input, ip) {\n    /** @type {!(Array.<number>|Uint8Array)} */\n    this.input = input;\n    /** @type {number} */\n    this.offset = ip;\n    /** @type {number} */\n    this.length;\n    /** @type {number} */\n    this.needVersion;\n    /** @type {number} */\n    this.flags;\n    /** @type {number} */\n    this.compression;\n    /** @type {number} */\n    this.time;\n    /** @type {number} */\n    this.date;\n    /** @type {number} */\n    this.crc32;\n    /** @type {number} */\n    this.compressedSize;\n    /** @type {number} */\n    this.plainSize;\n    /** @type {number} */\n    this.fileNameLength;\n    /** @type {number} */\n    this.extraFieldLength;\n    /** @type {string} */\n    this.filename;\n    /** @type {!(Array.<number>|Uint8Array)} */\n    this.extraField;\n  };\n\n  Unzip.LocalFileHeader.Flags = Zip.Flags;\n\n  Unzip.LocalFileHeader.prototype.parse = function() {\n    /** @type {!(Array.<number>|Uint8Array)} */\n    var input = this.input;\n    /** @type {number} */\n    var ip = this.offset;\n\n    // local file header signature\n    if (input[ip++] !== Unzip.LocalFileHeaderSignature[0] ||\n        input[ip++] !== Unzip.LocalFileHeaderSignature[1] ||\n        input[ip++] !== Unzip.LocalFileHeaderSignature[2] ||\n        input[ip++] !== Unzip.LocalFileHeaderSignature[3]) {\n      throw new Error('invalid local file header signature');\n    }\n\n    // version needed to extract\n    this.needVersion = input[ip++] | (input[ip++] << 8);\n\n    // general purpose bit flag\n    this.flags = input[ip++] | (input[ip++] << 8);\n\n    // compression method\n    this.compression = input[ip++] | (input[ip++] << 8);\n\n    // last mod file time\n    this.time = input[ip++] | (input[ip++] << 8);\n\n    //last mod file date\n    this.date = input[ip++] | (input[ip++] << 8);\n\n    // crc-32\n    this.crc32 = (\n      (input[ip++]      ) | (input[ip++] <<  8) |\n      (input[ip++] << 16) | (input[ip++] << 24)\n    ) >>> 0;\n\n    // compressed size\n    this.compressedSize = (\n      (input[ip++]      ) | (input[ip++] <<  8) |\n      (input[ip++] << 16) | (input[ip++] << 24)\n    ) >>> 0;\n\n    // uncompressed size\n    this.plainSize = (\n      (input[ip++]      ) | (input[ip++] <<  8) |\n      (input[ip++] << 16) | (input[ip++] << 24)\n    ) >>> 0;\n\n    // file name length\n    this.fileNameLength = input[ip++] | (input[ip++] << 8);\n\n    // extra field length\n    this.extraFieldLength = input[ip++] | (input[ip++] << 8);\n\n    // file name\n    this.filename = String.fromCharCode.apply(null, USE_TYPEDARRAY ?\n      input.subarray(ip, ip += this.fileNameLength) :\n      input.slice(ip, ip += this.fileNameLength)\n    );\n\n    // extra field\n    this.extraField = USE_TYPEDARRAY ?\n      input.subarray(ip, ip += this.extraFieldLength) :\n      input.slice(ip, ip += this.extraFieldLength);\n\n    this.length = ip - this.offset;\n  };\n\n\n  Unzip.prototype.searchEndOfCentralDirectoryRecord = function() {\n    /** @type {!(Array.<number>|Uint8Array)} */\n    var input = this.input;\n    /** @type {number} */\n    var ip;\n\n    for (ip = input.length - 12; ip > 0; --ip) {\n      if (input[ip  ] === Unzip.CentralDirectorySignature[0] &&\n          input[ip+1] === Unzip.CentralDirectorySignature[1] &&\n          input[ip+2] === Unzip.CentralDirectorySignature[2] &&\n          input[ip+3] === Unzip.CentralDirectorySignature[3]) {\n        this.eocdrOffset = ip;\n        return;\n      }\n    }\n\n    throw new Error('End of Central Directory Record not found');\n  };\n\n  Unzip.prototype.parseEndOfCentralDirectoryRecord = function() {\n    /** @type {!(Array.<number>|Uint8Array)} */\n    var input = this.input;\n    /** @type {number} */\n    var ip;\n\n    if (!this.eocdrOffset) {\n      this.searchEndOfCentralDirectoryRecord();\n    }\n    ip = this.eocdrOffset;\n\n    // signature\n    if (input[ip++] !== Unzip.CentralDirectorySignature[0] ||\n        input[ip++] !== Unzip.CentralDirectorySignature[1] ||\n        input[ip++] !== Unzip.CentralDirectorySignature[2] ||\n        input[ip++] !== Unzip.CentralDirectorySignature[3]) {\n      throw new Error('invalid signature');\n    }\n\n    // number of this disk\n    this.numberOfThisDisk = input[ip++] | (input[ip++] << 8);\n\n    // number of the disk with the start of the central directory\n    this.startDisk = input[ip++] | (input[ip++] << 8);\n\n    // total number of entries in the central directory on this disk\n    this.totalEntriesThisDisk = input[ip++] | (input[ip++] << 8);\n\n    // total number of entries in the central directory\n    this.totalEntries = input[ip++] | (input[ip++] << 8);\n\n    // size of the central directory\n    this.centralDirectorySize = (\n      (input[ip++]      ) | (input[ip++] <<  8) |\n      (input[ip++] << 16) | (input[ip++] << 24)\n    ) >>> 0;\n\n    // offset of start of central directory with respect to the starting disk number\n    this.centralDirectoryOffset = (\n      (input[ip++]      ) | (input[ip++] <<  8) |\n      (input[ip++] << 16) | (input[ip++] << 24)\n    ) >>> 0;\n\n    // .ZIP file comment length\n    this.commentLength = input[ip++] | (input[ip++] << 8);\n\n    // .ZIP file comment\n    this.comment = USE_TYPEDARRAY ?\n      input.subarray(ip, ip + this.commentLength) :\n      input.slice(ip, ip + this.commentLength);\n  };\n\n  Unzip.prototype.parseFileHeader = function() {\n    /** @type {Array.<Unzip.FileHeader>} */\n    var filelist = [];\n    /** @type {Object.<string, number>} */\n    var filetable = {};\n    /** @type {number} */\n    var ip;\n    /** @type {Unzip.FileHeader} */\n    var fileHeader;\n    /*: @type {number} */\n    var i;\n    /*: @type {number} */\n    var il;\n\n    if (this.fileHeaderList) {\n      return;\n    }\n\n    if (this.centralDirectoryOffset === void 0) {\n      this.parseEndOfCentralDirectoryRecord();\n    }\n    ip = this.centralDirectoryOffset;\n\n    for (i = 0, il = this.totalEntries; i < il; ++i) {\n      fileHeader = new Unzip.FileHeader(this.input, ip);\n      fileHeader.parse();\n      ip += fileHeader.length;\n      filelist[i] = fileHeader;\n      filetable[fileHeader.filename] = i;\n    }\n\n    if (this.centralDirectorySize < ip - this.centralDirectoryOffset) {\n      throw new Error('invalid file header size');\n    }\n\n    this.fileHeaderList = filelist;\n    this.filenameToIndex = filetable;\n  };\n\n  /**\n   * @param {number} index file header index.\n   * @param {Object=} opt_params\n   * @return {!(Array.<number>|Uint8Array)} file data.\n   */\n  Unzip.prototype.getFileData = function(index, opt_params) {\n    opt_params = opt_params || {};\n    /** @type {!(Array.<number>|Uint8Array)} */\n    var input = this.input;\n    /** @type {Array.<Unzip.FileHeader>} */\n    var fileHeaderList = this.fileHeaderList;\n    /** @type {Unzip.LocalFileHeader} */\n    var localFileHeader;\n    /** @type {number} */\n    var offset;\n    /** @type {number} */\n    var length;\n    /** @type {!(Array.<number>|Uint8Array)} */\n    var buffer;\n    /** @type {number} */\n    var crc32;\n    /** @type {Array.<number>|Uint32Array|Object} */\n    var key;\n    /** @type {number} */\n    var i;\n    /** @type {number} */\n    var il;\n\n    if (!fileHeaderList) {\n      this.parseFileHeader();\n    }\n\n    if (fileHeaderList[index] === void 0) {\n      throw new Error('wrong index');\n    }\n\n    offset = fileHeaderList[index].relativeOffset;\n    localFileHeader = new Unzip.LocalFileHeader(this.input, offset);\n    localFileHeader.parse();\n    offset += localFileHeader.length;\n    length = localFileHeader.compressedSize;\n\n    // decryption\n    if ((localFileHeader.flags & Unzip.LocalFileHeader.Flags.ENCRYPT) !== 0) {\n      if (!(opt_params['password'] || this.password)) {\n        throw new Error('please set password');\n      }\n      key =  this.createDecryptionKey(opt_params['password'] || this.password);\n\n      // encryption header\n      for(i = offset, il = offset + 12; i < il; ++i) {\n        this.decode(key, input[i]);\n      }\n      offset += 12;\n      length -= 12;\n\n      // decryption\n      for (i = offset, il = offset + length; i < il; ++i) {\n        input[i] = this.decode(key, input[i]);\n      }\n    }\n\n    switch (localFileHeader.compression) {\n      case Unzip.CompressionMethod.STORE:\n        buffer = USE_TYPEDARRAY ?\n          this.input.subarray(offset, offset + length) :\n          this.input.slice(offset, offset + length);\n        break;\n      case Unzip.CompressionMethod.DEFLATE:\n        buffer = new RawInflate(this.input, {\n          'index': offset,\n          'bufferSize': localFileHeader.plainSize\n        }).decompress();\n        break;\n      default:\n        throw new Error('unknown compression type');\n    }\n\n    if (this.verify) {\n      crc32 = CRC32.calc(buffer);\n      if (localFileHeader.crc32 !== crc32) {\n        throw new Error(\n          'wrong crc: file=0x' + localFileHeader.crc32.toString(16) +\n          ', data=0x' + crc32.toString(16)\n        );\n      }\n    }\n\n    return buffer;\n  };\n\n  /**\n   * @return {Array.<string>}\n   */\n  Unzip.prototype.getFilenames = function() {\n    /** @type {Array.<string>} */\n    var filenameList = [];\n    /** @type {number} */\n    var i;\n    /** @type {number} */\n    var il;\n    /** @type {Array.<Unzip.FileHeader>} */\n    var fileHeaderList;\n\n    if (!this.fileHeaderList) {\n      this.parseFileHeader();\n    }\n    fileHeaderList = this.fileHeaderList;\n\n    for (i = 0, il = fileHeaderList.length; i < il; ++i) {\n      filenameList[i] = fileHeaderList[i].filename;\n    }\n\n    return filenameList;\n  };\n\n  /**\n   * @param {string} filename extract filename.\n   * @param {Object=} opt_params\n   * @return {!(Array.<number>|Uint8Array)} decompressed data.\n   */\n  Unzip.prototype.decompress = function(filename, opt_params) {\n    /** @type {number} */\n    var index;\n\n    if (!this.filenameToIndex) {\n      this.parseFileHeader();\n    }\n    index = this.filenameToIndex[filename];\n\n    if (index === void 0) {\n      throw new Error(filename + ' not found');\n    }\n\n    return this.getFileData(index, opt_params);\n  };\n\n  /**\n   * @param {(Array.<number>|Uint8Array)} password\n   */\n  Unzip.prototype.setPassword = function(password) {\n    this.password = password;\n  };\n\n  /**\n   * @param {(Array.<number>|Uint32Array|Object)} key\n   * @param {number} n\n   * @return {number}\n   */\n  Unzip.prototype.decode = function(key, n) {\n    n ^= this.getByte(/** @type {(Array.<number>|Uint32Array)} */(key));\n    this.updateKeys(/** @type {(Array.<number>|Uint32Array)} */(key), n);\n\n    return n;\n  };\n\n  // common method\n  Unzip.prototype.updateKeys = Zip.prototype.updateKeys;\n  Unzip.prototype.createDecryptionKey = Zip.prototype.createEncryptionKey;\n  Unzip.prototype.getByte = Zip.prototype.getByte;\n\n  return Zlib.Unzip = Unzip;\n\n});\n\n\n"]}