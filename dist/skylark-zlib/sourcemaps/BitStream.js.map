{"version":3,"sources":["BitStream.js"],"names":["define","Zlib","BitStream","buffer","bufferPosition","this","index","bitindex","Uint8Array","DefaultBlockSize","length","Error","expandBuffer","prototype","oldbuf","il","set","writeBits","number","n","reverse","i","current","ReverseTable","rev32_","finish","subarray","table","r","s"],"mappings":";;;;;;;AAAAA,QACE,UACA,SAASC,GAYT,IAAIC,EAAY,SAASC,EAAQC,GAW/B,GATAC,KAAKC,MAAkC,iBAAnBF,EAA8BA,EAAiB,EAEnEC,KAAKE,SAAW,EAEhBF,KAAKF,OAASA,aAAoCK,WAChDL,EACA,IAAsBK,WAAoBN,EAAUO,kBAG7B,EAArBJ,KAAKF,OAAOO,QAAcL,KAAKC,MACjC,MAAM,IAAIK,MAAM,iBACPN,KAAKF,OAAOO,QAAUL,KAAKC,OACpCD,KAAKO,gBAsKT,OA7JAV,EAAUO,iBAAmB,MAM7BP,EAAUW,UAAUD,aAAe,WAEjC,IAAIE,EAAST,KAAKF,OAIdY,EAAKD,EAAOJ,OAEZP,EACF,IAAsBK,WAAoBO,GAAM,GAYlD,OAREZ,EAAOa,IAAIF,GAQLT,KAAKF,OAASA,GAUxBD,EAAUW,UAAUI,UAAY,SAASC,EAAQC,EAAGC,GAClD,IAOIC,EAPAlB,EAASE,KAAKF,OACdG,EAAQD,KAAKC,MACbC,EAAWF,KAAKE,SAGhBe,EAAUnB,EAAOG,GAwBrB,GAPIc,GAAWD,EAAI,IACjBD,EAASC,EAAI,EARf,SAAgBA,GACd,OAAQjB,EAAUqB,aAAiB,IAAJJ,IAAa,GACzCjB,EAAUqB,aAAaJ,IAAM,EAAI,MAAS,GAC1CjB,EAAUqB,aAAaJ,IAAM,GAAK,MAAS,EAC5CjB,EAAUqB,aAAaJ,IAAM,GAAK,KAKlCK,CAAON,IAAY,GAAKC,EACxBjB,EAAUqB,aAAaL,IAAY,EAAIC,GAIvCA,EAAIZ,EAAW,EACjBe,EAAWA,GAAWH,EAAKD,EAC3BX,GAAYY,OAGZ,IAAKE,EAAI,EAAGA,EAAIF,IAAKE,EACnBC,EAAWA,GAAW,EAAOJ,GAAUC,EAAIE,EAAI,EAAK,EAGjC,KAAbd,IACJA,EAAW,EACXJ,EAAOG,KAAWJ,EAAUqB,aAAaD,GACzCA,EAAU,EAGNhB,IAAUH,EAAOO,SACnBP,EAASE,KAAKO,iBAKtBT,EAAOG,GAASgB,EAEhBjB,KAAKF,OAASA,EACdE,KAAKE,SAAWA,EAChBF,KAAKC,MAAQA,GAQfJ,EAAUW,UAAUY,OAAS,WAC3B,IAAItB,EAASE,KAAKF,OACdG,EAAQD,KAAKC,MAoBjB,OAdID,KAAKE,SAAW,IAClBJ,EAAOG,KAAW,EAAID,KAAKE,SAC3BJ,EAAOG,GAASJ,EAAUqB,aAAapB,EAAOG,IAC9CA,KAKSH,EAAOuB,SAAS,EAAGpB,IAchCJ,EAAUqB,aAEP,WAED,IAEIF,EAFAM,EAAQ,IAAsBnB,WAAoB,KAKtD,IAAKa,EAAI,EAAGA,EAAI,MAAOA,EACrBM,EAAMN,GAAK,SAAUF,GACnB,IAAIS,EAAIT,EACJU,EAAI,EAER,IAAKV,KAAO,EAAGA,EAAGA,KAAO,EACvBS,IAAM,EACNA,GAAS,EAAJT,IACHU,EAGJ,OAAQD,GAAKC,EAAI,OAAU,EAVlB,CAWRR,GAGL,OAAOM,EAtBN,GAyBI1B,EAAKC,UAAYA","file":"../BitStream.js","sourcesContent":["define([\r\n  \"./zlib\"\r\n],function(Zlib) {\r\n  const USE_TYPEDARRAY = true;\r\n  /**\r\n   * @fileoverview bit 単位での書き込み実装.\r\n   */\r\n\r\n  /**\r\n   * ビットストリーム\r\n   * @constructor\r\n   * @param {!(Array|Uint8Array)=} buffer output buffer.\r\n   * @param {number=} bufferPosition start buffer pointer.\r\n   */\r\n  var BitStream = function(buffer, bufferPosition) {\r\n    /** @type {number} buffer index. */\r\n    this.index = typeof bufferPosition === 'number' ? bufferPosition : 0;\r\n    /** @type {number} bit index. */\r\n    this.bitindex = 0;\r\n    /** @type {!(Array|Uint8Array)} bit-stream output buffer. */\r\n    this.buffer = buffer instanceof (USE_TYPEDARRAY ? Uint8Array : Array) ?\r\n      buffer :\r\n      new (USE_TYPEDARRAY ? Uint8Array : Array)(BitStream.DefaultBlockSize);\r\n\r\n    // 入力された index が足りなかったら拡張するが、倍にしてもダメなら不正とする\r\n    if (this.buffer.length * 2 <= this.index) {\r\n      throw new Error(\"invalid index\");\r\n    } else if (this.buffer.length <= this.index) {\r\n      this.expandBuffer();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * デフォルトブロックサイズ.\r\n   * @const\r\n   * @type {number}\r\n   */\r\n  BitStream.DefaultBlockSize = 0x8000;\r\n\r\n  /**\r\n   * expand buffer.\r\n   * @return {!(Array|Uint8Array)} new buffer.\r\n   */\r\n  BitStream.prototype.expandBuffer = function() {\r\n    /** @type {!(Array|Uint8Array)} old buffer. */\r\n    var oldbuf = this.buffer;\r\n    /** @type {number} loop counter. */\r\n    var i;\r\n    /** @type {number} loop limiter. */\r\n    var il = oldbuf.length;\r\n    /** @type {!(Array|Uint8Array)} new buffer. */\r\n    var buffer =\r\n      new (USE_TYPEDARRAY ? Uint8Array : Array)(il << 1);\r\n\r\n    // copy buffer\r\n    if (USE_TYPEDARRAY) {\r\n      buffer.set(oldbuf);\r\n    } else {\r\n      // XXX: loop unrolling\r\n      for (i = 0; i < il; ++i) {\r\n        buffer[i] = oldbuf[i];\r\n      }\r\n    }\r\n\r\n    return (this.buffer = buffer);\r\n  };\r\n\r\n\r\n  /**\r\n   * 数値をビットで指定した数だけ書き込む.\r\n   * @param {number} number 書き込む数値.\r\n   * @param {number} n 書き込むビット数.\r\n   * @param {boolean=} reverse 逆順に書き込むならば true.\r\n   */\r\n  BitStream.prototype.writeBits = function(number, n, reverse) {\r\n    var buffer = this.buffer;\r\n    var index = this.index;\r\n    var bitindex = this.bitindex;\r\n\r\n    /** @type {number} current octet. */\r\n    var current = buffer[index];\r\n    /** @type {number} loop counter. */\r\n    var i;\r\n\r\n    /**\r\n     * 32-bit 整数のビット順を逆にする\r\n     * @param {number} n 32-bit integer.\r\n     * @return {number} reversed 32-bit integer.\r\n     * @private\r\n     */\r\n    function rev32_(n) {\r\n      return (BitStream.ReverseTable[n & 0xFF] << 24) |\r\n        (BitStream.ReverseTable[n >>> 8 & 0xFF] << 16) |\r\n        (BitStream.ReverseTable[n >>> 16 & 0xFF] << 8) |\r\n        BitStream.ReverseTable[n >>> 24 & 0xFF];\r\n    }\r\n\r\n    if (reverse && n > 1) {\r\n      number = n > 8 ?\r\n        rev32_(number) >> (32 - n) :\r\n        BitStream.ReverseTable[number] >> (8 - n);\r\n    }\r\n\r\n    // Byte 境界を超えないとき\r\n    if (n + bitindex < 8) {\r\n      current = (current << n) | number;\r\n      bitindex += n;\r\n    // Byte 境界を超えるとき\r\n    } else {\r\n      for (i = 0; i < n; ++i) {\r\n        current = (current << 1) | ((number >> n - i - 1) & 1);\r\n\r\n        // next byte\r\n        if (++bitindex === 8) {\r\n          bitindex = 0;\r\n          buffer[index++] = BitStream.ReverseTable[current];\r\n          current = 0;\r\n\r\n          // expand\r\n          if (index === buffer.length) {\r\n            buffer = this.expandBuffer();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    buffer[index] = current;\r\n\r\n    this.buffer = buffer;\r\n    this.bitindex = bitindex;\r\n    this.index = index;\r\n  };\r\n\r\n\r\n  /**\r\n   * ストリームの終端処理を行う\r\n   * @return {!(Array|Uint8Array)} 終端処理後のバッファを byte array で返す.\r\n   */\r\n  BitStream.prototype.finish = function() {\r\n    var buffer = this.buffer;\r\n    var index = this.index;\r\n\r\n    /** @type {!(Array|Uint8Array)} output buffer. */\r\n    var output;\r\n\r\n    // bitindex が 0 の時は余分に index が進んでいる状態\r\n    if (this.bitindex > 0) {\r\n      buffer[index] <<= 8 - this.bitindex;\r\n      buffer[index] = BitStream.ReverseTable[buffer[index]];\r\n      index++;\r\n    }\r\n\r\n    // array truncation\r\n    if (USE_TYPEDARRAY) {\r\n      output = buffer.subarray(0, index);\r\n    } else {\r\n      buffer.length = index;\r\n      output = buffer;\r\n    }\r\n\r\n    return output;\r\n  };\r\n\r\n  /**\r\n   * 0-255 のビット順を反転したテーブル\r\n   * @const\r\n   * @type {!(Uint8Array|Array.<number>)}\r\n   */\r\n  BitStream.ReverseTable = (function(table) {\r\n    return table;\r\n  })((function() {\r\n    /** @type {!(Array|Uint8Array)} reverse table. */\r\n    var table = new (USE_TYPEDARRAY ? Uint8Array : Array)(256);\r\n    /** @type {number} loop counter. */\r\n    var i;\r\n\r\n    // generate\r\n    for (i = 0; i < 256; ++i) {\r\n      table[i] = (function(n) {\r\n        var r = n;\r\n        var s = 7;\r\n\r\n        for (n >>>= 1; n; n >>>= 1) {\r\n          r <<= 1;\r\n          r |= n & 1;\r\n          --s;\r\n        }\r\n\r\n        return (r << s & 0xff) >>> 0;\r\n      })(i);\r\n    }\r\n\r\n    return table;\r\n  })());\r\n\r\n  return Zlib.BitStream = BitStream;\r\n});\r\n\r\n\r\n"]}