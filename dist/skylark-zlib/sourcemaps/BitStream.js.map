{"version":3,"sources":["BitStream.js"],"names":["define","Zlib","BitStream","buffer","bufferPosition","this","index","bitindex","Uint8Array","DefaultBlockSize","length","Error","expandBuffer","prototype","oldbuf","il","set","writeBits","number","n","reverse","i","current","ReverseTable","rev32_","finish","subarray","table","r","s"],"mappings":";;;;;;;AAAAA,QACE,UACA,SAASC,GAYT,IAAIC,EAAY,SAASC,EAAQC,GAW/B,GATAC,KAAKC,MAAkC,iBAAnBF,EAA8BA,EAAiB,EAEnEC,KAAKE,SAAW,EAEhBF,KAAKF,OAASA,aAAoCK,WAChDL,EACA,IAAsBK,WAAoBN,EAAUO,kBAG7B,EAArBJ,KAAKF,OAAOO,QAAcL,KAAKC,MACjC,MAAM,IAAIK,MAAM,iBACPN,KAAKF,OAAOO,QAAUL,KAAKC,OACpCD,KAAKO,gBAsKT,OA7JAV,EAAUO,iBAAmB,MAM7BP,EAAUW,UAAUD,aAAe,WAEjC,IAAIE,EAAST,KAAKF,OAIdY,EAAKD,EAAOJ,OAEZP,EACF,IAAsBK,WAAoBO,GAAM,GAYlD,OAREZ,EAAOa,IAAIF,GAQLT,KAAKF,OAASA,GAUxBD,EAAUW,UAAUI,UAAY,SAASC,EAAQC,EAAGC,GAClD,IAOIC,EAPAlB,EAASE,KAAKF,OACdG,EAAQD,KAAKC,MACbC,EAAWF,KAAKE,SAGhBe,EAAUnB,EAAOG,GAwBrB,GAPIc,GAAWD,EAAI,IACjBD,EAASC,EAAI,EARf,SAAgBA,GACd,OAAQjB,EAAUqB,aAAiB,IAAJJ,IAAa,GACzCjB,EAAUqB,aAAaJ,IAAM,EAAI,MAAS,GAC1CjB,EAAUqB,aAAaJ,IAAM,GAAK,MAAS,EAC5CjB,EAAUqB,aAAaJ,IAAM,GAAK,KAKlCK,CAAON,IAAY,GAAKC,EACxBjB,EAAUqB,aAAaL,IAAY,EAAIC,GAIvCA,EAAIZ,EAAW,EACjBe,EAAWA,GAAWH,EAAKD,EAC3BX,GAAYY,OAGZ,IAAKE,EAAI,EAAGA,EAAIF,IAAKE,EACnBC,EAAWA,GAAW,EAAOJ,GAAUC,EAAIE,EAAI,EAAK,EAGjC,KAAbd,IACJA,EAAW,EACXJ,EAAOG,KAAWJ,EAAUqB,aAAaD,GACzCA,EAAU,EAGNhB,IAAUH,EAAOO,SACnBP,EAASE,KAAKO,iBAKtBT,EAAOG,GAASgB,EAEhBjB,KAAKF,OAASA,EACdE,KAAKE,SAAWA,EAChBF,KAAKC,MAAQA,GAQfJ,EAAUW,UAAUY,OAAS,WAC3B,IAAItB,EAASE,KAAKF,OACdG,EAAQD,KAAKC,MAoBjB,OAdID,KAAKE,SAAW,IAClBJ,EAAOG,KAAW,EAAID,KAAKE,SAC3BJ,EAAOG,GAASJ,EAAUqB,aAAapB,EAAOG,IAC9CA,KAKSH,EAAOuB,SAAS,EAAGpB,IAchCJ,EAAUqB,aAEP,WAED,IAEIF,EAFAM,EAAQ,IAAsBnB,WAAoB,KAKtD,IAAKa,EAAI,EAAGA,EAAI,MAAOA,EACrBM,EAAMN,GAAK,SAAUF,GACnB,IAAIS,EAAIT,EACJU,EAAI,EAER,IAAKV,KAAO,EAAGA,EAAGA,KAAO,EACvBS,IAAM,EACNA,GAAS,EAAJT,IACHU,EAGJ,OAAQD,GAAKC,EAAI,OAAU,EAVlB,CAWRR,GAGL,OAAOM,EAtBN,GAyBI1B,EAAKC,UAAYA","file":"../BitStream.js","sourcesContent":["define([\n  \"./zlib\"\n],function(Zlib) {\n  const USE_TYPEDARRAY = true;\n  /**\n   * @fileoverview bit 単位での書き込み実装.\n   */\n\n  /**\n   * ビットストリーム\n   * @constructor\n   * @param {!(Array|Uint8Array)=} buffer output buffer.\n   * @param {number=} bufferPosition start buffer pointer.\n   */\n  var BitStream = function(buffer, bufferPosition) {\n    /** @type {number} buffer index. */\n    this.index = typeof bufferPosition === 'number' ? bufferPosition : 0;\n    /** @type {number} bit index. */\n    this.bitindex = 0;\n    /** @type {!(Array|Uint8Array)} bit-stream output buffer. */\n    this.buffer = buffer instanceof (USE_TYPEDARRAY ? Uint8Array : Array) ?\n      buffer :\n      new (USE_TYPEDARRAY ? Uint8Array : Array)(BitStream.DefaultBlockSize);\n\n    // 入力された index が足りなかったら拡張するが、倍にしてもダメなら不正とする\n    if (this.buffer.length * 2 <= this.index) {\n      throw new Error(\"invalid index\");\n    } else if (this.buffer.length <= this.index) {\n      this.expandBuffer();\n    }\n  };\n\n  /**\n   * デフォルトブロックサイズ.\n   * @const\n   * @type {number}\n   */\n  BitStream.DefaultBlockSize = 0x8000;\n\n  /**\n   * expand buffer.\n   * @return {!(Array|Uint8Array)} new buffer.\n   */\n  BitStream.prototype.expandBuffer = function() {\n    /** @type {!(Array|Uint8Array)} old buffer. */\n    var oldbuf = this.buffer;\n    /** @type {number} loop counter. */\n    var i;\n    /** @type {number} loop limiter. */\n    var il = oldbuf.length;\n    /** @type {!(Array|Uint8Array)} new buffer. */\n    var buffer =\n      new (USE_TYPEDARRAY ? Uint8Array : Array)(il << 1);\n\n    // copy buffer\n    if (USE_TYPEDARRAY) {\n      buffer.set(oldbuf);\n    } else {\n      // XXX: loop unrolling\n      for (i = 0; i < il; ++i) {\n        buffer[i] = oldbuf[i];\n      }\n    }\n\n    return (this.buffer = buffer);\n  };\n\n\n  /**\n   * 数値をビットで指定した数だけ書き込む.\n   * @param {number} number 書き込む数値.\n   * @param {number} n 書き込むビット数.\n   * @param {boolean=} reverse 逆順に書き込むならば true.\n   */\n  BitStream.prototype.writeBits = function(number, n, reverse) {\n    var buffer = this.buffer;\n    var index = this.index;\n    var bitindex = this.bitindex;\n\n    /** @type {number} current octet. */\n    var current = buffer[index];\n    /** @type {number} loop counter. */\n    var i;\n\n    /**\n     * 32-bit 整数のビット順を逆にする\n     * @param {number} n 32-bit integer.\n     * @return {number} reversed 32-bit integer.\n     * @private\n     */\n    function rev32_(n) {\n      return (BitStream.ReverseTable[n & 0xFF] << 24) |\n        (BitStream.ReverseTable[n >>> 8 & 0xFF] << 16) |\n        (BitStream.ReverseTable[n >>> 16 & 0xFF] << 8) |\n        BitStream.ReverseTable[n >>> 24 & 0xFF];\n    }\n\n    if (reverse && n > 1) {\n      number = n > 8 ?\n        rev32_(number) >> (32 - n) :\n        BitStream.ReverseTable[number] >> (8 - n);\n    }\n\n    // Byte 境界を超えないとき\n    if (n + bitindex < 8) {\n      current = (current << n) | number;\n      bitindex += n;\n    // Byte 境界を超えるとき\n    } else {\n      for (i = 0; i < n; ++i) {\n        current = (current << 1) | ((number >> n - i - 1) & 1);\n\n        // next byte\n        if (++bitindex === 8) {\n          bitindex = 0;\n          buffer[index++] = BitStream.ReverseTable[current];\n          current = 0;\n\n          // expand\n          if (index === buffer.length) {\n            buffer = this.expandBuffer();\n          }\n        }\n      }\n    }\n    buffer[index] = current;\n\n    this.buffer = buffer;\n    this.bitindex = bitindex;\n    this.index = index;\n  };\n\n\n  /**\n   * ストリームの終端処理を行う\n   * @return {!(Array|Uint8Array)} 終端処理後のバッファを byte array で返す.\n   */\n  BitStream.prototype.finish = function() {\n    var buffer = this.buffer;\n    var index = this.index;\n\n    /** @type {!(Array|Uint8Array)} output buffer. */\n    var output;\n\n    // bitindex が 0 の時は余分に index が進んでいる状態\n    if (this.bitindex > 0) {\n      buffer[index] <<= 8 - this.bitindex;\n      buffer[index] = BitStream.ReverseTable[buffer[index]];\n      index++;\n    }\n\n    // array truncation\n    if (USE_TYPEDARRAY) {\n      output = buffer.subarray(0, index);\n    } else {\n      buffer.length = index;\n      output = buffer;\n    }\n\n    return output;\n  };\n\n  /**\n   * 0-255 のビット順を反転したテーブル\n   * @const\n   * @type {!(Uint8Array|Array.<number>)}\n   */\n  BitStream.ReverseTable = (function(table) {\n    return table;\n  })((function() {\n    /** @type {!(Array|Uint8Array)} reverse table. */\n    var table = new (USE_TYPEDARRAY ? Uint8Array : Array)(256);\n    /** @type {number} loop counter. */\n    var i;\n\n    // generate\n    for (i = 0; i < 256; ++i) {\n      table[i] = (function(n) {\n        var r = n;\n        var s = 7;\n\n        for (n >>>= 1; n; n >>>= 1) {\n          r <<= 1;\n          r |= n & 1;\n          --s;\n        }\n\n        return (r << s & 0xff) >>> 0;\n      })(i);\n    }\n\n    return table;\n  })());\n\n  return Zlib.BitStream = BitStream;\n});\n\n\n"]}