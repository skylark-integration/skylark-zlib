{"version":3,"sources":["RawDeflate.js"],"names":["define","Zlib","Heap","BitStream","table","RawDeflate","input","opt_params","this","compressionType","CompressionType","DYNAMIC","lazy","freqsLitLen","freqsDist","Array","Uint8Array","output","op","NONE","FIXED","RESERVED","Lz77MinLength","Lz77MaxLength","WindowSize","MaxCodeLength","HUFMAX","FixedHuffmanTable","i","push","prototype","compress","blockArray","position","length","subarray","makeNocompressBlock","makeFixedHuffmanBlock","makeDynamicHuffmanBlock","isFinalBlock","bfinal","btype","len","nlen","buffer","set","data","stream","writeBits","lz77","fixedHuffman","finish","hlit","hdist","hclen","litLenLengths","litLenCodes","distLengths","distCodes","treeSymbols","treeLengths","treeCodes","code","bitlen","il","hclenOrder","transLengths","getLengths_","getCodesFromLengths_","getTreeSymbols_","freqs","codes","dynamicHuffman","dataArray","litLen","dist","index","literal","apply","Lz77Match","backwardDistance","LengthCodeTable","c","Uint32Array","getDistanceCode_","r","toLz77Array","codeArray","pos","matchKey","matchList","longestMatch","prevMatch","tmp","windowSize","lz77buf","Uint16Array","skipLength","writeMatch","match","offset","lz77Array","shift","searchLongestMatch_","currentMatch","matchLength","j","l","matchMax","dl","permatch","litlenLengths","runLength","nResult","rpt","src","result","limit","nodes","values","codeLength","nSymbols","heap","pop","value","reversePackageMerge_","symbols","t","weight","next","minimumCost","flag","type","currentPosition","excess","half","takePackage","x","lengths","m","count","startCode"],"mappings":"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","file":"../RawDeflate.js","sourcesContent":["define([\r\n  \"./zlib\",\r\n  \"./Heap\",\r\n  \"./BitStream\"\r\n],function(Zlib,Heap,BitStream) {\r\n  /**\r\n   * @fileoverview Deflate (RFC1951) 符号化アルゴリズム実装.\r\n   */\r\n  const USE_TYPEDARRAY = true;\r\n\r\n  /**\r\n   * Raw Deflate 実装\r\n   *\r\n   * @constructor\r\n   * @param {!(Array.<number>|Uint8Array)} input 符号化する対象のバッファ.\r\n   * @param {Object=} opt_params option parameters.\r\n   *\r\n   * typed array が使用可能なとき、outputBuffer が Array は自動的に Uint8Array に\r\n   * 変換されます.\r\n   * 別のオブジェクトになるため出力バッファを参照している変数などは\r\n   * 更新する必要があります.\r\n   */\r\n  var RawDeflate = function(input, opt_params) {\r\n    /** @type {RawDeflate.CompressionType} */\r\n    this.compressionType = RawDeflate.CompressionType.DYNAMIC;\r\n    /** @type {number} */\r\n    this.lazy = 0;\r\n    /** @type {!(Array.<number>|Uint32Array)} */\r\n    this.freqsLitLen;\r\n    /** @type {!(Array.<number>|Uint32Array)} */\r\n    this.freqsDist;\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    this.input =\r\n      (USE_TYPEDARRAY && input instanceof Array) ? new Uint8Array(input) : input;\r\n    /** @type {!(Array.<number>|Uint8Array)} output output buffer. */\r\n    this.output;\r\n    /** @type {number} pos output buffer position. */\r\n    this.op = 0;\r\n\r\n    // option parameters\r\n    if (opt_params) {\r\n      if (opt_params['lazy']) {\r\n        this.lazy = opt_params['lazy'];\r\n      }\r\n      if (typeof opt_params['compressionType'] === 'number') {\r\n        this.compressionType = opt_params['compressionType'];\r\n      }\r\n      if (opt_params['outputBuffer']) {\r\n        this.output =\r\n          (USE_TYPEDARRAY && opt_params['outputBuffer'] instanceof Array) ?\r\n          new Uint8Array(opt_params['outputBuffer']) : opt_params['outputBuffer'];\r\n      }\r\n      if (typeof opt_params['outputIndex'] === 'number') {\r\n        this.op = opt_params['outputIndex'];\r\n      }\r\n    }\r\n\r\n    if (!this.output) {\r\n      this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(0x8000);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @enum {number}\r\n   */\r\n  RawDeflate.CompressionType = {\r\n    NONE: 0,\r\n    FIXED: 1,\r\n    DYNAMIC: 2,\r\n    RESERVED: 3\r\n  };\r\n\r\n\r\n  /**\r\n   * LZ77 の最小マッチ長\r\n   * @const\r\n   * @type {number}\r\n   */\r\n  RawDeflate.Lz77MinLength = 3;\r\n\r\n  /**\r\n   * LZ77 の最大マッチ長\r\n   * @const\r\n   * @type {number}\r\n   */\r\n  RawDeflate.Lz77MaxLength = 258;\r\n\r\n  /**\r\n   * LZ77 のウィンドウサイズ\r\n   * @const\r\n   * @type {number}\r\n   */\r\n  RawDeflate.WindowSize = 0x8000;\r\n\r\n  /**\r\n   * 最長の符号長\r\n   * @const\r\n   * @type {number}\r\n   */\r\n  RawDeflate.MaxCodeLength = 16;\r\n\r\n  /**\r\n   * ハフマン符号の最大数値\r\n   * @const\r\n   * @type {number}\r\n   */\r\n  RawDeflate.HUFMAX = 286;\r\n\r\n  /**\r\n   * 固定ハフマン符号の符号化テーブル\r\n   * @const\r\n   * @type {Array.<Array.<number, number>>}\r\n   */\r\n  RawDeflate.FixedHuffmanTable = (function() {\r\n    var table = [], i;\r\n\r\n    for (i = 0; i < 288; i++) {\r\n      switch (true) {\r\n        case (i <= 143): table.push([i       + 0x030, 8]); break;\r\n        case (i <= 255): table.push([i - 144 + 0x190, 9]); break;\r\n        case (i <= 279): table.push([i - 256 + 0x000, 7]); break;\r\n        case (i <= 287): table.push([i - 280 + 0x0C0, 8]); break;\r\n        default:\r\n          throw 'invalid literal: ' + i;\r\n      }\r\n    }\r\n\r\n    return table;\r\n  })();\r\n\r\n  /**\r\n   * DEFLATE ブロックの作成\r\n   * @return {!(Array.<number>|Uint8Array)} 圧縮済み byte array.\r\n   */\r\n  RawDeflate.prototype.compress = function() {\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var blockArray;\r\n    /** @type {number} */\r\n    var position;\r\n    /** @type {number} */\r\n    var length;\r\n\r\n    var input = this.input;\r\n\r\n    // compression\r\n    switch (this.compressionType) {\r\n      case RawDeflate.CompressionType.NONE:\r\n        // each 65535-Byte (length header: 16-bit)\r\n        for (position = 0, length = input.length; position < length;) {\r\n          blockArray = USE_TYPEDARRAY ?\r\n            input.subarray(position, position + 0xffff) :\r\n            input.slice(position, position + 0xffff);\r\n          position += blockArray.length;\r\n          this.makeNocompressBlock(blockArray, (position === length));\r\n        }\r\n        break;\r\n      case RawDeflate.CompressionType.FIXED:\r\n        this.output = this.makeFixedHuffmanBlock(input, true);\r\n        this.op = this.output.length;\r\n        break;\r\n      case RawDeflate.CompressionType.DYNAMIC:\r\n        this.output = this.makeDynamicHuffmanBlock(input, true);\r\n        this.op = this.output.length;\r\n        break;\r\n      default:\r\n        throw 'invalid compression type';\r\n    }\r\n\r\n    return this.output;\r\n  };\r\n\r\n  /**\r\n   * 非圧縮ブロックの作成\r\n   * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.\r\n   * @param {!boolean} isFinalBlock 最後のブロックならばtrue.\r\n   * @return {!(Array.<number>|Uint8Array)} 非圧縮ブロック byte array.\r\n   */\r\n  RawDeflate.prototype.makeNocompressBlock =\r\n  function(blockArray, isFinalBlock) {\r\n    /** @type {number} */\r\n    var bfinal;\r\n    /** @type {RawDeflate.CompressionType} */\r\n    var btype;\r\n    /** @type {number} */\r\n    var len;\r\n    /** @type {number} */\r\n    var nlen;\r\n    /** @type {number} */\r\n    var i;\r\n    /** @type {number} */\r\n    var il;\r\n\r\n    var output = this.output;\r\n    var op = this.op;\r\n\r\n    // expand buffer\r\n    if (USE_TYPEDARRAY) {\r\n      output = new Uint8Array(this.output.buffer);\r\n      while (output.length <= op + blockArray.length + 5) {\r\n        output = new Uint8Array(output.length << 1);\r\n      }\r\n      output.set(this.output);\r\n    }\r\n\r\n    // header\r\n    bfinal = isFinalBlock ? 1 : 0;\r\n    btype = RawDeflate.CompressionType.NONE;\r\n    output[op++] = (bfinal) | (btype << 1);\r\n\r\n    // length\r\n    len = blockArray.length;\r\n    nlen = (~len + 0x10000) & 0xffff;\r\n    output[op++] =          len & 0xff;\r\n    output[op++] =  (len >>> 8) & 0xff;\r\n    output[op++] =         nlen & 0xff;\r\n    output[op++] = (nlen >>> 8) & 0xff;\r\n\r\n    // copy buffer\r\n    if (USE_TYPEDARRAY) {\r\n       output.set(blockArray, op);\r\n       op += blockArray.length;\r\n       output = output.subarray(0, op);\r\n    } else {\r\n      for (i = 0, il = blockArray.length; i < il; ++i) {\r\n        output[op++] = blockArray[i];\r\n      }\r\n      output.length = op;\r\n    }\r\n\r\n    this.op = op;\r\n    this.output = output;\r\n\r\n    return output;\r\n  };\r\n\r\n  /**\r\n   * 固定ハフマンブロックの作成\r\n   * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.\r\n   * @param {!boolean} isFinalBlock 最後のブロックならばtrue.\r\n   * @return {!(Array.<number>|Uint8Array)} 固定ハフマン符号化ブロック byte array.\r\n   */\r\n  RawDeflate.prototype.makeFixedHuffmanBlock =\r\n  function(blockArray, isFinalBlock) {\r\n    /** @type {BitStream} */\r\n    var stream = new BitStream(USE_TYPEDARRAY ?\r\n      new Uint8Array(this.output.buffer) : this.output, this.op);\r\n    /** @type {number} */\r\n    var bfinal;\r\n    /** @type {RawDeflate.CompressionType} */\r\n    var btype;\r\n    /** @type {!(Array.<number>|Uint16Array)} */\r\n    var data;\r\n\r\n    // header\r\n    bfinal = isFinalBlock ? 1 : 0;\r\n    btype = RawDeflate.CompressionType.FIXED;\r\n\r\n    stream.writeBits(bfinal, 1, true);\r\n    stream.writeBits(btype, 2, true);\r\n\r\n    data = this.lz77(blockArray);\r\n    this.fixedHuffman(data, stream);\r\n\r\n    return stream.finish();\r\n  };\r\n\r\n  /**\r\n   * 動的ハフマンブロックの作成\r\n   * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.\r\n   * @param {!boolean} isFinalBlock 最後のブロックならばtrue.\r\n   * @return {!(Array.<number>|Uint8Array)} 動的ハフマン符号ブロック byte array.\r\n   */\r\n  RawDeflate.prototype.makeDynamicHuffmanBlock =\r\n  function(blockArray, isFinalBlock) {\r\n    /** @type {BitStream} */\r\n    var stream = new BitStream(USE_TYPEDARRAY ?\r\n      new Uint8Array(this.output.buffer) : this.output, this.op);\r\n    /** @type {number} */\r\n    var bfinal;\r\n    /** @type {RawDeflate.CompressionType} */\r\n    var btype;\r\n    /** @type {!(Array.<number>|Uint16Array)} */\r\n    var data;\r\n    /** @type {number} */\r\n    var hlit;\r\n    /** @type {number} */\r\n    var hdist;\r\n    /** @type {number} */\r\n    var hclen;\r\n    /** @const @type {Array.<number>} */\r\n    var hclenOrder =\r\n          [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var litLenLengths;\r\n    /** @type {!(Array.<number>|Uint16Array)} */\r\n    var litLenCodes;\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var distLengths;\r\n    /** @type {!(Array.<number>|Uint16Array)} */\r\n    var distCodes;\r\n    /** @type {{\r\n     *   codes: !(Array.<number>|Uint32Array),\r\n     *   freqs: !(Array.<number>|Uint8Array)\r\n     * }} */\r\n    var treeSymbols;\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var treeLengths;\r\n    /** @type {Array} */\r\n    var transLengths = new Array(19);\r\n    /** @type {!(Array.<number>|Uint16Array)} */\r\n    var treeCodes;\r\n    /** @type {number} */\r\n    var code;\r\n    /** @type {number} */\r\n    var bitlen;\r\n    /** @type {number} */\r\n    var i;\r\n    /** @type {number} */\r\n    var il;\r\n\r\n    // header\r\n    bfinal = isFinalBlock ? 1 : 0;\r\n    btype = RawDeflate.CompressionType.DYNAMIC;\r\n\r\n    stream.writeBits(bfinal, 1, true);\r\n    stream.writeBits(btype, 2, true);\r\n\r\n    data = this.lz77(blockArray);\r\n\r\n    // リテラル・長さ, 距離のハフマン符号と符号長の算出\r\n    litLenLengths = this.getLengths_(this.freqsLitLen, 15);\r\n    litLenCodes = this.getCodesFromLengths_(litLenLengths);\r\n    distLengths = this.getLengths_(this.freqsDist, 7);\r\n    distCodes = this.getCodesFromLengths_(distLengths);\r\n\r\n    // HLIT, HDIST の決定\r\n    for (hlit = 286; hlit > 257 && litLenLengths[hlit - 1] === 0; hlit--) {}\r\n    for (hdist = 30; hdist > 1 && distLengths[hdist - 1] === 0; hdist--) {}\r\n\r\n    // HCLEN\r\n    treeSymbols =\r\n      this.getTreeSymbols_(hlit, litLenLengths, hdist, distLengths);\r\n    treeLengths = this.getLengths_(treeSymbols.freqs, 7);\r\n    for (i = 0; i < 19; i++) {\r\n      transLengths[i] = treeLengths[hclenOrder[i]];\r\n    }\r\n    for (hclen = 19; hclen > 4 && transLengths[hclen - 1] === 0; hclen--) {}\r\n\r\n    treeCodes = this.getCodesFromLengths_(treeLengths);\r\n\r\n    // 出力\r\n    stream.writeBits(hlit - 257, 5, true);\r\n    stream.writeBits(hdist - 1, 5, true);\r\n    stream.writeBits(hclen - 4, 4, true);\r\n    for (i = 0; i < hclen; i++) {\r\n      stream.writeBits(transLengths[i], 3, true);\r\n    }\r\n\r\n    // ツリーの出力\r\n    for (i = 0, il = treeSymbols.codes.length; i < il; i++) {\r\n      code = treeSymbols.codes[i];\r\n\r\n      stream.writeBits(treeCodes[code], treeLengths[code], true);\r\n\r\n      // extra bits\r\n      if (code >= 16) {\r\n        i++;\r\n        switch (code) {\r\n          case 16: bitlen = 2; break;\r\n          case 17: bitlen = 3; break;\r\n          case 18: bitlen = 7; break;\r\n          default:\r\n            throw 'invalid code: ' + code;\r\n        }\r\n\r\n        stream.writeBits(treeSymbols.codes[i], bitlen, true);\r\n      }\r\n    }\r\n\r\n    this.dynamicHuffman(\r\n      data,\r\n      [litLenCodes, litLenLengths],\r\n      [distCodes, distLengths],\r\n      stream\r\n    );\r\n\r\n    return stream.finish();\r\n  };\r\n\r\n\r\n  /**\r\n   * 動的ハフマン符号化(カスタムハフマンテーブル)\r\n   * @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.\r\n   * @param {!BitStream} stream 書き込み用ビットストリーム.\r\n   * @return {!BitStream} ハフマン符号化済みビットストリームオブジェクト.\r\n   */\r\n  RawDeflate.prototype.dynamicHuffman =\r\n  function(dataArray, litLen, dist, stream) {\r\n    /** @type {number} */\r\n    var index;\r\n    /** @type {number} */\r\n    var length;\r\n    /** @type {number} */\r\n    var literal;\r\n    /** @type {number} */\r\n    var code;\r\n    /** @type {number} */\r\n    var litLenCodes;\r\n    /** @type {number} */\r\n    var litLenLengths;\r\n    /** @type {number} */\r\n    var distCodes;\r\n    /** @type {number} */\r\n    var distLengths;\r\n\r\n    litLenCodes = litLen[0];\r\n    litLenLengths = litLen[1];\r\n    distCodes = dist[0];\r\n    distLengths = dist[1];\r\n\r\n    // 符号を BitStream に書き込んでいく\r\n    for (index = 0, length = dataArray.length; index < length; ++index) {\r\n      literal = dataArray[index];\r\n\r\n      // literal or length\r\n      stream.writeBits(litLenCodes[literal], litLenLengths[literal], true);\r\n\r\n      // 長さ・距離符号\r\n      if (literal > 256) {\r\n        // length extra\r\n        stream.writeBits(dataArray[++index], dataArray[++index], true);\r\n        // distance\r\n        code = dataArray[++index];\r\n        stream.writeBits(distCodes[code], distLengths[code], true);\r\n        // distance extra\r\n        stream.writeBits(dataArray[++index], dataArray[++index], true);\r\n      // 終端\r\n      } else if (literal === 256) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return stream;\r\n  };\r\n\r\n  /**\r\n   * 固定ハフマン符号化\r\n   * @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.\r\n   * @param {!BitStream} stream 書き込み用ビットストリーム.\r\n   * @return {!BitStream} ハフマン符号化済みビットストリームオブジェクト.\r\n   */\r\n  RawDeflate.prototype.fixedHuffman = function(dataArray, stream) {\r\n    /** @type {number} */\r\n    var index;\r\n    /** @type {number} */\r\n    var length;\r\n    /** @type {number} */\r\n    var literal;\r\n\r\n    // 符号を BitStream に書き込んでいく\r\n    for (index = 0, length = dataArray.length; index < length; index++) {\r\n      literal = dataArray[index];\r\n\r\n      // 符号の書き込み\r\n      BitStream.prototype.writeBits.apply(\r\n        stream,\r\n        RawDeflate.FixedHuffmanTable[literal]\r\n      );\r\n\r\n      // 長さ・距離符号\r\n      if (literal > 0x100) {\r\n        // length extra\r\n        stream.writeBits(dataArray[++index], dataArray[++index], true);\r\n        // distance\r\n        stream.writeBits(dataArray[++index], 5);\r\n        // distance extra\r\n        stream.writeBits(dataArray[++index], dataArray[++index], true);\r\n      // 終端\r\n      } else if (literal === 0x100) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return stream;\r\n  };\r\n\r\n  /**\r\n   * マッチ情報\r\n   * @param {!number} length マッチした長さ.\r\n   * @param {!number} backwardDistance マッチ位置との距離.\r\n   * @constructor\r\n   */\r\n  RawDeflate.Lz77Match = function(length, backwardDistance) {\r\n    /** @type {number} match length. */\r\n    this.length = length;\r\n    /** @type {number} backward distance. */\r\n    this.backwardDistance = backwardDistance;\r\n  };\r\n\r\n  /**\r\n   * 長さ符号テーブル.\r\n   * [コード, 拡張ビット, 拡張ビット長] の配列となっている.\r\n   * @const\r\n   * @type {!(Array.<number>|Uint32Array)}\r\n   */\r\n  RawDeflate.Lz77Match.LengthCodeTable = (function(table) {\r\n    return USE_TYPEDARRAY ? new Uint32Array(table) : table;\r\n  })((function() {\r\n    /** @type {!Array} */\r\n    var table = [];\r\n    /** @type {number} */\r\n    var i;\r\n    /** @type {!Array.<number>} */\r\n    var c;\r\n\r\n    for (i = 3; i <= 258; i++) {\r\n      c = code(i);\r\n      table[i] = (c[2] << 24) | (c[1] << 16) | c[0];\r\n    }\r\n\r\n    /**\r\n     * @param {number} length lz77 length.\r\n     * @return {!Array.<number>} lz77 codes.\r\n     */\r\n    function code(length) {\r\n      switch (true) {\r\n        case (length === 3): return [257, length - 3, 0]; break;\r\n        case (length === 4): return [258, length - 4, 0]; break;\r\n        case (length === 5): return [259, length - 5, 0]; break;\r\n        case (length === 6): return [260, length - 6, 0]; break;\r\n        case (length === 7): return [261, length - 7, 0]; break;\r\n        case (length === 8): return [262, length - 8, 0]; break;\r\n        case (length === 9): return [263, length - 9, 0]; break;\r\n        case (length === 10): return [264, length - 10, 0]; break;\r\n        case (length <= 12): return [265, length - 11, 1]; break;\r\n        case (length <= 14): return [266, length - 13, 1]; break;\r\n        case (length <= 16): return [267, length - 15, 1]; break;\r\n        case (length <= 18): return [268, length - 17, 1]; break;\r\n        case (length <= 22): return [269, length - 19, 2]; break;\r\n        case (length <= 26): return [270, length - 23, 2]; break;\r\n        case (length <= 30): return [271, length - 27, 2]; break;\r\n        case (length <= 34): return [272, length - 31, 2]; break;\r\n        case (length <= 42): return [273, length - 35, 3]; break;\r\n        case (length <= 50): return [274, length - 43, 3]; break;\r\n        case (length <= 58): return [275, length - 51, 3]; break;\r\n        case (length <= 66): return [276, length - 59, 3]; break;\r\n        case (length <= 82): return [277, length - 67, 4]; break;\r\n        case (length <= 98): return [278, length - 83, 4]; break;\r\n        case (length <= 114): return [279, length - 99, 4]; break;\r\n        case (length <= 130): return [280, length - 115, 4]; break;\r\n        case (length <= 162): return [281, length - 131, 5]; break;\r\n        case (length <= 194): return [282, length - 163, 5]; break;\r\n        case (length <= 226): return [283, length - 195, 5]; break;\r\n        case (length <= 257): return [284, length - 227, 5]; break;\r\n        case (length === 258): return [285, length - 258, 0]; break;\r\n        default: throw 'invalid length: ' + length;\r\n      }\r\n    }\r\n\r\n    return table;\r\n  })());\r\n\r\n  /**\r\n   * 距離符号テーブル\r\n   * @param {!number} dist 距離.\r\n   * @return {!Array.<number>} コード、拡張ビット、拡張ビット長の配列.\r\n   * @private\r\n   */\r\n  RawDeflate.Lz77Match.prototype.getDistanceCode_ = function(dist) {\r\n    /** @type {!Array.<number>} distance code table. */\r\n    var r;\r\n\r\n    switch (true) {\r\n      case (dist === 1): r = [0, dist - 1, 0]; break;\r\n      case (dist === 2): r = [1, dist - 2, 0]; break;\r\n      case (dist === 3): r = [2, dist - 3, 0]; break;\r\n      case (dist === 4): r = [3, dist - 4, 0]; break;\r\n      case (dist <= 6): r = [4, dist - 5, 1]; break;\r\n      case (dist <= 8): r = [5, dist - 7, 1]; break;\r\n      case (dist <= 12): r = [6, dist - 9, 2]; break;\r\n      case (dist <= 16): r = [7, dist - 13, 2]; break;\r\n      case (dist <= 24): r = [8, dist - 17, 3]; break;\r\n      case (dist <= 32): r = [9, dist - 25, 3]; break;\r\n      case (dist <= 48): r = [10, dist - 33, 4]; break;\r\n      case (dist <= 64): r = [11, dist - 49, 4]; break;\r\n      case (dist <= 96): r = [12, dist - 65, 5]; break;\r\n      case (dist <= 128): r = [13, dist - 97, 5]; break;\r\n      case (dist <= 192): r = [14, dist - 129, 6]; break;\r\n      case (dist <= 256): r = [15, dist - 193, 6]; break;\r\n      case (dist <= 384): r = [16, dist - 257, 7]; break;\r\n      case (dist <= 512): r = [17, dist - 385, 7]; break;\r\n      case (dist <= 768): r = [18, dist - 513, 8]; break;\r\n      case (dist <= 1024): r = [19, dist - 769, 8]; break;\r\n      case (dist <= 1536): r = [20, dist - 1025, 9]; break;\r\n      case (dist <= 2048): r = [21, dist - 1537, 9]; break;\r\n      case (dist <= 3072): r = [22, dist - 2049, 10]; break;\r\n      case (dist <= 4096): r = [23, dist - 3073, 10]; break;\r\n      case (dist <= 6144): r = [24, dist - 4097, 11]; break;\r\n      case (dist <= 8192): r = [25, dist - 6145, 11]; break;\r\n      case (dist <= 12288): r = [26, dist - 8193, 12]; break;\r\n      case (dist <= 16384): r = [27, dist - 12289, 12]; break;\r\n      case (dist <= 24576): r = [28, dist - 16385, 13]; break;\r\n      case (dist <= 32768): r = [29, dist - 24577, 13]; break;\r\n      default: throw 'invalid distance';\r\n    }\r\n\r\n    return r;\r\n  };\r\n\r\n  /**\r\n   * マッチ情報を LZ77 符号化配列で返す.\r\n   * なお、ここでは以下の内部仕様で符号化している\r\n   * [ CODE, EXTRA-BIT-LEN, EXTRA, CODE, EXTRA-BIT-LEN, EXTRA ]\r\n   * @return {!Array.<number>} LZ77 符号化 byte array.\r\n   */\r\n  RawDeflate.Lz77Match.prototype.toLz77Array = function() {\r\n    /** @type {number} */\r\n    var length = this.length;\r\n    /** @type {number} */\r\n    var dist = this.backwardDistance;\r\n    /** @type {Array} */\r\n    var codeArray = [];\r\n    /** @type {number} */\r\n    var pos = 0;\r\n    /** @type {!Array.<number>} */\r\n    var code;\r\n\r\n    // length\r\n    code = RawDeflate.Lz77Match.LengthCodeTable[length];\r\n    codeArray[pos++] = code & 0xffff;\r\n    codeArray[pos++] = (code >> 16) & 0xff;\r\n    codeArray[pos++] = code >> 24;\r\n\r\n    // distance\r\n    code = this.getDistanceCode_(dist);\r\n    codeArray[pos++] = code[0];\r\n    codeArray[pos++] = code[1];\r\n    codeArray[pos++] = code[2];\r\n\r\n    return codeArray;\r\n  };\r\n\r\n  /**\r\n   * LZ77 実装\r\n   * @param {!(Array.<number>|Uint8Array)} dataArray LZ77 符号化するバイト配列.\r\n   * @return {!(Array.<number>|Uint16Array)} LZ77 符号化した配列.\r\n   */\r\n  RawDeflate.prototype.lz77 = function(dataArray) {\r\n    /** @type {number} input position */\r\n    var position;\r\n    /** @type {number} input length */\r\n    var length;\r\n    /** @type {number} loop counter */\r\n    var i;\r\n    /** @type {number} loop limiter */\r\n    var il;\r\n    /** @type {number} chained-hash-table key */\r\n    var matchKey;\r\n    /** @type {Object.<number, Array.<number>>} chained-hash-table */\r\n    var table = {};\r\n    /** @const @type {number} */\r\n    var windowSize = RawDeflate.WindowSize;\r\n    /** @type {Array.<number>} match list */\r\n    var matchList;\r\n    /** @type {RawDeflate.Lz77Match} longest match */\r\n    var longestMatch;\r\n    /** @type {RawDeflate.Lz77Match} previous longest match */\r\n    var prevMatch;\r\n    /** @type {!(Array.<number>|Uint16Array)} lz77 buffer */\r\n    var lz77buf = USE_TYPEDARRAY ?\r\n      new Uint16Array(dataArray.length * 2) : [];\r\n    /** @type {number} lz77 output buffer pointer */\r\n    var pos = 0;\r\n    /** @type {number} lz77 skip length */\r\n    var skipLength = 0;\r\n    /** @type {!(Array.<number>|Uint32Array)} */\r\n    var freqsLitLen = new (USE_TYPEDARRAY ? Uint32Array : Array)(286);\r\n    /** @type {!(Array.<number>|Uint32Array)} */\r\n    var freqsDist = new (USE_TYPEDARRAY ? Uint32Array : Array)(30);\r\n    /** @type {number} */\r\n    var lazy = this.lazy;\r\n    /** @type {*} temporary variable */\r\n    var tmp;\r\n\r\n    // 初期化\r\n    if (!USE_TYPEDARRAY) {\r\n      for (i = 0; i <= 285;) { freqsLitLen[i++] = 0; }\r\n      for (i = 0; i <= 29;) { freqsDist[i++] = 0; }\r\n    }\r\n    freqsLitLen[256] = 1; // EOB の最低出現回数は 1\r\n\r\n    /**\r\n     * マッチデータの書き込み\r\n     * @param {RawDeflate.Lz77Match} match LZ77 Match data.\r\n     * @param {!number} offset スキップ開始位置(相対指定).\r\n     * @private\r\n     */\r\n    function writeMatch(match, offset) {\r\n      /** @type {Array.<number>} */\r\n      var lz77Array = match.toLz77Array();\r\n      /** @type {number} */\r\n      var i;\r\n      /** @type {number} */\r\n      var il;\r\n\r\n      for (i = 0, il = lz77Array.length; i < il; ++i) {\r\n        lz77buf[pos++] = lz77Array[i];\r\n      }\r\n      freqsLitLen[lz77Array[0]]++;\r\n      freqsDist[lz77Array[3]]++;\r\n      skipLength = match.length + offset - 1;\r\n      prevMatch = null;\r\n    }\r\n\r\n    // LZ77 符号化\r\n    for (position = 0, length = dataArray.length; position < length; ++position) {\r\n      // ハッシュキーの作成\r\n      for (matchKey = 0, i = 0, il = RawDeflate.Lz77MinLength; i < il; ++i) {\r\n        if (position + i === length) {\r\n          break;\r\n        }\r\n        matchKey = (matchKey << 8) | dataArray[position + i];\r\n      }\r\n\r\n      // テーブルが未定義だったら作成する\r\n      if (table[matchKey] === void 0) { table[matchKey] = []; }\r\n      matchList = table[matchKey];\r\n\r\n      // skip\r\n      if (skipLength-- > 0) {\r\n        matchList.push(position);\r\n        continue;\r\n      }\r\n\r\n      // マッチテーブルの更新 (最大戻り距離を超えているものを削除する)\r\n      while (matchList.length > 0 && position - matchList[0] > windowSize) {\r\n        matchList.shift();\r\n      }\r\n\r\n      // データ末尾でマッチしようがない場合はそのまま流しこむ\r\n      if (position + RawDeflate.Lz77MinLength >= length) {\r\n        if (prevMatch) {\r\n          writeMatch(prevMatch, -1);\r\n        }\r\n\r\n        for (i = 0, il = length - position; i < il; ++i) {\r\n          tmp = dataArray[position + i];\r\n          lz77buf[pos++] = tmp;\r\n          ++freqsLitLen[tmp];\r\n        }\r\n        break;\r\n      }\r\n\r\n      // マッチ候補から最長のものを探す\r\n      if (matchList.length > 0) {\r\n        longestMatch = this.searchLongestMatch_(dataArray, position, matchList);\r\n\r\n        if (prevMatch) {\r\n          // 現在のマッチの方が前回のマッチよりも長い\r\n          if (prevMatch.length < longestMatch.length) {\r\n            // write previous literal\r\n            tmp = dataArray[position - 1];\r\n            lz77buf[pos++] = tmp;\r\n            ++freqsLitLen[tmp];\r\n\r\n            // write current match\r\n            writeMatch(longestMatch, 0);\r\n          } else {\r\n            // write previous match\r\n            writeMatch(prevMatch, -1);\r\n          }\r\n        } else if (longestMatch.length < lazy) {\r\n          prevMatch = longestMatch;\r\n        } else {\r\n          writeMatch(longestMatch, 0);\r\n        }\r\n      // 前回マッチしていて今回マッチがなかったら前回のを採用\r\n      } else if (prevMatch) {\r\n        writeMatch(prevMatch, -1);\r\n      } else {\r\n        tmp = dataArray[position];\r\n        lz77buf[pos++] = tmp;\r\n        ++freqsLitLen[tmp];\r\n      }\r\n\r\n      matchList.push(position); // マッチテーブルに現在の位置を保存\r\n    }\r\n\r\n    // 終端処理\r\n    lz77buf[pos++] = 256;\r\n    freqsLitLen[256]++;\r\n    this.freqsLitLen = freqsLitLen;\r\n    this.freqsDist = freqsDist;\r\n\r\n    return /** @type {!(Uint16Array|Array.<number>)} */ (\r\n      USE_TYPEDARRAY ?  lz77buf.subarray(0, pos) : lz77buf\r\n    );\r\n  };\r\n\r\n  /**\r\n   * マッチした候補の中から最長一致を探す\r\n   * @param {!Object} data plain data byte array.\r\n   * @param {!number} position plain data byte array position.\r\n   * @param {!Array.<number>} matchList 候補となる位置の配列.\r\n   * @return {!RawDeflate.Lz77Match} 最長かつ最短距離のマッチオブジェクト.\r\n   * @private\r\n   */\r\n  RawDeflate.prototype.searchLongestMatch_ =\r\n  function(data, position, matchList) {\r\n    var match,\r\n        currentMatch,\r\n        matchMax = 0, matchLength,\r\n        i, j, l, dl = data.length;\r\n\r\n    // 候補を後ろから 1 つずつ絞り込んでゆく\r\n    permatch:\r\n    for (i = 0, l = matchList.length; i < l; i++) {\r\n      match = matchList[l - i - 1];\r\n      matchLength = RawDeflate.Lz77MinLength;\r\n\r\n      // 前回までの最長一致を末尾から一致検索する\r\n      if (matchMax > RawDeflate.Lz77MinLength) {\r\n        for (j = matchMax; j > RawDeflate.Lz77MinLength; j--) {\r\n          if (data[match + j - 1] !== data[position + j - 1]) {\r\n            continue permatch;\r\n          }\r\n        }\r\n        matchLength = matchMax;\r\n      }\r\n\r\n      // 最長一致探索\r\n      while (matchLength < RawDeflate.Lz77MaxLength &&\r\n             position + matchLength < dl &&\r\n             data[match + matchLength] === data[position + matchLength]) {\r\n        ++matchLength;\r\n      }\r\n\r\n      // マッチ長が同じ場合は後方を優先\r\n      if (matchLength > matchMax) {\r\n        currentMatch = match;\r\n        matchMax = matchLength;\r\n      }\r\n\r\n      // 最長が確定したら後の処理は省略\r\n      if (matchLength === RawDeflate.Lz77MaxLength) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return new RawDeflate.Lz77Match(matchMax, position - currentMatch);\r\n  };\r\n\r\n  /**\r\n   * Tree-Transmit Symbols の算出\r\n   * reference: PuTTY Deflate implementation\r\n   * @param {number} hlit HLIT.\r\n   * @param {!(Array.<number>|Uint8Array)} litlenLengths リテラルと長さ符号の符号長配列.\r\n   * @param {number} hdist HDIST.\r\n   * @param {!(Array.<number>|Uint8Array)} distLengths 距離符号の符号長配列.\r\n   * @return {{\r\n   *   codes: !(Array.<number>|Uint32Array),\r\n   *   freqs: !(Array.<number>|Uint8Array)\r\n   * }} Tree-Transmit Symbols.\r\n   */\r\n  RawDeflate.prototype.getTreeSymbols_ =\r\n  function(hlit, litlenLengths, hdist, distLengths) {\r\n    var src = new (USE_TYPEDARRAY ? Uint32Array : Array)(hlit + hdist),\r\n        i, j, runLength, l,\r\n        result = new (USE_TYPEDARRAY ? Uint32Array : Array)(286 + 30),\r\n        nResult,\r\n        rpt,\r\n        freqs = new (USE_TYPEDARRAY ? Uint8Array : Array)(19);\r\n\r\n    j = 0;\r\n    for (i = 0; i < hlit; i++) {\r\n      src[j++] = litlenLengths[i];\r\n    }\r\n    for (i = 0; i < hdist; i++) {\r\n      src[j++] = distLengths[i];\r\n    }\r\n\r\n    // 初期化\r\n    if (!USE_TYPEDARRAY) {\r\n      for (i = 0, l = freqs.length; i < l; ++i) {\r\n        freqs[i] = 0;\r\n      }\r\n    }\r\n\r\n    // 符号化\r\n    nResult = 0;\r\n    for (i = 0, l = src.length; i < l; i += j) {\r\n      // Run Length Encoding\r\n      for (j = 1; i + j < l && src[i + j] === src[i]; ++j) {}\r\n\r\n      runLength = j;\r\n\r\n      if (src[i] === 0) {\r\n        // 0 の繰り返しが 3 回未満ならばそのまま\r\n        if (runLength < 3) {\r\n          while (runLength-- > 0) {\r\n            result[nResult++] = 0;\r\n            freqs[0]++;\r\n          }\r\n        } else {\r\n          while (runLength > 0) {\r\n            // 繰り返しは最大 138 までなので切り詰める\r\n            rpt = (runLength < 138 ? runLength : 138);\r\n\r\n            if (rpt > runLength - 3 && rpt < runLength) {\r\n              rpt = runLength - 3;\r\n            }\r\n\r\n            // 3-10 回 -> 17\r\n            if (rpt <= 10) {\r\n              result[nResult++] = 17;\r\n              result[nResult++] = rpt - 3;\r\n              freqs[17]++;\r\n            // 11-138 回 -> 18\r\n            } else {\r\n              result[nResult++] = 18;\r\n              result[nResult++] = rpt - 11;\r\n              freqs[18]++;\r\n            }\r\n\r\n            runLength -= rpt;\r\n          }\r\n        }\r\n      } else {\r\n        result[nResult++] = src[i];\r\n        freqs[src[i]]++;\r\n        runLength--;\r\n\r\n        // 繰り返し回数が3回未満ならばランレングス符号は要らない\r\n        if (runLength < 3) {\r\n          while (runLength-- > 0) {\r\n            result[nResult++] = src[i];\r\n            freqs[src[i]]++;\r\n          }\r\n        // 3 回以上ならばランレングス符号化\r\n        } else {\r\n          while (runLength > 0) {\r\n            // runLengthを 3-6 で分割\r\n            rpt = (runLength < 6 ? runLength : 6);\r\n\r\n            if (rpt > runLength - 3 && rpt < runLength) {\r\n              rpt = runLength - 3;\r\n            }\r\n\r\n            result[nResult++] = 16;\r\n            result[nResult++] = rpt - 3;\r\n            freqs[16]++;\r\n\r\n            runLength -= rpt;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      codes:\r\n        USE_TYPEDARRAY ? result.subarray(0, nResult) : result.slice(0, nResult),\r\n      freqs: freqs\r\n    };\r\n  };\r\n\r\n  /**\r\n   * ハフマン符号の長さを取得する\r\n   * @param {!(Array.<number>|Uint8Array|Uint32Array)} freqs 出現カウント.\r\n   * @param {number} limit 符号長の制限.\r\n   * @return {!(Array.<number>|Uint8Array)} 符号長配列.\r\n   * @private\r\n   */\r\n  RawDeflate.prototype.getLengths_ = function(freqs, limit) {\r\n    /** @type {number} */\r\n    var nSymbols = freqs.length;\r\n    /** @type {Heap} */\r\n    var heap = new Heap(2 * RawDeflate.HUFMAX);\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var length = new (USE_TYPEDARRAY ? Uint8Array : Array)(nSymbols);\r\n    /** @type {Array} */\r\n    var nodes;\r\n    /** @type {!(Array.<number>|Uint32Array)} */\r\n    var values;\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var codeLength;\r\n    /** @type {number} */\r\n    var i;\r\n    /** @type {number} */\r\n    var il;\r\n\r\n    // 配列の初期化\r\n    if (!USE_TYPEDARRAY) {\r\n      for (i = 0; i < nSymbols; i++) {\r\n        length[i] = 0;\r\n      }\r\n    }\r\n\r\n    // ヒープの構築\r\n    for (i = 0; i < nSymbols; ++i) {\r\n      if (freqs[i] > 0) {\r\n        heap.push(i, freqs[i]);\r\n      }\r\n    }\r\n    nodes = new Array(heap.length / 2);\r\n    values = new (USE_TYPEDARRAY ? Uint32Array : Array)(heap.length / 2);\r\n\r\n    // 非 0 の要素が一つだけだった場合は、そのシンボルに符号長 1 を割り当てて終了\r\n    if (nodes.length === 1) {\r\n      length[heap.pop().index] = 1;\r\n      return length;\r\n    }\r\n\r\n    // Reverse Package Merge Algorithm による Canonical Huffman Code の符号長決定\r\n    for (i = 0, il = heap.length / 2; i < il; ++i) {\r\n      nodes[i] = heap.pop();\r\n      values[i] = nodes[i].value;\r\n    }\r\n    codeLength = this.reversePackageMerge_(values, values.length, limit);\r\n\r\n    for (i = 0, il = nodes.length; i < il; ++i) {\r\n      length[nodes[i].index] = codeLength[i];\r\n    }\r\n\r\n    return length;\r\n  };\r\n\r\n  /**\r\n   * Reverse Package Merge Algorithm.\r\n   * @param {!(Array.<number>|Uint32Array)} freqs sorted probability.\r\n   * @param {number} symbols number of symbols.\r\n   * @param {number} limit code length limit.\r\n   * @return {!(Array.<number>|Uint8Array)} code lengths.\r\n   */\r\n  RawDeflate.prototype.reversePackageMerge_ = function(freqs, symbols, limit) {\r\n    /** @type {!(Array.<number>|Uint16Array)} */\r\n    var minimumCost = new (USE_TYPEDARRAY ? Uint16Array : Array)(limit);\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var flag = new (USE_TYPEDARRAY ? Uint8Array : Array)(limit);\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var codeLength = new (USE_TYPEDARRAY ? Uint8Array : Array)(symbols);\r\n    /** @type {Array} */\r\n    var value = new Array(limit);\r\n    /** @type {Array} */\r\n    var type  = new Array(limit);\r\n    /** @type {Array.<number>} */\r\n    var currentPosition = new Array(limit);\r\n    /** @type {number} */\r\n    var excess = (1 << limit) - symbols;\r\n    /** @type {number} */\r\n    var half = (1 << (limit - 1));\r\n    /** @type {number} */\r\n    var i;\r\n    /** @type {number} */\r\n    var j;\r\n    /** @type {number} */\r\n    var t;\r\n    /** @type {number} */\r\n    var weight;\r\n    /** @type {number} */\r\n    var next;\r\n\r\n    /**\r\n     * @param {number} j\r\n     */\r\n    function takePackage(j) {\r\n      /** @type {number} */\r\n      var x = type[j][currentPosition[j]];\r\n\r\n      if (x === symbols) {\r\n        takePackage(j+1);\r\n        takePackage(j+1);\r\n      } else {\r\n        --codeLength[x];\r\n      }\r\n\r\n      ++currentPosition[j];\r\n    }\r\n\r\n    minimumCost[limit-1] = symbols;\r\n\r\n    for (j = 0; j < limit; ++j) {\r\n      if (excess < half) {\r\n        flag[j] = 0;\r\n      } else {\r\n        flag[j] = 1;\r\n        excess -= half;\r\n      }\r\n      excess <<= 1;\r\n      minimumCost[limit-2-j] = (minimumCost[limit-1-j] / 2 | 0) + symbols;\r\n    }\r\n    minimumCost[0] = flag[0];\r\n\r\n    value[0] = new Array(minimumCost[0]);\r\n    type[0]  = new Array(minimumCost[0]);\r\n    for (j = 1; j < limit; ++j) {\r\n      if (minimumCost[j] > 2 * minimumCost[j-1] + flag[j]) {\r\n        minimumCost[j] = 2 * minimumCost[j-1] + flag[j];\r\n      }\r\n      value[j] = new Array(minimumCost[j]);\r\n      type[j]  = new Array(minimumCost[j]);\r\n    }\r\n\r\n    for (i = 0; i < symbols; ++i) {\r\n      codeLength[i] = limit;\r\n    }\r\n\r\n    for (t = 0; t < minimumCost[limit-1]; ++t) {\r\n      value[limit-1][t] = freqs[t];\r\n      type[limit-1][t]  = t;\r\n    }\r\n\r\n    for (i = 0; i < limit; ++i) {\r\n      currentPosition[i] = 0;\r\n    }\r\n    if (flag[limit-1] === 1) {\r\n      --codeLength[0];\r\n      ++currentPosition[limit-1];\r\n    }\r\n\r\n    for (j = limit-2; j >= 0; --j) {\r\n      i = 0;\r\n      weight = 0;\r\n      next = currentPosition[j+1];\r\n\r\n      for (t = 0; t < minimumCost[j]; t++) {\r\n        weight = value[j+1][next] + value[j+1][next+1];\r\n\r\n        if (weight > freqs[i]) {\r\n          value[j][t] = weight;\r\n          type[j][t] = symbols;\r\n          next += 2;\r\n        } else {\r\n          value[j][t] = freqs[i];\r\n          type[j][t] = i;\r\n          ++i;\r\n        }\r\n      }\r\n\r\n      currentPosition[j] = 0;\r\n      if (flag[j] === 1) {\r\n        takePackage(j);\r\n      }\r\n    }\r\n\r\n    return codeLength;\r\n  };\r\n\r\n  /**\r\n   * 符号長配列からハフマン符号を取得する\r\n   * reference: PuTTY Deflate implementation\r\n   * @param {!(Array.<number>|Uint8Array)} lengths 符号長配列.\r\n   * @return {!(Array.<number>|Uint16Array)} ハフマン符号配列.\r\n   * @private\r\n   */\r\n  RawDeflate.prototype.getCodesFromLengths_ = function(lengths) {\r\n    var codes = new (USE_TYPEDARRAY ? Uint16Array : Array)(lengths.length),\r\n        count = [],\r\n        startCode = [],\r\n        code = 0, i, il, j, m;\r\n\r\n    // Count the codes of each length.\r\n    for (i = 0, il = lengths.length; i < il; i++) {\r\n      count[lengths[i]] = (count[lengths[i]] | 0) + 1;\r\n    }\r\n\r\n    // Determine the starting code for each length block.\r\n    for (i = 1, il = RawDeflate.MaxCodeLength; i <= il; i++) {\r\n      startCode[i] = code;\r\n      code += count[i] | 0;\r\n      code <<= 1;\r\n    }\r\n\r\n    // Determine the code for each symbol. Mirrored, of course.\r\n    for (i = 0, il = lengths.length; i < il; i++) {\r\n      code = startCode[lengths[i]];\r\n      startCode[lengths[i]] += 1;\r\n      codes[i] = 0;\r\n\r\n      for (j = 0, m = lengths[i]; j < m; j++) {\r\n        codes[i] = (codes[i] << 1) | (code & 1);\r\n        code >>>= 1;\r\n      }\r\n    }\r\n\r\n    return codes;\r\n  };\r\n\r\n  return Zlib.RawDeflate = RawDeflate;\r\n  \r\n});\r\n\r\n"]}