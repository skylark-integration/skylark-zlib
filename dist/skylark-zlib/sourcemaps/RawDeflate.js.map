{"version":3,"sources":["RawDeflate.js"],"names":["define","Zlib","Heap","BitStream","table","RawDeflate","input","opt_params","this","compressionType","CompressionType","DYNAMIC","lazy","freqsLitLen","freqsDist","Array","Uint8Array","output","op","NONE","FIXED","RESERVED","Lz77MinLength","Lz77MaxLength","WindowSize","MaxCodeLength","HUFMAX","FixedHuffmanTable","i","push","prototype","compress","blockArray","position","length","subarray","makeNocompressBlock","makeFixedHuffmanBlock","makeDynamicHuffmanBlock","isFinalBlock","bfinal","btype","len","nlen","buffer","set","data","stream","writeBits","lz77","fixedHuffman","finish","hlit","hdist","hclen","litLenLengths","litLenCodes","distLengths","distCodes","treeSymbols","treeLengths","treeCodes","code","bitlen","il","hclenOrder","transLengths","getLengths_","getCodesFromLengths_","getTreeSymbols_","freqs","codes","dynamicHuffman","dataArray","litLen","dist","index","literal","apply","Lz77Match","backwardDistance","LengthCodeTable","c","Uint32Array","getDistanceCode_","r","toLz77Array","codeArray","pos","matchKey","matchList","longestMatch","prevMatch","tmp","windowSize","lz77buf","Uint16Array","skipLength","writeMatch","match","offset","lz77Array","shift","searchLongestMatch_","currentMatch","matchLength","j","l","matchMax","dl","permatch","litlenLengths","runLength","nResult","rpt","src","result","limit","nodes","values","codeLength","nSymbols","heap","pop","value","reversePackageMerge_","symbols","t","weight","next","minimumCost","flag","type","currentPosition","excess","half","takePackage","x","lengths","m","count","startCode"],"mappings":"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","file":"../RawDeflate.js","sourcesContent":["define([\n  \"./zlib\",\n  \"./Heap\",\n  \"./BitStream\"\n],function(Zlib,Heap,BitStream) {\n  /**\n   * @fileoverview Deflate (RFC1951) 符号化アルゴリズム実装.\n   */\n  const USE_TYPEDARRAY = true;\n\n  /**\n   * Raw Deflate 実装\n   *\n   * @constructor\n   * @param {!(Array.<number>|Uint8Array)} input 符号化する対象のバッファ.\n   * @param {Object=} opt_params option parameters.\n   *\n   * typed array が使用可能なとき、outputBuffer が Array は自動的に Uint8Array に\n   * 変換されます.\n   * 別のオブジェクトになるため出力バッファを参照している変数などは\n   * 更新する必要があります.\n   */\n  var RawDeflate = function(input, opt_params) {\n    /** @type {RawDeflate.CompressionType} */\n    this.compressionType = RawDeflate.CompressionType.DYNAMIC;\n    /** @type {number} */\n    this.lazy = 0;\n    /** @type {!(Array.<number>|Uint32Array)} */\n    this.freqsLitLen;\n    /** @type {!(Array.<number>|Uint32Array)} */\n    this.freqsDist;\n    /** @type {!(Array.<number>|Uint8Array)} */\n    this.input =\n      (USE_TYPEDARRAY && input instanceof Array) ? new Uint8Array(input) : input;\n    /** @type {!(Array.<number>|Uint8Array)} output output buffer. */\n    this.output;\n    /** @type {number} pos output buffer position. */\n    this.op = 0;\n\n    // option parameters\n    if (opt_params) {\n      if (opt_params['lazy']) {\n        this.lazy = opt_params['lazy'];\n      }\n      if (typeof opt_params['compressionType'] === 'number') {\n        this.compressionType = opt_params['compressionType'];\n      }\n      if (opt_params['outputBuffer']) {\n        this.output =\n          (USE_TYPEDARRAY && opt_params['outputBuffer'] instanceof Array) ?\n          new Uint8Array(opt_params['outputBuffer']) : opt_params['outputBuffer'];\n      }\n      if (typeof opt_params['outputIndex'] === 'number') {\n        this.op = opt_params['outputIndex'];\n      }\n    }\n\n    if (!this.output) {\n      this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(0x8000);\n    }\n  };\n\n  /**\n   * @enum {number}\n   */\n  RawDeflate.CompressionType = {\n    NONE: 0,\n    FIXED: 1,\n    DYNAMIC: 2,\n    RESERVED: 3\n  };\n\n\n  /**\n   * LZ77 の最小マッチ長\n   * @const\n   * @type {number}\n   */\n  RawDeflate.Lz77MinLength = 3;\n\n  /**\n   * LZ77 の最大マッチ長\n   * @const\n   * @type {number}\n   */\n  RawDeflate.Lz77MaxLength = 258;\n\n  /**\n   * LZ77 のウィンドウサイズ\n   * @const\n   * @type {number}\n   */\n  RawDeflate.WindowSize = 0x8000;\n\n  /**\n   * 最長の符号長\n   * @const\n   * @type {number}\n   */\n  RawDeflate.MaxCodeLength = 16;\n\n  /**\n   * ハフマン符号の最大数値\n   * @const\n   * @type {number}\n   */\n  RawDeflate.HUFMAX = 286;\n\n  /**\n   * 固定ハフマン符号の符号化テーブル\n   * @const\n   * @type {Array.<Array.<number, number>>}\n   */\n  RawDeflate.FixedHuffmanTable = (function() {\n    var table = [], i;\n\n    for (i = 0; i < 288; i++) {\n      switch (true) {\n        case (i <= 143): table.push([i       + 0x030, 8]); break;\n        case (i <= 255): table.push([i - 144 + 0x190, 9]); break;\n        case (i <= 279): table.push([i - 256 + 0x000, 7]); break;\n        case (i <= 287): table.push([i - 280 + 0x0C0, 8]); break;\n        default:\n          throw 'invalid literal: ' + i;\n      }\n    }\n\n    return table;\n  })();\n\n  /**\n   * DEFLATE ブロックの作成\n   * @return {!(Array.<number>|Uint8Array)} 圧縮済み byte array.\n   */\n  RawDeflate.prototype.compress = function() {\n    /** @type {!(Array.<number>|Uint8Array)} */\n    var blockArray;\n    /** @type {number} */\n    var position;\n    /** @type {number} */\n    var length;\n\n    var input = this.input;\n\n    // compression\n    switch (this.compressionType) {\n      case RawDeflate.CompressionType.NONE:\n        // each 65535-Byte (length header: 16-bit)\n        for (position = 0, length = input.length; position < length;) {\n          blockArray = USE_TYPEDARRAY ?\n            input.subarray(position, position + 0xffff) :\n            input.slice(position, position + 0xffff);\n          position += blockArray.length;\n          this.makeNocompressBlock(blockArray, (position === length));\n        }\n        break;\n      case RawDeflate.CompressionType.FIXED:\n        this.output = this.makeFixedHuffmanBlock(input, true);\n        this.op = this.output.length;\n        break;\n      case RawDeflate.CompressionType.DYNAMIC:\n        this.output = this.makeDynamicHuffmanBlock(input, true);\n        this.op = this.output.length;\n        break;\n      default:\n        throw 'invalid compression type';\n    }\n\n    return this.output;\n  };\n\n  /**\n   * 非圧縮ブロックの作成\n   * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.\n   * @param {!boolean} isFinalBlock 最後のブロックならばtrue.\n   * @return {!(Array.<number>|Uint8Array)} 非圧縮ブロック byte array.\n   */\n  RawDeflate.prototype.makeNocompressBlock =\n  function(blockArray, isFinalBlock) {\n    /** @type {number} */\n    var bfinal;\n    /** @type {RawDeflate.CompressionType} */\n    var btype;\n    /** @type {number} */\n    var len;\n    /** @type {number} */\n    var nlen;\n    /** @type {number} */\n    var i;\n    /** @type {number} */\n    var il;\n\n    var output = this.output;\n    var op = this.op;\n\n    // expand buffer\n    if (USE_TYPEDARRAY) {\n      output = new Uint8Array(this.output.buffer);\n      while (output.length <= op + blockArray.length + 5) {\n        output = new Uint8Array(output.length << 1);\n      }\n      output.set(this.output);\n    }\n\n    // header\n    bfinal = isFinalBlock ? 1 : 0;\n    btype = RawDeflate.CompressionType.NONE;\n    output[op++] = (bfinal) | (btype << 1);\n\n    // length\n    len = blockArray.length;\n    nlen = (~len + 0x10000) & 0xffff;\n    output[op++] =          len & 0xff;\n    output[op++] =  (len >>> 8) & 0xff;\n    output[op++] =         nlen & 0xff;\n    output[op++] = (nlen >>> 8) & 0xff;\n\n    // copy buffer\n    if (USE_TYPEDARRAY) {\n       output.set(blockArray, op);\n       op += blockArray.length;\n       output = output.subarray(0, op);\n    } else {\n      for (i = 0, il = blockArray.length; i < il; ++i) {\n        output[op++] = blockArray[i];\n      }\n      output.length = op;\n    }\n\n    this.op = op;\n    this.output = output;\n\n    return output;\n  };\n\n  /**\n   * 固定ハフマンブロックの作成\n   * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.\n   * @param {!boolean} isFinalBlock 最後のブロックならばtrue.\n   * @return {!(Array.<number>|Uint8Array)} 固定ハフマン符号化ブロック byte array.\n   */\n  RawDeflate.prototype.makeFixedHuffmanBlock =\n  function(blockArray, isFinalBlock) {\n    /** @type {BitStream} */\n    var stream = new BitStream(USE_TYPEDARRAY ?\n      new Uint8Array(this.output.buffer) : this.output, this.op);\n    /** @type {number} */\n    var bfinal;\n    /** @type {RawDeflate.CompressionType} */\n    var btype;\n    /** @type {!(Array.<number>|Uint16Array)} */\n    var data;\n\n    // header\n    bfinal = isFinalBlock ? 1 : 0;\n    btype = RawDeflate.CompressionType.FIXED;\n\n    stream.writeBits(bfinal, 1, true);\n    stream.writeBits(btype, 2, true);\n\n    data = this.lz77(blockArray);\n    this.fixedHuffman(data, stream);\n\n    return stream.finish();\n  };\n\n  /**\n   * 動的ハフマンブロックの作成\n   * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.\n   * @param {!boolean} isFinalBlock 最後のブロックならばtrue.\n   * @return {!(Array.<number>|Uint8Array)} 動的ハフマン符号ブロック byte array.\n   */\n  RawDeflate.prototype.makeDynamicHuffmanBlock =\n  function(blockArray, isFinalBlock) {\n    /** @type {BitStream} */\n    var stream = new BitStream(USE_TYPEDARRAY ?\n      new Uint8Array(this.output.buffer) : this.output, this.op);\n    /** @type {number} */\n    var bfinal;\n    /** @type {RawDeflate.CompressionType} */\n    var btype;\n    /** @type {!(Array.<number>|Uint16Array)} */\n    var data;\n    /** @type {number} */\n    var hlit;\n    /** @type {number} */\n    var hdist;\n    /** @type {number} */\n    var hclen;\n    /** @const @type {Array.<number>} */\n    var hclenOrder =\n          [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n    /** @type {!(Array.<number>|Uint8Array)} */\n    var litLenLengths;\n    /** @type {!(Array.<number>|Uint16Array)} */\n    var litLenCodes;\n    /** @type {!(Array.<number>|Uint8Array)} */\n    var distLengths;\n    /** @type {!(Array.<number>|Uint16Array)} */\n    var distCodes;\n    /** @type {{\n     *   codes: !(Array.<number>|Uint32Array),\n     *   freqs: !(Array.<number>|Uint8Array)\n     * }} */\n    var treeSymbols;\n    /** @type {!(Array.<number>|Uint8Array)} */\n    var treeLengths;\n    /** @type {Array} */\n    var transLengths = new Array(19);\n    /** @type {!(Array.<number>|Uint16Array)} */\n    var treeCodes;\n    /** @type {number} */\n    var code;\n    /** @type {number} */\n    var bitlen;\n    /** @type {number} */\n    var i;\n    /** @type {number} */\n    var il;\n\n    // header\n    bfinal = isFinalBlock ? 1 : 0;\n    btype = RawDeflate.CompressionType.DYNAMIC;\n\n    stream.writeBits(bfinal, 1, true);\n    stream.writeBits(btype, 2, true);\n\n    data = this.lz77(blockArray);\n\n    // リテラル・長さ, 距離のハフマン符号と符号長の算出\n    litLenLengths = this.getLengths_(this.freqsLitLen, 15);\n    litLenCodes = this.getCodesFromLengths_(litLenLengths);\n    distLengths = this.getLengths_(this.freqsDist, 7);\n    distCodes = this.getCodesFromLengths_(distLengths);\n\n    // HLIT, HDIST の決定\n    for (hlit = 286; hlit > 257 && litLenLengths[hlit - 1] === 0; hlit--) {}\n    for (hdist = 30; hdist > 1 && distLengths[hdist - 1] === 0; hdist--) {}\n\n    // HCLEN\n    treeSymbols =\n      this.getTreeSymbols_(hlit, litLenLengths, hdist, distLengths);\n    treeLengths = this.getLengths_(treeSymbols.freqs, 7);\n    for (i = 0; i < 19; i++) {\n      transLengths[i] = treeLengths[hclenOrder[i]];\n    }\n    for (hclen = 19; hclen > 4 && transLengths[hclen - 1] === 0; hclen--) {}\n\n    treeCodes = this.getCodesFromLengths_(treeLengths);\n\n    // 出力\n    stream.writeBits(hlit - 257, 5, true);\n    stream.writeBits(hdist - 1, 5, true);\n    stream.writeBits(hclen - 4, 4, true);\n    for (i = 0; i < hclen; i++) {\n      stream.writeBits(transLengths[i], 3, true);\n    }\n\n    // ツリーの出力\n    for (i = 0, il = treeSymbols.codes.length; i < il; i++) {\n      code = treeSymbols.codes[i];\n\n      stream.writeBits(treeCodes[code], treeLengths[code], true);\n\n      // extra bits\n      if (code >= 16) {\n        i++;\n        switch (code) {\n          case 16: bitlen = 2; break;\n          case 17: bitlen = 3; break;\n          case 18: bitlen = 7; break;\n          default:\n            throw 'invalid code: ' + code;\n        }\n\n        stream.writeBits(treeSymbols.codes[i], bitlen, true);\n      }\n    }\n\n    this.dynamicHuffman(\n      data,\n      [litLenCodes, litLenLengths],\n      [distCodes, distLengths],\n      stream\n    );\n\n    return stream.finish();\n  };\n\n\n  /**\n   * 動的ハフマン符号化(カスタムハフマンテーブル)\n   * @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.\n   * @param {!BitStream} stream 書き込み用ビットストリーム.\n   * @return {!BitStream} ハフマン符号化済みビットストリームオブジェクト.\n   */\n  RawDeflate.prototype.dynamicHuffman =\n  function(dataArray, litLen, dist, stream) {\n    /** @type {number} */\n    var index;\n    /** @type {number} */\n    var length;\n    /** @type {number} */\n    var literal;\n    /** @type {number} */\n    var code;\n    /** @type {number} */\n    var litLenCodes;\n    /** @type {number} */\n    var litLenLengths;\n    /** @type {number} */\n    var distCodes;\n    /** @type {number} */\n    var distLengths;\n\n    litLenCodes = litLen[0];\n    litLenLengths = litLen[1];\n    distCodes = dist[0];\n    distLengths = dist[1];\n\n    // 符号を BitStream に書き込んでいく\n    for (index = 0, length = dataArray.length; index < length; ++index) {\n      literal = dataArray[index];\n\n      // literal or length\n      stream.writeBits(litLenCodes[literal], litLenLengths[literal], true);\n\n      // 長さ・距離符号\n      if (literal > 256) {\n        // length extra\n        stream.writeBits(dataArray[++index], dataArray[++index], true);\n        // distance\n        code = dataArray[++index];\n        stream.writeBits(distCodes[code], distLengths[code], true);\n        // distance extra\n        stream.writeBits(dataArray[++index], dataArray[++index], true);\n      // 終端\n      } else if (literal === 256) {\n        break;\n      }\n    }\n\n    return stream;\n  };\n\n  /**\n   * 固定ハフマン符号化\n   * @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.\n   * @param {!BitStream} stream 書き込み用ビットストリーム.\n   * @return {!BitStream} ハフマン符号化済みビットストリームオブジェクト.\n   */\n  RawDeflate.prototype.fixedHuffman = function(dataArray, stream) {\n    /** @type {number} */\n    var index;\n    /** @type {number} */\n    var length;\n    /** @type {number} */\n    var literal;\n\n    // 符号を BitStream に書き込んでいく\n    for (index = 0, length = dataArray.length; index < length; index++) {\n      literal = dataArray[index];\n\n      // 符号の書き込み\n      BitStream.prototype.writeBits.apply(\n        stream,\n        RawDeflate.FixedHuffmanTable[literal]\n      );\n\n      // 長さ・距離符号\n      if (literal > 0x100) {\n        // length extra\n        stream.writeBits(dataArray[++index], dataArray[++index], true);\n        // distance\n        stream.writeBits(dataArray[++index], 5);\n        // distance extra\n        stream.writeBits(dataArray[++index], dataArray[++index], true);\n      // 終端\n      } else if (literal === 0x100) {\n        break;\n      }\n    }\n\n    return stream;\n  };\n\n  /**\n   * マッチ情報\n   * @param {!number} length マッチした長さ.\n   * @param {!number} backwardDistance マッチ位置との距離.\n   * @constructor\n   */\n  RawDeflate.Lz77Match = function(length, backwardDistance) {\n    /** @type {number} match length. */\n    this.length = length;\n    /** @type {number} backward distance. */\n    this.backwardDistance = backwardDistance;\n  };\n\n  /**\n   * 長さ符号テーブル.\n   * [コード, 拡張ビット, 拡張ビット長] の配列となっている.\n   * @const\n   * @type {!(Array.<number>|Uint32Array)}\n   */\n  RawDeflate.Lz77Match.LengthCodeTable = (function(table) {\n    return USE_TYPEDARRAY ? new Uint32Array(table) : table;\n  })((function() {\n    /** @type {!Array} */\n    var table = [];\n    /** @type {number} */\n    var i;\n    /** @type {!Array.<number>} */\n    var c;\n\n    for (i = 3; i <= 258; i++) {\n      c = code(i);\n      table[i] = (c[2] << 24) | (c[1] << 16) | c[0];\n    }\n\n    /**\n     * @param {number} length lz77 length.\n     * @return {!Array.<number>} lz77 codes.\n     */\n    function code(length) {\n      switch (true) {\n        case (length === 3): return [257, length - 3, 0]; break;\n        case (length === 4): return [258, length - 4, 0]; break;\n        case (length === 5): return [259, length - 5, 0]; break;\n        case (length === 6): return [260, length - 6, 0]; break;\n        case (length === 7): return [261, length - 7, 0]; break;\n        case (length === 8): return [262, length - 8, 0]; break;\n        case (length === 9): return [263, length - 9, 0]; break;\n        case (length === 10): return [264, length - 10, 0]; break;\n        case (length <= 12): return [265, length - 11, 1]; break;\n        case (length <= 14): return [266, length - 13, 1]; break;\n        case (length <= 16): return [267, length - 15, 1]; break;\n        case (length <= 18): return [268, length - 17, 1]; break;\n        case (length <= 22): return [269, length - 19, 2]; break;\n        case (length <= 26): return [270, length - 23, 2]; break;\n        case (length <= 30): return [271, length - 27, 2]; break;\n        case (length <= 34): return [272, length - 31, 2]; break;\n        case (length <= 42): return [273, length - 35, 3]; break;\n        case (length <= 50): return [274, length - 43, 3]; break;\n        case (length <= 58): return [275, length - 51, 3]; break;\n        case (length <= 66): return [276, length - 59, 3]; break;\n        case (length <= 82): return [277, length - 67, 4]; break;\n        case (length <= 98): return [278, length - 83, 4]; break;\n        case (length <= 114): return [279, length - 99, 4]; break;\n        case (length <= 130): return [280, length - 115, 4]; break;\n        case (length <= 162): return [281, length - 131, 5]; break;\n        case (length <= 194): return [282, length - 163, 5]; break;\n        case (length <= 226): return [283, length - 195, 5]; break;\n        case (length <= 257): return [284, length - 227, 5]; break;\n        case (length === 258): return [285, length - 258, 0]; break;\n        default: throw 'invalid length: ' + length;\n      }\n    }\n\n    return table;\n  })());\n\n  /**\n   * 距離符号テーブル\n   * @param {!number} dist 距離.\n   * @return {!Array.<number>} コード、拡張ビット、拡張ビット長の配列.\n   * @private\n   */\n  RawDeflate.Lz77Match.prototype.getDistanceCode_ = function(dist) {\n    /** @type {!Array.<number>} distance code table. */\n    var r;\n\n    switch (true) {\n      case (dist === 1): r = [0, dist - 1, 0]; break;\n      case (dist === 2): r = [1, dist - 2, 0]; break;\n      case (dist === 3): r = [2, dist - 3, 0]; break;\n      case (dist === 4): r = [3, dist - 4, 0]; break;\n      case (dist <= 6): r = [4, dist - 5, 1]; break;\n      case (dist <= 8): r = [5, dist - 7, 1]; break;\n      case (dist <= 12): r = [6, dist - 9, 2]; break;\n      case (dist <= 16): r = [7, dist - 13, 2]; break;\n      case (dist <= 24): r = [8, dist - 17, 3]; break;\n      case (dist <= 32): r = [9, dist - 25, 3]; break;\n      case (dist <= 48): r = [10, dist - 33, 4]; break;\n      case (dist <= 64): r = [11, dist - 49, 4]; break;\n      case (dist <= 96): r = [12, dist - 65, 5]; break;\n      case (dist <= 128): r = [13, dist - 97, 5]; break;\n      case (dist <= 192): r = [14, dist - 129, 6]; break;\n      case (dist <= 256): r = [15, dist - 193, 6]; break;\n      case (dist <= 384): r = [16, dist - 257, 7]; break;\n      case (dist <= 512): r = [17, dist - 385, 7]; break;\n      case (dist <= 768): r = [18, dist - 513, 8]; break;\n      case (dist <= 1024): r = [19, dist - 769, 8]; break;\n      case (dist <= 1536): r = [20, dist - 1025, 9]; break;\n      case (dist <= 2048): r = [21, dist - 1537, 9]; break;\n      case (dist <= 3072): r = [22, dist - 2049, 10]; break;\n      case (dist <= 4096): r = [23, dist - 3073, 10]; break;\n      case (dist <= 6144): r = [24, dist - 4097, 11]; break;\n      case (dist <= 8192): r = [25, dist - 6145, 11]; break;\n      case (dist <= 12288): r = [26, dist - 8193, 12]; break;\n      case (dist <= 16384): r = [27, dist - 12289, 12]; break;\n      case (dist <= 24576): r = [28, dist - 16385, 13]; break;\n      case (dist <= 32768): r = [29, dist - 24577, 13]; break;\n      default: throw 'invalid distance';\n    }\n\n    return r;\n  };\n\n  /**\n   * マッチ情報を LZ77 符号化配列で返す.\n   * なお、ここでは以下の内部仕様で符号化している\n   * [ CODE, EXTRA-BIT-LEN, EXTRA, CODE, EXTRA-BIT-LEN, EXTRA ]\n   * @return {!Array.<number>} LZ77 符号化 byte array.\n   */\n  RawDeflate.Lz77Match.prototype.toLz77Array = function() {\n    /** @type {number} */\n    var length = this.length;\n    /** @type {number} */\n    var dist = this.backwardDistance;\n    /** @type {Array} */\n    var codeArray = [];\n    /** @type {number} */\n    var pos = 0;\n    /** @type {!Array.<number>} */\n    var code;\n\n    // length\n    code = RawDeflate.Lz77Match.LengthCodeTable[length];\n    codeArray[pos++] = code & 0xffff;\n    codeArray[pos++] = (code >> 16) & 0xff;\n    codeArray[pos++] = code >> 24;\n\n    // distance\n    code = this.getDistanceCode_(dist);\n    codeArray[pos++] = code[0];\n    codeArray[pos++] = code[1];\n    codeArray[pos++] = code[2];\n\n    return codeArray;\n  };\n\n  /**\n   * LZ77 実装\n   * @param {!(Array.<number>|Uint8Array)} dataArray LZ77 符号化するバイト配列.\n   * @return {!(Array.<number>|Uint16Array)} LZ77 符号化した配列.\n   */\n  RawDeflate.prototype.lz77 = function(dataArray) {\n    /** @type {number} input position */\n    var position;\n    /** @type {number} input length */\n    var length;\n    /** @type {number} loop counter */\n    var i;\n    /** @type {number} loop limiter */\n    var il;\n    /** @type {number} chained-hash-table key */\n    var matchKey;\n    /** @type {Object.<number, Array.<number>>} chained-hash-table */\n    var table = {};\n    /** @const @type {number} */\n    var windowSize = RawDeflate.WindowSize;\n    /** @type {Array.<number>} match list */\n    var matchList;\n    /** @type {RawDeflate.Lz77Match} longest match */\n    var longestMatch;\n    /** @type {RawDeflate.Lz77Match} previous longest match */\n    var prevMatch;\n    /** @type {!(Array.<number>|Uint16Array)} lz77 buffer */\n    var lz77buf = USE_TYPEDARRAY ?\n      new Uint16Array(dataArray.length * 2) : [];\n    /** @type {number} lz77 output buffer pointer */\n    var pos = 0;\n    /** @type {number} lz77 skip length */\n    var skipLength = 0;\n    /** @type {!(Array.<number>|Uint32Array)} */\n    var freqsLitLen = new (USE_TYPEDARRAY ? Uint32Array : Array)(286);\n    /** @type {!(Array.<number>|Uint32Array)} */\n    var freqsDist = new (USE_TYPEDARRAY ? Uint32Array : Array)(30);\n    /** @type {number} */\n    var lazy = this.lazy;\n    /** @type {*} temporary variable */\n    var tmp;\n\n    // 初期化\n    if (!USE_TYPEDARRAY) {\n      for (i = 0; i <= 285;) { freqsLitLen[i++] = 0; }\n      for (i = 0; i <= 29;) { freqsDist[i++] = 0; }\n    }\n    freqsLitLen[256] = 1; // EOB の最低出現回数は 1\n\n    /**\n     * マッチデータの書き込み\n     * @param {RawDeflate.Lz77Match} match LZ77 Match data.\n     * @param {!number} offset スキップ開始位置(相対指定).\n     * @private\n     */\n    function writeMatch(match, offset) {\n      /** @type {Array.<number>} */\n      var lz77Array = match.toLz77Array();\n      /** @type {number} */\n      var i;\n      /** @type {number} */\n      var il;\n\n      for (i = 0, il = lz77Array.length; i < il; ++i) {\n        lz77buf[pos++] = lz77Array[i];\n      }\n      freqsLitLen[lz77Array[0]]++;\n      freqsDist[lz77Array[3]]++;\n      skipLength = match.length + offset - 1;\n      prevMatch = null;\n    }\n\n    // LZ77 符号化\n    for (position = 0, length = dataArray.length; position < length; ++position) {\n      // ハッシュキーの作成\n      for (matchKey = 0, i = 0, il = RawDeflate.Lz77MinLength; i < il; ++i) {\n        if (position + i === length) {\n          break;\n        }\n        matchKey = (matchKey << 8) | dataArray[position + i];\n      }\n\n      // テーブルが未定義だったら作成する\n      if (table[matchKey] === void 0) { table[matchKey] = []; }\n      matchList = table[matchKey];\n\n      // skip\n      if (skipLength-- > 0) {\n        matchList.push(position);\n        continue;\n      }\n\n      // マッチテーブルの更新 (最大戻り距離を超えているものを削除する)\n      while (matchList.length > 0 && position - matchList[0] > windowSize) {\n        matchList.shift();\n      }\n\n      // データ末尾でマッチしようがない場合はそのまま流しこむ\n      if (position + RawDeflate.Lz77MinLength >= length) {\n        if (prevMatch) {\n          writeMatch(prevMatch, -1);\n        }\n\n        for (i = 0, il = length - position; i < il; ++i) {\n          tmp = dataArray[position + i];\n          lz77buf[pos++] = tmp;\n          ++freqsLitLen[tmp];\n        }\n        break;\n      }\n\n      // マッチ候補から最長のものを探す\n      if (matchList.length > 0) {\n        longestMatch = this.searchLongestMatch_(dataArray, position, matchList);\n\n        if (prevMatch) {\n          // 現在のマッチの方が前回のマッチよりも長い\n          if (prevMatch.length < longestMatch.length) {\n            // write previous literal\n            tmp = dataArray[position - 1];\n            lz77buf[pos++] = tmp;\n            ++freqsLitLen[tmp];\n\n            // write current match\n            writeMatch(longestMatch, 0);\n          } else {\n            // write previous match\n            writeMatch(prevMatch, -1);\n          }\n        } else if (longestMatch.length < lazy) {\n          prevMatch = longestMatch;\n        } else {\n          writeMatch(longestMatch, 0);\n        }\n      // 前回マッチしていて今回マッチがなかったら前回のを採用\n      } else if (prevMatch) {\n        writeMatch(prevMatch, -1);\n      } else {\n        tmp = dataArray[position];\n        lz77buf[pos++] = tmp;\n        ++freqsLitLen[tmp];\n      }\n\n      matchList.push(position); // マッチテーブルに現在の位置を保存\n    }\n\n    // 終端処理\n    lz77buf[pos++] = 256;\n    freqsLitLen[256]++;\n    this.freqsLitLen = freqsLitLen;\n    this.freqsDist = freqsDist;\n\n    return /** @type {!(Uint16Array|Array.<number>)} */ (\n      USE_TYPEDARRAY ?  lz77buf.subarray(0, pos) : lz77buf\n    );\n  };\n\n  /**\n   * マッチした候補の中から最長一致を探す\n   * @param {!Object} data plain data byte array.\n   * @param {!number} position plain data byte array position.\n   * @param {!Array.<number>} matchList 候補となる位置の配列.\n   * @return {!RawDeflate.Lz77Match} 最長かつ最短距離のマッチオブジェクト.\n   * @private\n   */\n  RawDeflate.prototype.searchLongestMatch_ =\n  function(data, position, matchList) {\n    var match,\n        currentMatch,\n        matchMax = 0, matchLength,\n        i, j, l, dl = data.length;\n\n    // 候補を後ろから 1 つずつ絞り込んでゆく\n    permatch:\n    for (i = 0, l = matchList.length; i < l; i++) {\n      match = matchList[l - i - 1];\n      matchLength = RawDeflate.Lz77MinLength;\n\n      // 前回までの最長一致を末尾から一致検索する\n      if (matchMax > RawDeflate.Lz77MinLength) {\n        for (j = matchMax; j > RawDeflate.Lz77MinLength; j--) {\n          if (data[match + j - 1] !== data[position + j - 1]) {\n            continue permatch;\n          }\n        }\n        matchLength = matchMax;\n      }\n\n      // 最長一致探索\n      while (matchLength < RawDeflate.Lz77MaxLength &&\n             position + matchLength < dl &&\n             data[match + matchLength] === data[position + matchLength]) {\n        ++matchLength;\n      }\n\n      // マッチ長が同じ場合は後方を優先\n      if (matchLength > matchMax) {\n        currentMatch = match;\n        matchMax = matchLength;\n      }\n\n      // 最長が確定したら後の処理は省略\n      if (matchLength === RawDeflate.Lz77MaxLength) {\n        break;\n      }\n    }\n\n    return new RawDeflate.Lz77Match(matchMax, position - currentMatch);\n  };\n\n  /**\n   * Tree-Transmit Symbols の算出\n   * reference: PuTTY Deflate implementation\n   * @param {number} hlit HLIT.\n   * @param {!(Array.<number>|Uint8Array)} litlenLengths リテラルと長さ符号の符号長配列.\n   * @param {number} hdist HDIST.\n   * @param {!(Array.<number>|Uint8Array)} distLengths 距離符号の符号長配列.\n   * @return {{\n   *   codes: !(Array.<number>|Uint32Array),\n   *   freqs: !(Array.<number>|Uint8Array)\n   * }} Tree-Transmit Symbols.\n   */\n  RawDeflate.prototype.getTreeSymbols_ =\n  function(hlit, litlenLengths, hdist, distLengths) {\n    var src = new (USE_TYPEDARRAY ? Uint32Array : Array)(hlit + hdist),\n        i, j, runLength, l,\n        result = new (USE_TYPEDARRAY ? Uint32Array : Array)(286 + 30),\n        nResult,\n        rpt,\n        freqs = new (USE_TYPEDARRAY ? Uint8Array : Array)(19);\n\n    j = 0;\n    for (i = 0; i < hlit; i++) {\n      src[j++] = litlenLengths[i];\n    }\n    for (i = 0; i < hdist; i++) {\n      src[j++] = distLengths[i];\n    }\n\n    // 初期化\n    if (!USE_TYPEDARRAY) {\n      for (i = 0, l = freqs.length; i < l; ++i) {\n        freqs[i] = 0;\n      }\n    }\n\n    // 符号化\n    nResult = 0;\n    for (i = 0, l = src.length; i < l; i += j) {\n      // Run Length Encoding\n      for (j = 1; i + j < l && src[i + j] === src[i]; ++j) {}\n\n      runLength = j;\n\n      if (src[i] === 0) {\n        // 0 の繰り返しが 3 回未満ならばそのまま\n        if (runLength < 3) {\n          while (runLength-- > 0) {\n            result[nResult++] = 0;\n            freqs[0]++;\n          }\n        } else {\n          while (runLength > 0) {\n            // 繰り返しは最大 138 までなので切り詰める\n            rpt = (runLength < 138 ? runLength : 138);\n\n            if (rpt > runLength - 3 && rpt < runLength) {\n              rpt = runLength - 3;\n            }\n\n            // 3-10 回 -> 17\n            if (rpt <= 10) {\n              result[nResult++] = 17;\n              result[nResult++] = rpt - 3;\n              freqs[17]++;\n            // 11-138 回 -> 18\n            } else {\n              result[nResult++] = 18;\n              result[nResult++] = rpt - 11;\n              freqs[18]++;\n            }\n\n            runLength -= rpt;\n          }\n        }\n      } else {\n        result[nResult++] = src[i];\n        freqs[src[i]]++;\n        runLength--;\n\n        // 繰り返し回数が3回未満ならばランレングス符号は要らない\n        if (runLength < 3) {\n          while (runLength-- > 0) {\n            result[nResult++] = src[i];\n            freqs[src[i]]++;\n          }\n        // 3 回以上ならばランレングス符号化\n        } else {\n          while (runLength > 0) {\n            // runLengthを 3-6 で分割\n            rpt = (runLength < 6 ? runLength : 6);\n\n            if (rpt > runLength - 3 && rpt < runLength) {\n              rpt = runLength - 3;\n            }\n\n            result[nResult++] = 16;\n            result[nResult++] = rpt - 3;\n            freqs[16]++;\n\n            runLength -= rpt;\n          }\n        }\n      }\n    }\n\n    return {\n      codes:\n        USE_TYPEDARRAY ? result.subarray(0, nResult) : result.slice(0, nResult),\n      freqs: freqs\n    };\n  };\n\n  /**\n   * ハフマン符号の長さを取得する\n   * @param {!(Array.<number>|Uint8Array|Uint32Array)} freqs 出現カウント.\n   * @param {number} limit 符号長の制限.\n   * @return {!(Array.<number>|Uint8Array)} 符号長配列.\n   * @private\n   */\n  RawDeflate.prototype.getLengths_ = function(freqs, limit) {\n    /** @type {number} */\n    var nSymbols = freqs.length;\n    /** @type {Heap} */\n    var heap = new Heap(2 * RawDeflate.HUFMAX);\n    /** @type {!(Array.<number>|Uint8Array)} */\n    var length = new (USE_TYPEDARRAY ? Uint8Array : Array)(nSymbols);\n    /** @type {Array} */\n    var nodes;\n    /** @type {!(Array.<number>|Uint32Array)} */\n    var values;\n    /** @type {!(Array.<number>|Uint8Array)} */\n    var codeLength;\n    /** @type {number} */\n    var i;\n    /** @type {number} */\n    var il;\n\n    // 配列の初期化\n    if (!USE_TYPEDARRAY) {\n      for (i = 0; i < nSymbols; i++) {\n        length[i] = 0;\n      }\n    }\n\n    // ヒープの構築\n    for (i = 0; i < nSymbols; ++i) {\n      if (freqs[i] > 0) {\n        heap.push(i, freqs[i]);\n      }\n    }\n    nodes = new Array(heap.length / 2);\n    values = new (USE_TYPEDARRAY ? Uint32Array : Array)(heap.length / 2);\n\n    // 非 0 の要素が一つだけだった場合は、そのシンボルに符号長 1 を割り当てて終了\n    if (nodes.length === 1) {\n      length[heap.pop().index] = 1;\n      return length;\n    }\n\n    // Reverse Package Merge Algorithm による Canonical Huffman Code の符号長決定\n    for (i = 0, il = heap.length / 2; i < il; ++i) {\n      nodes[i] = heap.pop();\n      values[i] = nodes[i].value;\n    }\n    codeLength = this.reversePackageMerge_(values, values.length, limit);\n\n    for (i = 0, il = nodes.length; i < il; ++i) {\n      length[nodes[i].index] = codeLength[i];\n    }\n\n    return length;\n  };\n\n  /**\n   * Reverse Package Merge Algorithm.\n   * @param {!(Array.<number>|Uint32Array)} freqs sorted probability.\n   * @param {number} symbols number of symbols.\n   * @param {number} limit code length limit.\n   * @return {!(Array.<number>|Uint8Array)} code lengths.\n   */\n  RawDeflate.prototype.reversePackageMerge_ = function(freqs, symbols, limit) {\n    /** @type {!(Array.<number>|Uint16Array)} */\n    var minimumCost = new (USE_TYPEDARRAY ? Uint16Array : Array)(limit);\n    /** @type {!(Array.<number>|Uint8Array)} */\n    var flag = new (USE_TYPEDARRAY ? Uint8Array : Array)(limit);\n    /** @type {!(Array.<number>|Uint8Array)} */\n    var codeLength = new (USE_TYPEDARRAY ? Uint8Array : Array)(symbols);\n    /** @type {Array} */\n    var value = new Array(limit);\n    /** @type {Array} */\n    var type  = new Array(limit);\n    /** @type {Array.<number>} */\n    var currentPosition = new Array(limit);\n    /** @type {number} */\n    var excess = (1 << limit) - symbols;\n    /** @type {number} */\n    var half = (1 << (limit - 1));\n    /** @type {number} */\n    var i;\n    /** @type {number} */\n    var j;\n    /** @type {number} */\n    var t;\n    /** @type {number} */\n    var weight;\n    /** @type {number} */\n    var next;\n\n    /**\n     * @param {number} j\n     */\n    function takePackage(j) {\n      /** @type {number} */\n      var x = type[j][currentPosition[j]];\n\n      if (x === symbols) {\n        takePackage(j+1);\n        takePackage(j+1);\n      } else {\n        --codeLength[x];\n      }\n\n      ++currentPosition[j];\n    }\n\n    minimumCost[limit-1] = symbols;\n\n    for (j = 0; j < limit; ++j) {\n      if (excess < half) {\n        flag[j] = 0;\n      } else {\n        flag[j] = 1;\n        excess -= half;\n      }\n      excess <<= 1;\n      minimumCost[limit-2-j] = (minimumCost[limit-1-j] / 2 | 0) + symbols;\n    }\n    minimumCost[0] = flag[0];\n\n    value[0] = new Array(minimumCost[0]);\n    type[0]  = new Array(minimumCost[0]);\n    for (j = 1; j < limit; ++j) {\n      if (minimumCost[j] > 2 * minimumCost[j-1] + flag[j]) {\n        minimumCost[j] = 2 * minimumCost[j-1] + flag[j];\n      }\n      value[j] = new Array(minimumCost[j]);\n      type[j]  = new Array(minimumCost[j]);\n    }\n\n    for (i = 0; i < symbols; ++i) {\n      codeLength[i] = limit;\n    }\n\n    for (t = 0; t < minimumCost[limit-1]; ++t) {\n      value[limit-1][t] = freqs[t];\n      type[limit-1][t]  = t;\n    }\n\n    for (i = 0; i < limit; ++i) {\n      currentPosition[i] = 0;\n    }\n    if (flag[limit-1] === 1) {\n      --codeLength[0];\n      ++currentPosition[limit-1];\n    }\n\n    for (j = limit-2; j >= 0; --j) {\n      i = 0;\n      weight = 0;\n      next = currentPosition[j+1];\n\n      for (t = 0; t < minimumCost[j]; t++) {\n        weight = value[j+1][next] + value[j+1][next+1];\n\n        if (weight > freqs[i]) {\n          value[j][t] = weight;\n          type[j][t] = symbols;\n          next += 2;\n        } else {\n          value[j][t] = freqs[i];\n          type[j][t] = i;\n          ++i;\n        }\n      }\n\n      currentPosition[j] = 0;\n      if (flag[j] === 1) {\n        takePackage(j);\n      }\n    }\n\n    return codeLength;\n  };\n\n  /**\n   * 符号長配列からハフマン符号を取得する\n   * reference: PuTTY Deflate implementation\n   * @param {!(Array.<number>|Uint8Array)} lengths 符号長配列.\n   * @return {!(Array.<number>|Uint16Array)} ハフマン符号配列.\n   * @private\n   */\n  RawDeflate.prototype.getCodesFromLengths_ = function(lengths) {\n    var codes = new (USE_TYPEDARRAY ? Uint16Array : Array)(lengths.length),\n        count = [],\n        startCode = [],\n        code = 0, i, il, j, m;\n\n    // Count the codes of each length.\n    for (i = 0, il = lengths.length; i < il; i++) {\n      count[lengths[i]] = (count[lengths[i]] | 0) + 1;\n    }\n\n    // Determine the starting code for each length block.\n    for (i = 1, il = RawDeflate.MaxCodeLength; i <= il; i++) {\n      startCode[i] = code;\n      code += count[i] | 0;\n      code <<= 1;\n    }\n\n    // Determine the code for each symbol. Mirrored, of course.\n    for (i = 0, il = lengths.length; i < il; i++) {\n      code = startCode[lengths[i]];\n      startCode[lengths[i]] += 1;\n      codes[i] = 0;\n\n      for (j = 0, m = lengths[i]; j < m; j++) {\n        codes[i] = (codes[i] << 1) | (code & 1);\n        code >>>= 1;\n      }\n    }\n\n    return codes;\n  };\n\n  return Zlib.RawDeflate = RawDeflate;\n  \n});\n\n"]}