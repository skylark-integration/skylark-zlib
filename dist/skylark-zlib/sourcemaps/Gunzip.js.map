{"version":3,"sources":["Gunzip.js"],"names":["define","Zlib","CRC32","Gzip","RawInflate","GunzipMember","Gunzip","input","opt_params","this","ip","member","decompressed","prototype","getMembers","decompress","slice","il","length","decodeMember","concatMember","isize","rawinflate","inflated","inflen","c","ci","str","mtime","crc32","id1","id2","Error","cm","flg","Date","xfl","os","FlagsMask","FEXTRA","xlen","decodeSubField","FNAME","String","fromCharCode","name","join","FCOMMENT","comment","FHCRC","crc16","calc","index","bufferSize","data","toString","push","i","buffer","p","size","Uint8Array","set"],"mappings":"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","file":"../Gunzip.js","sourcesContent":["define([\n  \"./zlib\",\n  \"./crc32\",\n  \"./Gzip\",\n  \"./RawInflate\",\n  \"./GunzipMember\"\n],function(Zlib,CRC32,Gzip,RawInflate,GunzipMember) {\n  /**\n   * @fileoverview GZIP (RFC1952) 展開コンテナ実装.\n   */\n\n\n   const USE_TYPEDARRAY = true;\n\n  /**\n   * @constructor\n   * @param {!(Array|Uint8Array)} input input buffer.\n   * @param {Object=} opt_params option parameters.\n   */\n  var Gunzip = function(input, opt_params) {\n    /** @type {!(Array.<number>|Uint8Array)} input buffer. */\n    this.input = input;\n    /** @type {number} input buffer pointer. */\n    this.ip = 0;\n    /** @type {Array.<GunzipMember>} */\n    this.member = [];\n    /** @type {boolean} */\n    this.decompressed = false;\n  };\n\n  /**\n   * @return {Array.<GunzipMember>}\n   */\n  Gunzip.prototype.getMembers = function() {\n    if (!this.decompressed) {\n      this.decompress();\n    }\n\n    return this.member.slice();\n  };\n\n  /**\n   * inflate gzip data.\n   * @return {!(Array.<number>|Uint8Array)} inflated buffer.\n   */\n  Gunzip.prototype.decompress = function() {\n    /** @type {number} input length. */\n    var il = this.input.length;\n\n    while (this.ip < il) {\n      this.decodeMember();\n    }\n\n    this.decompressed = true;\n\n    return this.concatMember();\n  };\n\n  /**\n   * decode gzip member.\n   */\n  Gunzip.prototype.decodeMember = function() {\n    /** @type {GunzipMember} */\n    var member = new GunzipMember();\n    /** @type {number} */\n    var isize;\n    /** @type {RawInflate} RawInflate implementation. */\n    var rawinflate;\n    /** @type {!(Array.<number>|Uint8Array)} inflated data. */\n    var inflated;\n    /** @type {number} inflate size */\n    var inflen;\n    /** @type {number} character code */\n    var c;\n    /** @type {number} character index in string. */\n    var ci;\n    /** @type {Array.<string>} character array. */\n    var str;\n    /** @type {number} modification time. */\n    var mtime;\n    /** @type {number} */\n    var crc32;\n\n    var input = this.input;\n    var ip = this.ip;\n\n    member.id1 = input[ip++];\n    member.id2 = input[ip++];\n\n    // check signature\n    if (member.id1 !== 0x1f || member.id2 !== 0x8b) {\n      throw new Error('invalid file signature:' + member.id1 + ',' + member.id2);\n    }\n\n    // check compression method\n    member.cm = input[ip++];\n    switch (member.cm) {\n      case 8: /* XXX: use Zlib const */\n        break;\n      default:\n        throw new Error('unknown compression method: ' + member.cm);\n    }\n\n    // flags\n    member.flg = input[ip++];\n\n    // modification time\n    mtime = (input[ip++])       |\n            (input[ip++] << 8)  |\n            (input[ip++] << 16) |\n            (input[ip++] << 24);\n    member.mtime = new Date(mtime * 1000);\n\n    // extra flags\n    member.xfl = input[ip++];\n\n    // operating system\n    member.os = input[ip++];\n\n    // extra\n    if ((member.flg & Gzip.FlagsMask.FEXTRA) > 0) {\n      member.xlen = input[ip++] | (input[ip++] << 8);\n      ip = this.decodeSubField(ip, member.xlen);\n    }\n\n    // fname\n    if ((member.flg & Gzip.FlagsMask.FNAME) > 0) {\n      for(str = [], ci = 0; (c = input[ip++]) > 0;) {\n        str[ci++] = String.fromCharCode(c);\n      }\n      member.name = str.join('');\n    }\n\n    // fcomment\n    if ((member.flg & Gzip.FlagsMask.FCOMMENT) > 0) {\n      for(str = [], ci = 0; (c = input[ip++]) > 0;) {\n        str[ci++] = String.fromCharCode(c);\n      }\n      member.comment = str.join('');\n    }\n\n    // fhcrc\n    if ((member.flg & Gzip.FlagsMask.FHCRC) > 0) {\n      member.crc16 = CRC32.calc(input, 0, ip) & 0xffff;\n      if (member.crc16 !== (input[ip++] | (input[ip++] << 8))) {\n        throw new Error('invalid header crc16');\n      }\n    }\n\n    // isize を事前に取得すると展開後のサイズが分かるため、\n    // inflate処理のバッファサイズが事前に分かり、高速になる\n    isize = (input[input.length - 4])       | (input[input.length - 3] << 8) |\n            (input[input.length - 2] << 16) | (input[input.length - 1] << 24);\n\n    // isize の妥当性チェック\n    // ハフマン符号では最小 2-bit のため、最大で 1/4 になる\n    // LZ77 符号では 長さと距離 2-Byte で最大 258-Byte を表現できるため、\n    // 1/128 になるとする\n    // ここから入力バッファの残りが isize の 512 倍以上だったら\n    // サイズ指定のバッファ確保は行わない事とする\n    if (input.length - ip - /* CRC-32 */4 - /* ISIZE */4 < isize * 512) {\n      inflen = isize;\n    }\n\n    // compressed block\n    rawinflate = new RawInflate(input, {'index': ip, 'bufferSize': inflen});\n    member.data = inflated = rawinflate.decompress();\n    ip = rawinflate.ip;\n\n    // crc32\n    member.crc32 = crc32 =\n      ((input[ip++])       | (input[ip++] << 8) |\n       (input[ip++] << 16) | (input[ip++] << 24)) >>> 0;\n    if (CRC32.calc(inflated) !== crc32) {\n      throw new Error('invalid CRC-32 checksum: 0x' +\n          CRC32.calc(inflated).toString(16) + ' / 0x' + crc32.toString(16));\n    }\n\n    // input size\n    member.isize = isize =\n      ((input[ip++])       | (input[ip++] << 8) |\n       (input[ip++] << 16) | (input[ip++] << 24)) >>> 0;\n    if ((inflated.length & 0xffffffff) !== isize) {\n      throw new Error('invalid input size: ' +\n          (inflated.length & 0xffffffff) + ' / ' + isize);\n    }\n\n    this.member.push(member);\n    this.ip = ip;\n  };\n\n  /**\n   * サブフィールドのデコード\n   * XXX: 現在は何もせずスキップする\n   */\n  Gunzip.prototype.decodeSubField = function(ip, length) {\n    return ip + length;\n  };\n\n  /**\n   * @return {!(Array.<number>|Uint8Array)}\n   */\n  Gunzip.prototype.concatMember = function() {\n    /** @type {Array.<GunzipMember>} */\n    var member = this.member;\n    /** @type {number} */\n    var i;\n    /** @type {number} */\n    var il;\n    /** @type {number} */\n    var p = 0;\n    /** @type {number} */\n    var size = 0;\n    /** @type {!(Array.<number>|Uint8Array)} */\n    var buffer;\n\n    for (i = 0, il = member.length; i < il; ++i) {\n      size += member[i].data.length;\n    }\n\n    if (USE_TYPEDARRAY) {\n      buffer = new Uint8Array(size);\n      for (i = 0; i < il; ++i) {\n        buffer.set(member[i].data, p);\n        p += member[i].data.length;\n      }\n    } else {\n      buffer = [];\n      for (i = 0; i < il; ++i) {\n        buffer[i] = member[i].data;\n      }\n      buffer = Array.prototype.concat.apply([], buffer);\n    }\n\n    return buffer;\n  };\n\n  return Zlib.Gunzip = Gunzip;\n});\n"]}