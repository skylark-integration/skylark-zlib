{"version":3,"sources":["Heap.js"],"names":["define","Zlib","Heap","length","this","buffer","Uint16Array","prototype","getParent","index","getChild","push","value","current","parent","swap","heap","pop"],"mappings":";;;;;;;AAAAA,QACE,UACA,SAASC,GAWT,IAAIC,EAAO,SAASC,GAClBC,KAAKC,OAAS,IAAsBC,YAA8B,EAATH,GACzDC,KAAKD,OAAS,GAkHhB,OAzGAD,EAAKK,UAAUC,UAAY,SAASC,GAClC,OAA+B,IAAtBA,EAAQ,GAAK,EAAI,IAQ5BP,EAAKK,UAAUG,SAAW,SAASD,GACjC,OAAO,EAAIA,EAAQ,GASrBP,EAAKK,UAAUI,KAAO,SAASF,EAAOG,GACpC,IAAIC,EAASC,EAETC,EADAC,EAAOZ,KAAKC,OAQhB,IALAQ,EAAUT,KAAKD,OACfa,EAAKZ,KAAKD,UAAYS,EACtBI,EAAKZ,KAAKD,UAAYM,EAGfI,EAAU,IACfC,EAASV,KAAKI,UAAUK,GAGpBG,EAAKH,GAAWG,EAAKF,KACvBC,EAAOC,EAAKH,GACZG,EAAKH,GAAWG,EAAKF,GACrBE,EAAKF,GAAUC,EAEfA,EAAOC,EAAKH,EAAU,GACtBG,EAAKH,EAAU,GAAKG,EAAKF,EAAS,GAClCE,EAAKF,EAAS,GAAKC,EAEnBF,EAAUC,EAOd,OAAOV,KAAKD,QAQdD,EAAKK,UAAUU,IAAM,WACnB,IAAIR,EAAOG,EACaG,EACpBF,EAASC,EADTE,EAAOZ,KAAKC,OAahB,IAVAO,EAAQI,EAAK,GACbP,EAAQO,EAAK,GAGbZ,KAAKD,QAAU,EACfa,EAAK,GAAKA,EAAKZ,KAAKD,QACpBa,EAAK,GAAKA,EAAKZ,KAAKD,OAAS,GAE7BW,EAAS,KAGPD,EAAUT,KAAKM,SAASI,KAGTV,KAAKD,UAKhBU,EAAU,EAAIT,KAAKD,QAAUa,EAAKH,EAAU,GAAKG,EAAKH,KACxDA,GAAW,GAITG,EAAKH,GAAWG,EAAKF,KACvBC,EAAOC,EAAKF,GACZE,EAAKF,GAAUE,EAAKH,GACpBG,EAAKH,GAAWE,EAEhBA,EAAOC,EAAKF,EAAS,GACrBE,EAAKF,EAAS,GAAKE,EAAKH,EAAU,GAClCG,EAAKH,EAAU,GAAKE,EAKtBD,EAASD,EAGX,OAAQJ,MAAOA,EAAOG,MAAOA,EAAOT,OAAQC,KAAKD,SAI5CF,EAAKC,KAAOA","file":"../Heap.js","sourcesContent":["define([\r\n  \"./zlib\"\r\n],function(Zlib) {\r\n  /**\r\n   * @fileoverview Heap Sort 実装. ハフマン符号化で使用する.\r\n   */\r\n  const USE_TYPEDARRAY = true;\r\n\r\n  /*\r\n   * カスタムハフマン符号で使用するヒープ実装\r\n   * @param {number} length ヒープサイズ.\r\n   * @constructor\r\n   */\r\n  var Heap = function(length) {\r\n    this.buffer = new (USE_TYPEDARRAY ? Uint16Array : Array)(length * 2);\r\n    this.length = 0;\r\n  };\r\n\r\n  /**\r\n   * 親ノードの index 取得\r\n   * @param {number} index 子ノードの index.\r\n   * @return {number} 親ノードの index.\r\n   *\r\n   */\r\n  Heap.prototype.getParent = function(index) {\r\n    return ((index - 2) / 4 | 0) * 2;\r\n  };\r\n\r\n  /**\r\n   * 子ノードの index 取得\r\n   * @param {number} index 親ノードの index.\r\n   * @return {number} 子ノードの index.\r\n   */\r\n  Heap.prototype.getChild = function(index) {\r\n    return 2 * index + 2;\r\n  };\r\n\r\n  /**\r\n   * Heap に値を追加する\r\n   * @param {number} index キー index.\r\n   * @param {number} value 値.\r\n   * @return {number} 現在のヒープ長.\r\n   */\r\n  Heap.prototype.push = function(index, value) {\r\n    var current, parent,\r\n        heap = this.buffer,\r\n        swap;\r\n\r\n    current = this.length;\r\n    heap[this.length++] = value;\r\n    heap[this.length++] = index;\r\n\r\n    // ルートノードにたどり着くまで入れ替えを試みる\r\n    while (current > 0) {\r\n      parent = this.getParent(current);\r\n\r\n      // 親ノードと比較して親の方が小さければ入れ替える\r\n      if (heap[current] > heap[parent]) {\r\n        swap = heap[current];\r\n        heap[current] = heap[parent];\r\n        heap[parent] = swap;\r\n\r\n        swap = heap[current + 1];\r\n        heap[current + 1] = heap[parent + 1];\r\n        heap[parent + 1] = swap;\r\n\r\n        current = parent;\r\n      // 入れ替えが必要なくなったらそこで抜ける\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return this.length;\r\n  };\r\n\r\n  /**\r\n   * Heapから一番大きい値を返す\r\n   * @return {{index: number, value: number, length: number}} {index: キーindex,\r\n   *     value: 値, length: ヒープ長} の Object.\r\n   */\r\n  Heap.prototype.pop = function() {\r\n    var index, value,\r\n        heap = this.buffer, swap,\r\n        current, parent;\r\n\r\n    value = heap[0];\r\n    index = heap[1];\r\n\r\n    // 後ろから値を取る\r\n    this.length -= 2;\r\n    heap[0] = heap[this.length];\r\n    heap[1] = heap[this.length + 1];\r\n\r\n    parent = 0;\r\n    // ルートノードから下がっていく\r\n    while (true) {\r\n      current = this.getChild(parent);\r\n\r\n      // 範囲チェック\r\n      if (current >= this.length) {\r\n        break;\r\n      }\r\n\r\n      // 隣のノードと比較して、隣の方が値が大きければ隣を現在ノードとして選択\r\n      if (current + 2 < this.length && heap[current + 2] > heap[current]) {\r\n        current += 2;\r\n      }\r\n\r\n      // 親ノードと比較して親の方が小さい場合は入れ替える\r\n      if (heap[current] > heap[parent]) {\r\n        swap = heap[parent];\r\n        heap[parent] = heap[current];\r\n        heap[current] = swap;\r\n\r\n        swap = heap[parent + 1];\r\n        heap[parent + 1] = heap[current + 1];\r\n        heap[current + 1] = swap;\r\n      } else {\r\n        break;\r\n      }\r\n\r\n      parent = current;\r\n    }\r\n\r\n    return {index: index, value: value, length: this.length};\r\n  };\r\n\r\n\r\n  return Zlib.Heap = Heap;\r\n});\r\n\r\n"]}