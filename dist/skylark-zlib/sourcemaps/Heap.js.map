{"version":3,"sources":["Heap.js"],"names":["define","Zlib","Heap","length","this","buffer","Uint16Array","prototype","getParent","index","getChild","push","value","current","parent","swap","heap","pop"],"mappings":";;;;;;;AAAAA,QACE,UACA,SAASC,GAWT,IAAIC,EAAO,SAASC,GAClBC,KAAKC,OAAS,IAAsBC,YAA8B,EAATH,GACzDC,KAAKD,OAAS,GAkHhB,OAzGAD,EAAKK,UAAUC,UAAY,SAASC,GAClC,OAA+B,IAAtBA,EAAQ,GAAK,EAAI,IAQ5BP,EAAKK,UAAUG,SAAW,SAASD,GACjC,OAAO,EAAIA,EAAQ,GASrBP,EAAKK,UAAUI,KAAO,SAASF,EAAOG,GACpC,IAAIC,EAASC,EAETC,EADAC,EAAOZ,KAAKC,OAQhB,IALAQ,EAAUT,KAAKD,OACfa,EAAKZ,KAAKD,UAAYS,EACtBI,EAAKZ,KAAKD,UAAYM,EAGfI,EAAU,IACfC,EAASV,KAAKI,UAAUK,GAGpBG,EAAKH,GAAWG,EAAKF,KACvBC,EAAOC,EAAKH,GACZG,EAAKH,GAAWG,EAAKF,GACrBE,EAAKF,GAAUC,EAEfA,EAAOC,EAAKH,EAAU,GACtBG,EAAKH,EAAU,GAAKG,EAAKF,EAAS,GAClCE,EAAKF,EAAS,GAAKC,EAEnBF,EAAUC,EAOd,OAAOV,KAAKD,QAQdD,EAAKK,UAAUU,IAAM,WACnB,IAAIR,EAAOG,EACaG,EACpBF,EAASC,EADTE,EAAOZ,KAAKC,OAahB,IAVAO,EAAQI,EAAK,GACbP,EAAQO,EAAK,GAGbZ,KAAKD,QAAU,EACfa,EAAK,GAAKA,EAAKZ,KAAKD,QACpBa,EAAK,GAAKA,EAAKZ,KAAKD,OAAS,GAE7BW,EAAS,KAGPD,EAAUT,KAAKM,SAASI,KAGTV,KAAKD,UAKhBU,EAAU,EAAIT,KAAKD,QAAUa,EAAKH,EAAU,GAAKG,EAAKH,KACxDA,GAAW,GAITG,EAAKH,GAAWG,EAAKF,KACvBC,EAAOC,EAAKF,GACZE,EAAKF,GAAUE,EAAKH,GACpBG,EAAKH,GAAWE,EAEhBA,EAAOC,EAAKF,EAAS,GACrBE,EAAKF,EAAS,GAAKE,EAAKH,EAAU,GAClCG,EAAKH,EAAU,GAAKE,EAKtBD,EAASD,EAGX,OAAQJ,MAAOA,EAAOG,MAAOA,EAAOT,OAAQC,KAAKD,SAI5CF,EAAKC,KAAOA","file":"../Heap.js","sourcesContent":["define([\n  \"./zlib\"\n],function(Zlib) {\n  /**\n   * @fileoverview Heap Sort 実装. ハフマン符号化で使用する.\n   */\n  const USE_TYPEDARRAY = true;\n\n  /*\n   * カスタムハフマン符号で使用するヒープ実装\n   * @param {number} length ヒープサイズ.\n   * @constructor\n   */\n  var Heap = function(length) {\n    this.buffer = new (USE_TYPEDARRAY ? Uint16Array : Array)(length * 2);\n    this.length = 0;\n  };\n\n  /**\n   * 親ノードの index 取得\n   * @param {number} index 子ノードの index.\n   * @return {number} 親ノードの index.\n   *\n   */\n  Heap.prototype.getParent = function(index) {\n    return ((index - 2) / 4 | 0) * 2;\n  };\n\n  /**\n   * 子ノードの index 取得\n   * @param {number} index 親ノードの index.\n   * @return {number} 子ノードの index.\n   */\n  Heap.prototype.getChild = function(index) {\n    return 2 * index + 2;\n  };\n\n  /**\n   * Heap に値を追加する\n   * @param {number} index キー index.\n   * @param {number} value 値.\n   * @return {number} 現在のヒープ長.\n   */\n  Heap.prototype.push = function(index, value) {\n    var current, parent,\n        heap = this.buffer,\n        swap;\n\n    current = this.length;\n    heap[this.length++] = value;\n    heap[this.length++] = index;\n\n    // ルートノードにたどり着くまで入れ替えを試みる\n    while (current > 0) {\n      parent = this.getParent(current);\n\n      // 親ノードと比較して親の方が小さければ入れ替える\n      if (heap[current] > heap[parent]) {\n        swap = heap[current];\n        heap[current] = heap[parent];\n        heap[parent] = swap;\n\n        swap = heap[current + 1];\n        heap[current + 1] = heap[parent + 1];\n        heap[parent + 1] = swap;\n\n        current = parent;\n      // 入れ替えが必要なくなったらそこで抜ける\n      } else {\n        break;\n      }\n    }\n\n    return this.length;\n  };\n\n  /**\n   * Heapから一番大きい値を返す\n   * @return {{index: number, value: number, length: number}} {index: キーindex,\n   *     value: 値, length: ヒープ長} の Object.\n   */\n  Heap.prototype.pop = function() {\n    var index, value,\n        heap = this.buffer, swap,\n        current, parent;\n\n    value = heap[0];\n    index = heap[1];\n\n    // 後ろから値を取る\n    this.length -= 2;\n    heap[0] = heap[this.length];\n    heap[1] = heap[this.length + 1];\n\n    parent = 0;\n    // ルートノードから下がっていく\n    while (true) {\n      current = this.getChild(parent);\n\n      // 範囲チェック\n      if (current >= this.length) {\n        break;\n      }\n\n      // 隣のノードと比較して、隣の方が値が大きければ隣を現在ノードとして選択\n      if (current + 2 < this.length && heap[current + 2] > heap[current]) {\n        current += 2;\n      }\n\n      // 親ノードと比較して親の方が小さい場合は入れ替える\n      if (heap[current] > heap[parent]) {\n        swap = heap[parent];\n        heap[parent] = heap[current];\n        heap[current] = swap;\n\n        swap = heap[parent + 1];\n        heap[parent + 1] = heap[current + 1];\n        heap[current + 1] = swap;\n      } else {\n        break;\n      }\n\n      parent = current;\n    }\n\n    return {index: index, value: value, length: this.length};\n  };\n\n\n  return Zlib.Heap = Heap;\n});\n\n"]}