{"version":3,"sources":["skylark-zlib.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"../skylark-zlib.js","sourcesContent":["define('skylark-zlib/zlib',[\r\n\t\"skylark-langx/skylark\"\r\n],function(skylark) {\r\n\treturn skylark.attach(\"intg.Zlib\",{\r\n\t\tCompressionMethod : {\r\n\t\t  DEFLATE: 8,\r\n\t\t  RESERVED: 15\r\n\r\n\t\t}\r\n\t})\r\n});\r\n\ndefine('skylark-zlib/util',[\r\n  \"./zlib\"\r\n],function(Zlib) {\r\n  /**\r\n   * @fileoverview 雑多な関数群をまとめたモジュール実装.\r\n   */\r\n  var Util = {};\r\n\r\n  /**\r\n   * Byte String から Byte Array に変換.\r\n   * @param {!string} str byte string.\r\n   * @return {!Array.<number>} byte array.\r\n   */\r\n  Util.stringToByteArray = function(str) {\r\n    /** @type {!Array.<(string|number)>} */\r\n    var tmp = str.split('');\r\n    /** @type {number} */\r\n    var i;\r\n    /** @type {number} */\r\n    var il;\r\n\r\n    for (i = 0, il = tmp.length; i < il; i++) {\r\n      tmp[i] = (tmp[i].charCodeAt(0) & 0xff) >>> 0;\r\n    }\r\n\r\n    return tmp;\r\n  };\r\n\r\n  return Zlib.Util = Util;\r\n\r\n});\r\n\r\n\r\n\ndefine('skylark-zlib/adler32',[\r\n  \"./zlib\",\r\n  \"./util\"\r\n],function(Zlib,Util){\r\n\r\n  var Adler32 = function(array) {\r\n    if (typeof(array) === 'string') {\r\n      array = Util.stringToByteArray(array);\r\n    }\r\n    return Adler32.update(1, array);\r\n  };\r\n\r\n  /**\r\n   * Adler32 ハッシュ値の更新\r\n   * @param {number} adler 現在のハッシュ値.\r\n   * @param {!(Array|Uint8Array)} array 更新に使用する byte array.\r\n   * @return {number} Adler32 ハッシュ値.\r\n   */\r\n  Adler32.update = function(adler, array) {\r\n    /** @type {number} */\r\n    var s1 = adler & 0xffff;\r\n    /** @type {number} */\r\n    var s2 = (adler >>> 16) & 0xffff;\r\n    /** @type {number} array length */\r\n    var len = array.length;\r\n    /** @type {number} loop length (don't overflow) */\r\n    var tlen;\r\n    /** @type {number} array index */\r\n    var i = 0;\r\n\r\n    while (len > 0) {\r\n      tlen = len > Adler32.OptimizationParameter ?\r\n        Adler32.OptimizationParameter : len;\r\n      len -= tlen;\r\n      do {\r\n        s1 += array[i++];\r\n        s2 += s1;\r\n      } while (--tlen);\r\n\r\n      s1 %= 65521;\r\n      s2 %= 65521;\r\n    }\r\n\r\n    return ((s2 << 16) | s1) >>> 0;\r\n  };\r\n\r\n  /**\r\n   * Adler32 最適化パラメータ\r\n   * 現状では 1024 程度が最適.\r\n   * @see http://jsperf.com/adler-32-simple-vs-optimized/3\r\n   * @define {number}\r\n   */\r\n  Adler32.OptimizationParameter = 1024;\r\n\r\n\r\n  return Zlib.Adler32 = Adler32;\r\n\r\n});\r\n\ndefine('skylark-zlib/BitStream',[\r\n  \"./zlib\"\r\n],function(Zlib) {\r\n  const USE_TYPEDARRAY = true;\r\n  /**\r\n   * @fileoverview bit 単位での書き込み実装.\r\n   */\r\n\r\n  /**\r\n   * ビットストリーム\r\n   * @constructor\r\n   * @param {!(Array|Uint8Array)=} buffer output buffer.\r\n   * @param {number=} bufferPosition start buffer pointer.\r\n   */\r\n  var BitStream = function(buffer, bufferPosition) {\r\n    /** @type {number} buffer index. */\r\n    this.index = typeof bufferPosition === 'number' ? bufferPosition : 0;\r\n    /** @type {number} bit index. */\r\n    this.bitindex = 0;\r\n    /** @type {!(Array|Uint8Array)} bit-stream output buffer. */\r\n    this.buffer = buffer instanceof (USE_TYPEDARRAY ? Uint8Array : Array) ?\r\n      buffer :\r\n      new (USE_TYPEDARRAY ? Uint8Array : Array)(BitStream.DefaultBlockSize);\r\n\r\n    // 入力された index が足りなかったら拡張するが、倍にしてもダメなら不正とする\r\n    if (this.buffer.length * 2 <= this.index) {\r\n      throw new Error(\"invalid index\");\r\n    } else if (this.buffer.length <= this.index) {\r\n      this.expandBuffer();\r\n    }\r\n  };\r\n\r\n  /**\r\n   * デフォルトブロックサイズ.\r\n   * @const\r\n   * @type {number}\r\n   */\r\n  BitStream.DefaultBlockSize = 0x8000;\r\n\r\n  /**\r\n   * expand buffer.\r\n   * @return {!(Array|Uint8Array)} new buffer.\r\n   */\r\n  BitStream.prototype.expandBuffer = function() {\r\n    /** @type {!(Array|Uint8Array)} old buffer. */\r\n    var oldbuf = this.buffer;\r\n    /** @type {number} loop counter. */\r\n    var i;\r\n    /** @type {number} loop limiter. */\r\n    var il = oldbuf.length;\r\n    /** @type {!(Array|Uint8Array)} new buffer. */\r\n    var buffer =\r\n      new (USE_TYPEDARRAY ? Uint8Array : Array)(il << 1);\r\n\r\n    // copy buffer\r\n    if (USE_TYPEDARRAY) {\r\n      buffer.set(oldbuf);\r\n    } else {\r\n      // XXX: loop unrolling\r\n      for (i = 0; i < il; ++i) {\r\n        buffer[i] = oldbuf[i];\r\n      }\r\n    }\r\n\r\n    return (this.buffer = buffer);\r\n  };\r\n\r\n\r\n  /**\r\n   * 数値をビットで指定した数だけ書き込む.\r\n   * @param {number} number 書き込む数値.\r\n   * @param {number} n 書き込むビット数.\r\n   * @param {boolean=} reverse 逆順に書き込むならば true.\r\n   */\r\n  BitStream.prototype.writeBits = function(number, n, reverse) {\r\n    var buffer = this.buffer;\r\n    var index = this.index;\r\n    var bitindex = this.bitindex;\r\n\r\n    /** @type {number} current octet. */\r\n    var current = buffer[index];\r\n    /** @type {number} loop counter. */\r\n    var i;\r\n\r\n    /**\r\n     * 32-bit 整数のビット順を逆にする\r\n     * @param {number} n 32-bit integer.\r\n     * @return {number} reversed 32-bit integer.\r\n     * @private\r\n     */\r\n    function rev32_(n) {\r\n      return (BitStream.ReverseTable[n & 0xFF] << 24) |\r\n        (BitStream.ReverseTable[n >>> 8 & 0xFF] << 16) |\r\n        (BitStream.ReverseTable[n >>> 16 & 0xFF] << 8) |\r\n        BitStream.ReverseTable[n >>> 24 & 0xFF];\r\n    }\r\n\r\n    if (reverse && n > 1) {\r\n      number = n > 8 ?\r\n        rev32_(number) >> (32 - n) :\r\n        BitStream.ReverseTable[number] >> (8 - n);\r\n    }\r\n\r\n    // Byte 境界を超えないとき\r\n    if (n + bitindex < 8) {\r\n      current = (current << n) | number;\r\n      bitindex += n;\r\n    // Byte 境界を超えるとき\r\n    } else {\r\n      for (i = 0; i < n; ++i) {\r\n        current = (current << 1) | ((number >> n - i - 1) & 1);\r\n\r\n        // next byte\r\n        if (++bitindex === 8) {\r\n          bitindex = 0;\r\n          buffer[index++] = BitStream.ReverseTable[current];\r\n          current = 0;\r\n\r\n          // expand\r\n          if (index === buffer.length) {\r\n            buffer = this.expandBuffer();\r\n          }\r\n        }\r\n      }\r\n    }\r\n    buffer[index] = current;\r\n\r\n    this.buffer = buffer;\r\n    this.bitindex = bitindex;\r\n    this.index = index;\r\n  };\r\n\r\n\r\n  /**\r\n   * ストリームの終端処理を行う\r\n   * @return {!(Array|Uint8Array)} 終端処理後のバッファを byte array で返す.\r\n   */\r\n  BitStream.prototype.finish = function() {\r\n    var buffer = this.buffer;\r\n    var index = this.index;\r\n\r\n    /** @type {!(Array|Uint8Array)} output buffer. */\r\n    var output;\r\n\r\n    // bitindex が 0 の時は余分に index が進んでいる状態\r\n    if (this.bitindex > 0) {\r\n      buffer[index] <<= 8 - this.bitindex;\r\n      buffer[index] = BitStream.ReverseTable[buffer[index]];\r\n      index++;\r\n    }\r\n\r\n    // array truncation\r\n    if (USE_TYPEDARRAY) {\r\n      output = buffer.subarray(0, index);\r\n    } else {\r\n      buffer.length = index;\r\n      output = buffer;\r\n    }\r\n\r\n    return output;\r\n  };\r\n\r\n  /**\r\n   * 0-255 のビット順を反転したテーブル\r\n   * @const\r\n   * @type {!(Uint8Array|Array.<number>)}\r\n   */\r\n  BitStream.ReverseTable = (function(table) {\r\n    return table;\r\n  })((function() {\r\n    /** @type {!(Array|Uint8Array)} reverse table. */\r\n    var table = new (USE_TYPEDARRAY ? Uint8Array : Array)(256);\r\n    /** @type {number} loop counter. */\r\n    var i;\r\n\r\n    // generate\r\n    for (i = 0; i < 256; ++i) {\r\n      table[i] = (function(n) {\r\n        var r = n;\r\n        var s = 7;\r\n\r\n        for (n >>>= 1; n; n >>>= 1) {\r\n          r <<= 1;\r\n          r |= n & 1;\r\n          --s;\r\n        }\r\n\r\n        return (r << s & 0xff) >>> 0;\r\n      })(i);\r\n    }\r\n\r\n    return table;\r\n  })());\r\n\r\n  return Zlib.BitStream = BitStream;\r\n});\r\n\r\n\r\n\ndefine('skylark-zlib/crc32',[\r\n  \"./zlib\"\r\n],function(Zlib) {\r\n  /**\r\n   * @fileoverview CRC32 実装.\r\n   */\r\n\r\n\r\n  const USE_TYPEDARRAY = true;\r\n\r\n\r\n  /** @define {boolean} */\r\n  var ZLIB_CRC32_COMPACT = false;\r\n\r\n\r\n  var CRC32 = {};\r\n\r\n\r\n  /**\r\n   * CRC32 ハッシュ値を取得\r\n   * @param {!(Array.<number>|Uint8Array)} data data byte array.\r\n   * @param {number=} pos data position.\r\n   * @param {number=} length data length.\r\n   * @return {number} CRC32.\r\n   */\r\n  CRC32.calc = function(data, pos, length) {\r\n    return CRC32.update(data, 0, pos, length);\r\n  };\r\n\r\n  /**\r\n   * CRC32ハッシュ値を更新\r\n   * @param {!(Array.<number>|Uint8Array)} data data byte array.\r\n   * @param {number} crc CRC32.\r\n   * @param {number=} pos data position.\r\n   * @param {number=} length data length.\r\n   * @return {number} CRC32.\r\n   */\r\n  CRC32.update = function(data, crc, pos, length) {\r\n    var table = CRC32.Table;\r\n    var i = (typeof pos === 'number') ? pos : (pos = 0);\r\n    var il = (typeof length === 'number') ? length : data.length;\r\n\r\n    crc ^= 0xffffffff;\r\n\r\n    // loop unrolling for performance\r\n    for (i = il & 7; i--; ++pos) {\r\n      crc = (crc >>> 8) ^ table[(crc ^ data[pos]) & 0xff];\r\n    }\r\n    for (i = il >> 3; i--; pos += 8) {\r\n      crc = (crc >>> 8) ^ table[(crc ^ data[pos    ]) & 0xff];\r\n      crc = (crc >>> 8) ^ table[(crc ^ data[pos + 1]) & 0xff];\r\n      crc = (crc >>> 8) ^ table[(crc ^ data[pos + 2]) & 0xff];\r\n      crc = (crc >>> 8) ^ table[(crc ^ data[pos + 3]) & 0xff];\r\n      crc = (crc >>> 8) ^ table[(crc ^ data[pos + 4]) & 0xff];\r\n      crc = (crc >>> 8) ^ table[(crc ^ data[pos + 5]) & 0xff];\r\n      crc = (crc >>> 8) ^ table[(crc ^ data[pos + 6]) & 0xff];\r\n      crc = (crc >>> 8) ^ table[(crc ^ data[pos + 7]) & 0xff];\r\n    }\r\n\r\n    return (crc ^ 0xffffffff) >>> 0;\r\n  };\r\n\r\n  /**\r\n   * @param {number} num\r\n   * @param {number} crc\r\n   * @returns {number}\r\n   */\r\n  CRC32.single = function(num, crc) {\r\n    return (CRC32.Table[(num ^ crc) & 0xff] ^ (num >>> 8)) >>> 0;\r\n  };\r\n\r\n  /**\r\n   * @type {Array.<number>}\r\n   * @const\r\n   * @private\r\n   */\r\n  CRC32.Table_ = [\r\n    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,\r\n    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,\r\n    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,\r\n    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\r\n    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,\r\n    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,\r\n    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,\r\n    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\r\n    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,\r\n    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,\r\n    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,\r\n    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\r\n    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,\r\n    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,\r\n    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,\r\n    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\r\n    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,\r\n    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,\r\n    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,\r\n    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\r\n    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,\r\n    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,\r\n    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,\r\n    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\r\n    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,\r\n    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,\r\n    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,\r\n    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\r\n    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,\r\n    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,\r\n    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,\r\n    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\r\n    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,\r\n    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,\r\n    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,\r\n    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\r\n    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,\r\n    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,\r\n    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,\r\n    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\r\n    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,\r\n    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,\r\n    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d\r\n  ];\r\n\r\n  /**\r\n   * @type {!(Array.<number>|Uint32Array)} CRC-32 Table.\r\n   * @const\r\n   */\r\n  CRC32.Table = ZLIB_CRC32_COMPACT ? (function() {\r\n    /** @type {!(Array.<number>|Uint32Array)} */\r\n    var table = new (USE_TYPEDARRAY ? Uint32Array : Array)(256);\r\n    /** @type {number} */\r\n    var c;\r\n    /** @type {number} */\r\n    var i;\r\n    /** @type {number} */\r\n    var j;\r\n\r\n    for (i = 0; i < 256; ++i) {\r\n      c = i;\r\n      for (j = 0; j < 8; ++j) {\r\n        c = (c & 1) ? (0xedB88320 ^ (c >>> 1)) : (c >>> 1);\r\n      }\r\n      table[i] = c >>> 0;\r\n    }\r\n\r\n    return table;\r\n  })() : USE_TYPEDARRAY ? new Uint32Array(CRC32.Table_) : CRC32.Table_;\r\n\r\n\r\n  return Zlib.CRC32 = CRC32;\r\n});\r\n\r\n\r\n\ndefine('skylark-zlib/Heap',[\r\n  \"./zlib\"\r\n],function(Zlib) {\r\n  /**\r\n   * @fileoverview Heap Sort 実装. ハフマン符号化で使用する.\r\n   */\r\n  const USE_TYPEDARRAY = true;\r\n\r\n  /*\r\n   * カスタムハフマン符号で使用するヒープ実装\r\n   * @param {number} length ヒープサイズ.\r\n   * @constructor\r\n   */\r\n  var Heap = function(length) {\r\n    this.buffer = new (USE_TYPEDARRAY ? Uint16Array : Array)(length * 2);\r\n    this.length = 0;\r\n  };\r\n\r\n  /**\r\n   * 親ノードの index 取得\r\n   * @param {number} index 子ノードの index.\r\n   * @return {number} 親ノードの index.\r\n   *\r\n   */\r\n  Heap.prototype.getParent = function(index) {\r\n    return ((index - 2) / 4 | 0) * 2;\r\n  };\r\n\r\n  /**\r\n   * 子ノードの index 取得\r\n   * @param {number} index 親ノードの index.\r\n   * @return {number} 子ノードの index.\r\n   */\r\n  Heap.prototype.getChild = function(index) {\r\n    return 2 * index + 2;\r\n  };\r\n\r\n  /**\r\n   * Heap に値を追加する\r\n   * @param {number} index キー index.\r\n   * @param {number} value 値.\r\n   * @return {number} 現在のヒープ長.\r\n   */\r\n  Heap.prototype.push = function(index, value) {\r\n    var current, parent,\r\n        heap = this.buffer,\r\n        swap;\r\n\r\n    current = this.length;\r\n    heap[this.length++] = value;\r\n    heap[this.length++] = index;\r\n\r\n    // ルートノードにたどり着くまで入れ替えを試みる\r\n    while (current > 0) {\r\n      parent = this.getParent(current);\r\n\r\n      // 親ノードと比較して親の方が小さければ入れ替える\r\n      if (heap[current] > heap[parent]) {\r\n        swap = heap[current];\r\n        heap[current] = heap[parent];\r\n        heap[parent] = swap;\r\n\r\n        swap = heap[current + 1];\r\n        heap[current + 1] = heap[parent + 1];\r\n        heap[parent + 1] = swap;\r\n\r\n        current = parent;\r\n      // 入れ替えが必要なくなったらそこで抜ける\r\n      } else {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return this.length;\r\n  };\r\n\r\n  /**\r\n   * Heapから一番大きい値を返す\r\n   * @return {{index: number, value: number, length: number}} {index: キーindex,\r\n   *     value: 値, length: ヒープ長} の Object.\r\n   */\r\n  Heap.prototype.pop = function() {\r\n    var index, value,\r\n        heap = this.buffer, swap,\r\n        current, parent;\r\n\r\n    value = heap[0];\r\n    index = heap[1];\r\n\r\n    // 後ろから値を取る\r\n    this.length -= 2;\r\n    heap[0] = heap[this.length];\r\n    heap[1] = heap[this.length + 1];\r\n\r\n    parent = 0;\r\n    // ルートノードから下がっていく\r\n    while (true) {\r\n      current = this.getChild(parent);\r\n\r\n      // 範囲チェック\r\n      if (current >= this.length) {\r\n        break;\r\n      }\r\n\r\n      // 隣のノードと比較して、隣の方が値が大きければ隣を現在ノードとして選択\r\n      if (current + 2 < this.length && heap[current + 2] > heap[current]) {\r\n        current += 2;\r\n      }\r\n\r\n      // 親ノードと比較して親の方が小さい場合は入れ替える\r\n      if (heap[current] > heap[parent]) {\r\n        swap = heap[parent];\r\n        heap[parent] = heap[current];\r\n        heap[current] = swap;\r\n\r\n        swap = heap[parent + 1];\r\n        heap[parent + 1] = heap[current + 1];\r\n        heap[current + 1] = swap;\r\n      } else {\r\n        break;\r\n      }\r\n\r\n      parent = current;\r\n    }\r\n\r\n    return {index: index, value: value, length: this.length};\r\n  };\r\n\r\n\r\n  return Zlib.Heap = Heap;\r\n});\r\n\r\n\ndefine('skylark-zlib/RawDeflate',[\r\n  \"./zlib\",\r\n  \"./Heap\",\r\n  \"./BitStream\"\r\n],function(Zlib,Heap,BitStream) {\r\n  /**\r\n   * @fileoverview Deflate (RFC1951) 符号化アルゴリズム実装.\r\n   */\r\n  const USE_TYPEDARRAY = true;\r\n\r\n  /**\r\n   * Raw Deflate 実装\r\n   *\r\n   * @constructor\r\n   * @param {!(Array.<number>|Uint8Array)} input 符号化する対象のバッファ.\r\n   * @param {Object=} opt_params option parameters.\r\n   *\r\n   * typed array が使用可能なとき、outputBuffer が Array は自動的に Uint8Array に\r\n   * 変換されます.\r\n   * 別のオブジェクトになるため出力バッファを参照している変数などは\r\n   * 更新する必要があります.\r\n   */\r\n  var RawDeflate = function(input, opt_params) {\r\n    /** @type {RawDeflate.CompressionType} */\r\n    this.compressionType = RawDeflate.CompressionType.DYNAMIC;\r\n    /** @type {number} */\r\n    this.lazy = 0;\r\n    /** @type {!(Array.<number>|Uint32Array)} */\r\n    this.freqsLitLen;\r\n    /** @type {!(Array.<number>|Uint32Array)} */\r\n    this.freqsDist;\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    this.input =\r\n      (USE_TYPEDARRAY && input instanceof Array) ? new Uint8Array(input) : input;\r\n    /** @type {!(Array.<number>|Uint8Array)} output output buffer. */\r\n    this.output;\r\n    /** @type {number} pos output buffer position. */\r\n    this.op = 0;\r\n\r\n    // option parameters\r\n    if (opt_params) {\r\n      if (opt_params['lazy']) {\r\n        this.lazy = opt_params['lazy'];\r\n      }\r\n      if (typeof opt_params['compressionType'] === 'number') {\r\n        this.compressionType = opt_params['compressionType'];\r\n      }\r\n      if (opt_params['outputBuffer']) {\r\n        this.output =\r\n          (USE_TYPEDARRAY && opt_params['outputBuffer'] instanceof Array) ?\r\n          new Uint8Array(opt_params['outputBuffer']) : opt_params['outputBuffer'];\r\n      }\r\n      if (typeof opt_params['outputIndex'] === 'number') {\r\n        this.op = opt_params['outputIndex'];\r\n      }\r\n    }\r\n\r\n    if (!this.output) {\r\n      this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(0x8000);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @enum {number}\r\n   */\r\n  RawDeflate.CompressionType = {\r\n    NONE: 0,\r\n    FIXED: 1,\r\n    DYNAMIC: 2,\r\n    RESERVED: 3\r\n  };\r\n\r\n\r\n  /**\r\n   * LZ77 の最小マッチ長\r\n   * @const\r\n   * @type {number}\r\n   */\r\n  RawDeflate.Lz77MinLength = 3;\r\n\r\n  /**\r\n   * LZ77 の最大マッチ長\r\n   * @const\r\n   * @type {number}\r\n   */\r\n  RawDeflate.Lz77MaxLength = 258;\r\n\r\n  /**\r\n   * LZ77 のウィンドウサイズ\r\n   * @const\r\n   * @type {number}\r\n   */\r\n  RawDeflate.WindowSize = 0x8000;\r\n\r\n  /**\r\n   * 最長の符号長\r\n   * @const\r\n   * @type {number}\r\n   */\r\n  RawDeflate.MaxCodeLength = 16;\r\n\r\n  /**\r\n   * ハフマン符号の最大数値\r\n   * @const\r\n   * @type {number}\r\n   */\r\n  RawDeflate.HUFMAX = 286;\r\n\r\n  /**\r\n   * 固定ハフマン符号の符号化テーブル\r\n   * @const\r\n   * @type {Array.<Array.<number, number>>}\r\n   */\r\n  RawDeflate.FixedHuffmanTable = (function() {\r\n    var table = [], i;\r\n\r\n    for (i = 0; i < 288; i++) {\r\n      switch (true) {\r\n        case (i <= 143): table.push([i       + 0x030, 8]); break;\r\n        case (i <= 255): table.push([i - 144 + 0x190, 9]); break;\r\n        case (i <= 279): table.push([i - 256 + 0x000, 7]); break;\r\n        case (i <= 287): table.push([i - 280 + 0x0C0, 8]); break;\r\n        default:\r\n          throw 'invalid literal: ' + i;\r\n      }\r\n    }\r\n\r\n    return table;\r\n  })();\r\n\r\n  /**\r\n   * DEFLATE ブロックの作成\r\n   * @return {!(Array.<number>|Uint8Array)} 圧縮済み byte array.\r\n   */\r\n  RawDeflate.prototype.compress = function() {\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var blockArray;\r\n    /** @type {number} */\r\n    var position;\r\n    /** @type {number} */\r\n    var length;\r\n\r\n    var input = this.input;\r\n\r\n    // compression\r\n    switch (this.compressionType) {\r\n      case RawDeflate.CompressionType.NONE:\r\n        // each 65535-Byte (length header: 16-bit)\r\n        for (position = 0, length = input.length; position < length;) {\r\n          blockArray = USE_TYPEDARRAY ?\r\n            input.subarray(position, position + 0xffff) :\r\n            input.slice(position, position + 0xffff);\r\n          position += blockArray.length;\r\n          this.makeNocompressBlock(blockArray, (position === length));\r\n        }\r\n        break;\r\n      case RawDeflate.CompressionType.FIXED:\r\n        this.output = this.makeFixedHuffmanBlock(input, true);\r\n        this.op = this.output.length;\r\n        break;\r\n      case RawDeflate.CompressionType.DYNAMIC:\r\n        this.output = this.makeDynamicHuffmanBlock(input, true);\r\n        this.op = this.output.length;\r\n        break;\r\n      default:\r\n        throw 'invalid compression type';\r\n    }\r\n\r\n    return this.output;\r\n  };\r\n\r\n  /**\r\n   * 非圧縮ブロックの作成\r\n   * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.\r\n   * @param {!boolean} isFinalBlock 最後のブロックならばtrue.\r\n   * @return {!(Array.<number>|Uint8Array)} 非圧縮ブロック byte array.\r\n   */\r\n  RawDeflate.prototype.makeNocompressBlock =\r\n  function(blockArray, isFinalBlock) {\r\n    /** @type {number} */\r\n    var bfinal;\r\n    /** @type {RawDeflate.CompressionType} */\r\n    var btype;\r\n    /** @type {number} */\r\n    var len;\r\n    /** @type {number} */\r\n    var nlen;\r\n    /** @type {number} */\r\n    var i;\r\n    /** @type {number} */\r\n    var il;\r\n\r\n    var output = this.output;\r\n    var op = this.op;\r\n\r\n    // expand buffer\r\n    if (USE_TYPEDARRAY) {\r\n      output = new Uint8Array(this.output.buffer);\r\n      while (output.length <= op + blockArray.length + 5) {\r\n        output = new Uint8Array(output.length << 1);\r\n      }\r\n      output.set(this.output);\r\n    }\r\n\r\n    // header\r\n    bfinal = isFinalBlock ? 1 : 0;\r\n    btype = RawDeflate.CompressionType.NONE;\r\n    output[op++] = (bfinal) | (btype << 1);\r\n\r\n    // length\r\n    len = blockArray.length;\r\n    nlen = (~len + 0x10000) & 0xffff;\r\n    output[op++] =          len & 0xff;\r\n    output[op++] =  (len >>> 8) & 0xff;\r\n    output[op++] =         nlen & 0xff;\r\n    output[op++] = (nlen >>> 8) & 0xff;\r\n\r\n    // copy buffer\r\n    if (USE_TYPEDARRAY) {\r\n       output.set(blockArray, op);\r\n       op += blockArray.length;\r\n       output = output.subarray(0, op);\r\n    } else {\r\n      for (i = 0, il = blockArray.length; i < il; ++i) {\r\n        output[op++] = blockArray[i];\r\n      }\r\n      output.length = op;\r\n    }\r\n\r\n    this.op = op;\r\n    this.output = output;\r\n\r\n    return output;\r\n  };\r\n\r\n  /**\r\n   * 固定ハフマンブロックの作成\r\n   * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.\r\n   * @param {!boolean} isFinalBlock 最後のブロックならばtrue.\r\n   * @return {!(Array.<number>|Uint8Array)} 固定ハフマン符号化ブロック byte array.\r\n   */\r\n  RawDeflate.prototype.makeFixedHuffmanBlock =\r\n  function(blockArray, isFinalBlock) {\r\n    /** @type {BitStream} */\r\n    var stream = new BitStream(USE_TYPEDARRAY ?\r\n      new Uint8Array(this.output.buffer) : this.output, this.op);\r\n    /** @type {number} */\r\n    var bfinal;\r\n    /** @type {RawDeflate.CompressionType} */\r\n    var btype;\r\n    /** @type {!(Array.<number>|Uint16Array)} */\r\n    var data;\r\n\r\n    // header\r\n    bfinal = isFinalBlock ? 1 : 0;\r\n    btype = RawDeflate.CompressionType.FIXED;\r\n\r\n    stream.writeBits(bfinal, 1, true);\r\n    stream.writeBits(btype, 2, true);\r\n\r\n    data = this.lz77(blockArray);\r\n    this.fixedHuffman(data, stream);\r\n\r\n    return stream.finish();\r\n  };\r\n\r\n  /**\r\n   * 動的ハフマンブロックの作成\r\n   * @param {!(Array.<number>|Uint8Array)} blockArray ブロックデータ byte array.\r\n   * @param {!boolean} isFinalBlock 最後のブロックならばtrue.\r\n   * @return {!(Array.<number>|Uint8Array)} 動的ハフマン符号ブロック byte array.\r\n   */\r\n  RawDeflate.prototype.makeDynamicHuffmanBlock =\r\n  function(blockArray, isFinalBlock) {\r\n    /** @type {BitStream} */\r\n    var stream = new BitStream(USE_TYPEDARRAY ?\r\n      new Uint8Array(this.output.buffer) : this.output, this.op);\r\n    /** @type {number} */\r\n    var bfinal;\r\n    /** @type {RawDeflate.CompressionType} */\r\n    var btype;\r\n    /** @type {!(Array.<number>|Uint16Array)} */\r\n    var data;\r\n    /** @type {number} */\r\n    var hlit;\r\n    /** @type {number} */\r\n    var hdist;\r\n    /** @type {number} */\r\n    var hclen;\r\n    /** @const @type {Array.<number>} */\r\n    var hclenOrder =\r\n          [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var litLenLengths;\r\n    /** @type {!(Array.<number>|Uint16Array)} */\r\n    var litLenCodes;\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var distLengths;\r\n    /** @type {!(Array.<number>|Uint16Array)} */\r\n    var distCodes;\r\n    /** @type {{\r\n     *   codes: !(Array.<number>|Uint32Array),\r\n     *   freqs: !(Array.<number>|Uint8Array)\r\n     * }} */\r\n    var treeSymbols;\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var treeLengths;\r\n    /** @type {Array} */\r\n    var transLengths = new Array(19);\r\n    /** @type {!(Array.<number>|Uint16Array)} */\r\n    var treeCodes;\r\n    /** @type {number} */\r\n    var code;\r\n    /** @type {number} */\r\n    var bitlen;\r\n    /** @type {number} */\r\n    var i;\r\n    /** @type {number} */\r\n    var il;\r\n\r\n    // header\r\n    bfinal = isFinalBlock ? 1 : 0;\r\n    btype = RawDeflate.CompressionType.DYNAMIC;\r\n\r\n    stream.writeBits(bfinal, 1, true);\r\n    stream.writeBits(btype, 2, true);\r\n\r\n    data = this.lz77(blockArray);\r\n\r\n    // リテラル・長さ, 距離のハフマン符号と符号長の算出\r\n    litLenLengths = this.getLengths_(this.freqsLitLen, 15);\r\n    litLenCodes = this.getCodesFromLengths_(litLenLengths);\r\n    distLengths = this.getLengths_(this.freqsDist, 7);\r\n    distCodes = this.getCodesFromLengths_(distLengths);\r\n\r\n    // HLIT, HDIST の決定\r\n    for (hlit = 286; hlit > 257 && litLenLengths[hlit - 1] === 0; hlit--) {}\r\n    for (hdist = 30; hdist > 1 && distLengths[hdist - 1] === 0; hdist--) {}\r\n\r\n    // HCLEN\r\n    treeSymbols =\r\n      this.getTreeSymbols_(hlit, litLenLengths, hdist, distLengths);\r\n    treeLengths = this.getLengths_(treeSymbols.freqs, 7);\r\n    for (i = 0; i < 19; i++) {\r\n      transLengths[i] = treeLengths[hclenOrder[i]];\r\n    }\r\n    for (hclen = 19; hclen > 4 && transLengths[hclen - 1] === 0; hclen--) {}\r\n\r\n    treeCodes = this.getCodesFromLengths_(treeLengths);\r\n\r\n    // 出力\r\n    stream.writeBits(hlit - 257, 5, true);\r\n    stream.writeBits(hdist - 1, 5, true);\r\n    stream.writeBits(hclen - 4, 4, true);\r\n    for (i = 0; i < hclen; i++) {\r\n      stream.writeBits(transLengths[i], 3, true);\r\n    }\r\n\r\n    // ツリーの出力\r\n    for (i = 0, il = treeSymbols.codes.length; i < il; i++) {\r\n      code = treeSymbols.codes[i];\r\n\r\n      stream.writeBits(treeCodes[code], treeLengths[code], true);\r\n\r\n      // extra bits\r\n      if (code >= 16) {\r\n        i++;\r\n        switch (code) {\r\n          case 16: bitlen = 2; break;\r\n          case 17: bitlen = 3; break;\r\n          case 18: bitlen = 7; break;\r\n          default:\r\n            throw 'invalid code: ' + code;\r\n        }\r\n\r\n        stream.writeBits(treeSymbols.codes[i], bitlen, true);\r\n      }\r\n    }\r\n\r\n    this.dynamicHuffman(\r\n      data,\r\n      [litLenCodes, litLenLengths],\r\n      [distCodes, distLengths],\r\n      stream\r\n    );\r\n\r\n    return stream.finish();\r\n  };\r\n\r\n\r\n  /**\r\n   * 動的ハフマン符号化(カスタムハフマンテーブル)\r\n   * @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.\r\n   * @param {!BitStream} stream 書き込み用ビットストリーム.\r\n   * @return {!BitStream} ハフマン符号化済みビットストリームオブジェクト.\r\n   */\r\n  RawDeflate.prototype.dynamicHuffman =\r\n  function(dataArray, litLen, dist, stream) {\r\n    /** @type {number} */\r\n    var index;\r\n    /** @type {number} */\r\n    var length;\r\n    /** @type {number} */\r\n    var literal;\r\n    /** @type {number} */\r\n    var code;\r\n    /** @type {number} */\r\n    var litLenCodes;\r\n    /** @type {number} */\r\n    var litLenLengths;\r\n    /** @type {number} */\r\n    var distCodes;\r\n    /** @type {number} */\r\n    var distLengths;\r\n\r\n    litLenCodes = litLen[0];\r\n    litLenLengths = litLen[1];\r\n    distCodes = dist[0];\r\n    distLengths = dist[1];\r\n\r\n    // 符号を BitStream に書き込んでいく\r\n    for (index = 0, length = dataArray.length; index < length; ++index) {\r\n      literal = dataArray[index];\r\n\r\n      // literal or length\r\n      stream.writeBits(litLenCodes[literal], litLenLengths[literal], true);\r\n\r\n      // 長さ・距離符号\r\n      if (literal > 256) {\r\n        // length extra\r\n        stream.writeBits(dataArray[++index], dataArray[++index], true);\r\n        // distance\r\n        code = dataArray[++index];\r\n        stream.writeBits(distCodes[code], distLengths[code], true);\r\n        // distance extra\r\n        stream.writeBits(dataArray[++index], dataArray[++index], true);\r\n      // 終端\r\n      } else if (literal === 256) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return stream;\r\n  };\r\n\r\n  /**\r\n   * 固定ハフマン符号化\r\n   * @param {!(Array.<number>|Uint16Array)} dataArray LZ77 符号化済み byte array.\r\n   * @param {!BitStream} stream 書き込み用ビットストリーム.\r\n   * @return {!BitStream} ハフマン符号化済みビットストリームオブジェクト.\r\n   */\r\n  RawDeflate.prototype.fixedHuffman = function(dataArray, stream) {\r\n    /** @type {number} */\r\n    var index;\r\n    /** @type {number} */\r\n    var length;\r\n    /** @type {number} */\r\n    var literal;\r\n\r\n    // 符号を BitStream に書き込んでいく\r\n    for (index = 0, length = dataArray.length; index < length; index++) {\r\n      literal = dataArray[index];\r\n\r\n      // 符号の書き込み\r\n      BitStream.prototype.writeBits.apply(\r\n        stream,\r\n        RawDeflate.FixedHuffmanTable[literal]\r\n      );\r\n\r\n      // 長さ・距離符号\r\n      if (literal > 0x100) {\r\n        // length extra\r\n        stream.writeBits(dataArray[++index], dataArray[++index], true);\r\n        // distance\r\n        stream.writeBits(dataArray[++index], 5);\r\n        // distance extra\r\n        stream.writeBits(dataArray[++index], dataArray[++index], true);\r\n      // 終端\r\n      } else if (literal === 0x100) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return stream;\r\n  };\r\n\r\n  /**\r\n   * マッチ情報\r\n   * @param {!number} length マッチした長さ.\r\n   * @param {!number} backwardDistance マッチ位置との距離.\r\n   * @constructor\r\n   */\r\n  RawDeflate.Lz77Match = function(length, backwardDistance) {\r\n    /** @type {number} match length. */\r\n    this.length = length;\r\n    /** @type {number} backward distance. */\r\n    this.backwardDistance = backwardDistance;\r\n  };\r\n\r\n  /**\r\n   * 長さ符号テーブル.\r\n   * [コード, 拡張ビット, 拡張ビット長] の配列となっている.\r\n   * @const\r\n   * @type {!(Array.<number>|Uint32Array)}\r\n   */\r\n  RawDeflate.Lz77Match.LengthCodeTable = (function(table) {\r\n    return USE_TYPEDARRAY ? new Uint32Array(table) : table;\r\n  })((function() {\r\n    /** @type {!Array} */\r\n    var table = [];\r\n    /** @type {number} */\r\n    var i;\r\n    /** @type {!Array.<number>} */\r\n    var c;\r\n\r\n    for (i = 3; i <= 258; i++) {\r\n      c = code(i);\r\n      table[i] = (c[2] << 24) | (c[1] << 16) | c[0];\r\n    }\r\n\r\n    /**\r\n     * @param {number} length lz77 length.\r\n     * @return {!Array.<number>} lz77 codes.\r\n     */\r\n    function code(length) {\r\n      switch (true) {\r\n        case (length === 3): return [257, length - 3, 0]; break;\r\n        case (length === 4): return [258, length - 4, 0]; break;\r\n        case (length === 5): return [259, length - 5, 0]; break;\r\n        case (length === 6): return [260, length - 6, 0]; break;\r\n        case (length === 7): return [261, length - 7, 0]; break;\r\n        case (length === 8): return [262, length - 8, 0]; break;\r\n        case (length === 9): return [263, length - 9, 0]; break;\r\n        case (length === 10): return [264, length - 10, 0]; break;\r\n        case (length <= 12): return [265, length - 11, 1]; break;\r\n        case (length <= 14): return [266, length - 13, 1]; break;\r\n        case (length <= 16): return [267, length - 15, 1]; break;\r\n        case (length <= 18): return [268, length - 17, 1]; break;\r\n        case (length <= 22): return [269, length - 19, 2]; break;\r\n        case (length <= 26): return [270, length - 23, 2]; break;\r\n        case (length <= 30): return [271, length - 27, 2]; break;\r\n        case (length <= 34): return [272, length - 31, 2]; break;\r\n        case (length <= 42): return [273, length - 35, 3]; break;\r\n        case (length <= 50): return [274, length - 43, 3]; break;\r\n        case (length <= 58): return [275, length - 51, 3]; break;\r\n        case (length <= 66): return [276, length - 59, 3]; break;\r\n        case (length <= 82): return [277, length - 67, 4]; break;\r\n        case (length <= 98): return [278, length - 83, 4]; break;\r\n        case (length <= 114): return [279, length - 99, 4]; break;\r\n        case (length <= 130): return [280, length - 115, 4]; break;\r\n        case (length <= 162): return [281, length - 131, 5]; break;\r\n        case (length <= 194): return [282, length - 163, 5]; break;\r\n        case (length <= 226): return [283, length - 195, 5]; break;\r\n        case (length <= 257): return [284, length - 227, 5]; break;\r\n        case (length === 258): return [285, length - 258, 0]; break;\r\n        default: throw 'invalid length: ' + length;\r\n      }\r\n    }\r\n\r\n    return table;\r\n  })());\r\n\r\n  /**\r\n   * 距離符号テーブル\r\n   * @param {!number} dist 距離.\r\n   * @return {!Array.<number>} コード、拡張ビット、拡張ビット長の配列.\r\n   * @private\r\n   */\r\n  RawDeflate.Lz77Match.prototype.getDistanceCode_ = function(dist) {\r\n    /** @type {!Array.<number>} distance code table. */\r\n    var r;\r\n\r\n    switch (true) {\r\n      case (dist === 1): r = [0, dist - 1, 0]; break;\r\n      case (dist === 2): r = [1, dist - 2, 0]; break;\r\n      case (dist === 3): r = [2, dist - 3, 0]; break;\r\n      case (dist === 4): r = [3, dist - 4, 0]; break;\r\n      case (dist <= 6): r = [4, dist - 5, 1]; break;\r\n      case (dist <= 8): r = [5, dist - 7, 1]; break;\r\n      case (dist <= 12): r = [6, dist - 9, 2]; break;\r\n      case (dist <= 16): r = [7, dist - 13, 2]; break;\r\n      case (dist <= 24): r = [8, dist - 17, 3]; break;\r\n      case (dist <= 32): r = [9, dist - 25, 3]; break;\r\n      case (dist <= 48): r = [10, dist - 33, 4]; break;\r\n      case (dist <= 64): r = [11, dist - 49, 4]; break;\r\n      case (dist <= 96): r = [12, dist - 65, 5]; break;\r\n      case (dist <= 128): r = [13, dist - 97, 5]; break;\r\n      case (dist <= 192): r = [14, dist - 129, 6]; break;\r\n      case (dist <= 256): r = [15, dist - 193, 6]; break;\r\n      case (dist <= 384): r = [16, dist - 257, 7]; break;\r\n      case (dist <= 512): r = [17, dist - 385, 7]; break;\r\n      case (dist <= 768): r = [18, dist - 513, 8]; break;\r\n      case (dist <= 1024): r = [19, dist - 769, 8]; break;\r\n      case (dist <= 1536): r = [20, dist - 1025, 9]; break;\r\n      case (dist <= 2048): r = [21, dist - 1537, 9]; break;\r\n      case (dist <= 3072): r = [22, dist - 2049, 10]; break;\r\n      case (dist <= 4096): r = [23, dist - 3073, 10]; break;\r\n      case (dist <= 6144): r = [24, dist - 4097, 11]; break;\r\n      case (dist <= 8192): r = [25, dist - 6145, 11]; break;\r\n      case (dist <= 12288): r = [26, dist - 8193, 12]; break;\r\n      case (dist <= 16384): r = [27, dist - 12289, 12]; break;\r\n      case (dist <= 24576): r = [28, dist - 16385, 13]; break;\r\n      case (dist <= 32768): r = [29, dist - 24577, 13]; break;\r\n      default: throw 'invalid distance';\r\n    }\r\n\r\n    return r;\r\n  };\r\n\r\n  /**\r\n   * マッチ情報を LZ77 符号化配列で返す.\r\n   * なお、ここでは以下の内部仕様で符号化している\r\n   * [ CODE, EXTRA-BIT-LEN, EXTRA, CODE, EXTRA-BIT-LEN, EXTRA ]\r\n   * @return {!Array.<number>} LZ77 符号化 byte array.\r\n   */\r\n  RawDeflate.Lz77Match.prototype.toLz77Array = function() {\r\n    /** @type {number} */\r\n    var length = this.length;\r\n    /** @type {number} */\r\n    var dist = this.backwardDistance;\r\n    /** @type {Array} */\r\n    var codeArray = [];\r\n    /** @type {number} */\r\n    var pos = 0;\r\n    /** @type {!Array.<number>} */\r\n    var code;\r\n\r\n    // length\r\n    code = RawDeflate.Lz77Match.LengthCodeTable[length];\r\n    codeArray[pos++] = code & 0xffff;\r\n    codeArray[pos++] = (code >> 16) & 0xff;\r\n    codeArray[pos++] = code >> 24;\r\n\r\n    // distance\r\n    code = this.getDistanceCode_(dist);\r\n    codeArray[pos++] = code[0];\r\n    codeArray[pos++] = code[1];\r\n    codeArray[pos++] = code[2];\r\n\r\n    return codeArray;\r\n  };\r\n\r\n  /**\r\n   * LZ77 実装\r\n   * @param {!(Array.<number>|Uint8Array)} dataArray LZ77 符号化するバイト配列.\r\n   * @return {!(Array.<number>|Uint16Array)} LZ77 符号化した配列.\r\n   */\r\n  RawDeflate.prototype.lz77 = function(dataArray) {\r\n    /** @type {number} input position */\r\n    var position;\r\n    /** @type {number} input length */\r\n    var length;\r\n    /** @type {number} loop counter */\r\n    var i;\r\n    /** @type {number} loop limiter */\r\n    var il;\r\n    /** @type {number} chained-hash-table key */\r\n    var matchKey;\r\n    /** @type {Object.<number, Array.<number>>} chained-hash-table */\r\n    var table = {};\r\n    /** @const @type {number} */\r\n    var windowSize = RawDeflate.WindowSize;\r\n    /** @type {Array.<number>} match list */\r\n    var matchList;\r\n    /** @type {RawDeflate.Lz77Match} longest match */\r\n    var longestMatch;\r\n    /** @type {RawDeflate.Lz77Match} previous longest match */\r\n    var prevMatch;\r\n    /** @type {!(Array.<number>|Uint16Array)} lz77 buffer */\r\n    var lz77buf = USE_TYPEDARRAY ?\r\n      new Uint16Array(dataArray.length * 2) : [];\r\n    /** @type {number} lz77 output buffer pointer */\r\n    var pos = 0;\r\n    /** @type {number} lz77 skip length */\r\n    var skipLength = 0;\r\n    /** @type {!(Array.<number>|Uint32Array)} */\r\n    var freqsLitLen = new (USE_TYPEDARRAY ? Uint32Array : Array)(286);\r\n    /** @type {!(Array.<number>|Uint32Array)} */\r\n    var freqsDist = new (USE_TYPEDARRAY ? Uint32Array : Array)(30);\r\n    /** @type {number} */\r\n    var lazy = this.lazy;\r\n    /** @type {*} temporary variable */\r\n    var tmp;\r\n\r\n    // 初期化\r\n    if (!USE_TYPEDARRAY) {\r\n      for (i = 0; i <= 285;) { freqsLitLen[i++] = 0; }\r\n      for (i = 0; i <= 29;) { freqsDist[i++] = 0; }\r\n    }\r\n    freqsLitLen[256] = 1; // EOB の最低出現回数は 1\r\n\r\n    /**\r\n     * マッチデータの書き込み\r\n     * @param {RawDeflate.Lz77Match} match LZ77 Match data.\r\n     * @param {!number} offset スキップ開始位置(相対指定).\r\n     * @private\r\n     */\r\n    function writeMatch(match, offset) {\r\n      /** @type {Array.<number>} */\r\n      var lz77Array = match.toLz77Array();\r\n      /** @type {number} */\r\n      var i;\r\n      /** @type {number} */\r\n      var il;\r\n\r\n      for (i = 0, il = lz77Array.length; i < il; ++i) {\r\n        lz77buf[pos++] = lz77Array[i];\r\n      }\r\n      freqsLitLen[lz77Array[0]]++;\r\n      freqsDist[lz77Array[3]]++;\r\n      skipLength = match.length + offset - 1;\r\n      prevMatch = null;\r\n    }\r\n\r\n    // LZ77 符号化\r\n    for (position = 0, length = dataArray.length; position < length; ++position) {\r\n      // ハッシュキーの作成\r\n      for (matchKey = 0, i = 0, il = RawDeflate.Lz77MinLength; i < il; ++i) {\r\n        if (position + i === length) {\r\n          break;\r\n        }\r\n        matchKey = (matchKey << 8) | dataArray[position + i];\r\n      }\r\n\r\n      // テーブルが未定義だったら作成する\r\n      if (table[matchKey] === void 0) { table[matchKey] = []; }\r\n      matchList = table[matchKey];\r\n\r\n      // skip\r\n      if (skipLength-- > 0) {\r\n        matchList.push(position);\r\n        continue;\r\n      }\r\n\r\n      // マッチテーブルの更新 (最大戻り距離を超えているものを削除する)\r\n      while (matchList.length > 0 && position - matchList[0] > windowSize) {\r\n        matchList.shift();\r\n      }\r\n\r\n      // データ末尾でマッチしようがない場合はそのまま流しこむ\r\n      if (position + RawDeflate.Lz77MinLength >= length) {\r\n        if (prevMatch) {\r\n          writeMatch(prevMatch, -1);\r\n        }\r\n\r\n        for (i = 0, il = length - position; i < il; ++i) {\r\n          tmp = dataArray[position + i];\r\n          lz77buf[pos++] = tmp;\r\n          ++freqsLitLen[tmp];\r\n        }\r\n        break;\r\n      }\r\n\r\n      // マッチ候補から最長のものを探す\r\n      if (matchList.length > 0) {\r\n        longestMatch = this.searchLongestMatch_(dataArray, position, matchList);\r\n\r\n        if (prevMatch) {\r\n          // 現在のマッチの方が前回のマッチよりも長い\r\n          if (prevMatch.length < longestMatch.length) {\r\n            // write previous literal\r\n            tmp = dataArray[position - 1];\r\n            lz77buf[pos++] = tmp;\r\n            ++freqsLitLen[tmp];\r\n\r\n            // write current match\r\n            writeMatch(longestMatch, 0);\r\n          } else {\r\n            // write previous match\r\n            writeMatch(prevMatch, -1);\r\n          }\r\n        } else if (longestMatch.length < lazy) {\r\n          prevMatch = longestMatch;\r\n        } else {\r\n          writeMatch(longestMatch, 0);\r\n        }\r\n      // 前回マッチしていて今回マッチがなかったら前回のを採用\r\n      } else if (prevMatch) {\r\n        writeMatch(prevMatch, -1);\r\n      } else {\r\n        tmp = dataArray[position];\r\n        lz77buf[pos++] = tmp;\r\n        ++freqsLitLen[tmp];\r\n      }\r\n\r\n      matchList.push(position); // マッチテーブルに現在の位置を保存\r\n    }\r\n\r\n    // 終端処理\r\n    lz77buf[pos++] = 256;\r\n    freqsLitLen[256]++;\r\n    this.freqsLitLen = freqsLitLen;\r\n    this.freqsDist = freqsDist;\r\n\r\n    return /** @type {!(Uint16Array|Array.<number>)} */ (\r\n      USE_TYPEDARRAY ?  lz77buf.subarray(0, pos) : lz77buf\r\n    );\r\n  };\r\n\r\n  /**\r\n   * マッチした候補の中から最長一致を探す\r\n   * @param {!Object} data plain data byte array.\r\n   * @param {!number} position plain data byte array position.\r\n   * @param {!Array.<number>} matchList 候補となる位置の配列.\r\n   * @return {!RawDeflate.Lz77Match} 最長かつ最短距離のマッチオブジェクト.\r\n   * @private\r\n   */\r\n  RawDeflate.prototype.searchLongestMatch_ =\r\n  function(data, position, matchList) {\r\n    var match,\r\n        currentMatch,\r\n        matchMax = 0, matchLength,\r\n        i, j, l, dl = data.length;\r\n\r\n    // 候補を後ろから 1 つずつ絞り込んでゆく\r\n    permatch:\r\n    for (i = 0, l = matchList.length; i < l; i++) {\r\n      match = matchList[l - i - 1];\r\n      matchLength = RawDeflate.Lz77MinLength;\r\n\r\n      // 前回までの最長一致を末尾から一致検索する\r\n      if (matchMax > RawDeflate.Lz77MinLength) {\r\n        for (j = matchMax; j > RawDeflate.Lz77MinLength; j--) {\r\n          if (data[match + j - 1] !== data[position + j - 1]) {\r\n            continue permatch;\r\n          }\r\n        }\r\n        matchLength = matchMax;\r\n      }\r\n\r\n      // 最長一致探索\r\n      while (matchLength < RawDeflate.Lz77MaxLength &&\r\n             position + matchLength < dl &&\r\n             data[match + matchLength] === data[position + matchLength]) {\r\n        ++matchLength;\r\n      }\r\n\r\n      // マッチ長が同じ場合は後方を優先\r\n      if (matchLength > matchMax) {\r\n        currentMatch = match;\r\n        matchMax = matchLength;\r\n      }\r\n\r\n      // 最長が確定したら後の処理は省略\r\n      if (matchLength === RawDeflate.Lz77MaxLength) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    return new RawDeflate.Lz77Match(matchMax, position - currentMatch);\r\n  };\r\n\r\n  /**\r\n   * Tree-Transmit Symbols の算出\r\n   * reference: PuTTY Deflate implementation\r\n   * @param {number} hlit HLIT.\r\n   * @param {!(Array.<number>|Uint8Array)} litlenLengths リテラルと長さ符号の符号長配列.\r\n   * @param {number} hdist HDIST.\r\n   * @param {!(Array.<number>|Uint8Array)} distLengths 距離符号の符号長配列.\r\n   * @return {{\r\n   *   codes: !(Array.<number>|Uint32Array),\r\n   *   freqs: !(Array.<number>|Uint8Array)\r\n   * }} Tree-Transmit Symbols.\r\n   */\r\n  RawDeflate.prototype.getTreeSymbols_ =\r\n  function(hlit, litlenLengths, hdist, distLengths) {\r\n    var src = new (USE_TYPEDARRAY ? Uint32Array : Array)(hlit + hdist),\r\n        i, j, runLength, l,\r\n        result = new (USE_TYPEDARRAY ? Uint32Array : Array)(286 + 30),\r\n        nResult,\r\n        rpt,\r\n        freqs = new (USE_TYPEDARRAY ? Uint8Array : Array)(19);\r\n\r\n    j = 0;\r\n    for (i = 0; i < hlit; i++) {\r\n      src[j++] = litlenLengths[i];\r\n    }\r\n    for (i = 0; i < hdist; i++) {\r\n      src[j++] = distLengths[i];\r\n    }\r\n\r\n    // 初期化\r\n    if (!USE_TYPEDARRAY) {\r\n      for (i = 0, l = freqs.length; i < l; ++i) {\r\n        freqs[i] = 0;\r\n      }\r\n    }\r\n\r\n    // 符号化\r\n    nResult = 0;\r\n    for (i = 0, l = src.length; i < l; i += j) {\r\n      // Run Length Encoding\r\n      for (j = 1; i + j < l && src[i + j] === src[i]; ++j) {}\r\n\r\n      runLength = j;\r\n\r\n      if (src[i] === 0) {\r\n        // 0 の繰り返しが 3 回未満ならばそのまま\r\n        if (runLength < 3) {\r\n          while (runLength-- > 0) {\r\n            result[nResult++] = 0;\r\n            freqs[0]++;\r\n          }\r\n        } else {\r\n          while (runLength > 0) {\r\n            // 繰り返しは最大 138 までなので切り詰める\r\n            rpt = (runLength < 138 ? runLength : 138);\r\n\r\n            if (rpt > runLength - 3 && rpt < runLength) {\r\n              rpt = runLength - 3;\r\n            }\r\n\r\n            // 3-10 回 -> 17\r\n            if (rpt <= 10) {\r\n              result[nResult++] = 17;\r\n              result[nResult++] = rpt - 3;\r\n              freqs[17]++;\r\n            // 11-138 回 -> 18\r\n            } else {\r\n              result[nResult++] = 18;\r\n              result[nResult++] = rpt - 11;\r\n              freqs[18]++;\r\n            }\r\n\r\n            runLength -= rpt;\r\n          }\r\n        }\r\n      } else {\r\n        result[nResult++] = src[i];\r\n        freqs[src[i]]++;\r\n        runLength--;\r\n\r\n        // 繰り返し回数が3回未満ならばランレングス符号は要らない\r\n        if (runLength < 3) {\r\n          while (runLength-- > 0) {\r\n            result[nResult++] = src[i];\r\n            freqs[src[i]]++;\r\n          }\r\n        // 3 回以上ならばランレングス符号化\r\n        } else {\r\n          while (runLength > 0) {\r\n            // runLengthを 3-6 で分割\r\n            rpt = (runLength < 6 ? runLength : 6);\r\n\r\n            if (rpt > runLength - 3 && rpt < runLength) {\r\n              rpt = runLength - 3;\r\n            }\r\n\r\n            result[nResult++] = 16;\r\n            result[nResult++] = rpt - 3;\r\n            freqs[16]++;\r\n\r\n            runLength -= rpt;\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      codes:\r\n        USE_TYPEDARRAY ? result.subarray(0, nResult) : result.slice(0, nResult),\r\n      freqs: freqs\r\n    };\r\n  };\r\n\r\n  /**\r\n   * ハフマン符号の長さを取得する\r\n   * @param {!(Array.<number>|Uint8Array|Uint32Array)} freqs 出現カウント.\r\n   * @param {number} limit 符号長の制限.\r\n   * @return {!(Array.<number>|Uint8Array)} 符号長配列.\r\n   * @private\r\n   */\r\n  RawDeflate.prototype.getLengths_ = function(freqs, limit) {\r\n    /** @type {number} */\r\n    var nSymbols = freqs.length;\r\n    /** @type {Heap} */\r\n    var heap = new Heap(2 * RawDeflate.HUFMAX);\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var length = new (USE_TYPEDARRAY ? Uint8Array : Array)(nSymbols);\r\n    /** @type {Array} */\r\n    var nodes;\r\n    /** @type {!(Array.<number>|Uint32Array)} */\r\n    var values;\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var codeLength;\r\n    /** @type {number} */\r\n    var i;\r\n    /** @type {number} */\r\n    var il;\r\n\r\n    // 配列の初期化\r\n    if (!USE_TYPEDARRAY) {\r\n      for (i = 0; i < nSymbols; i++) {\r\n        length[i] = 0;\r\n      }\r\n    }\r\n\r\n    // ヒープの構築\r\n    for (i = 0; i < nSymbols; ++i) {\r\n      if (freqs[i] > 0) {\r\n        heap.push(i, freqs[i]);\r\n      }\r\n    }\r\n    nodes = new Array(heap.length / 2);\r\n    values = new (USE_TYPEDARRAY ? Uint32Array : Array)(heap.length / 2);\r\n\r\n    // 非 0 の要素が一つだけだった場合は、そのシンボルに符号長 1 を割り当てて終了\r\n    if (nodes.length === 1) {\r\n      length[heap.pop().index] = 1;\r\n      return length;\r\n    }\r\n\r\n    // Reverse Package Merge Algorithm による Canonical Huffman Code の符号長決定\r\n    for (i = 0, il = heap.length / 2; i < il; ++i) {\r\n      nodes[i] = heap.pop();\r\n      values[i] = nodes[i].value;\r\n    }\r\n    codeLength = this.reversePackageMerge_(values, values.length, limit);\r\n\r\n    for (i = 0, il = nodes.length; i < il; ++i) {\r\n      length[nodes[i].index] = codeLength[i];\r\n    }\r\n\r\n    return length;\r\n  };\r\n\r\n  /**\r\n   * Reverse Package Merge Algorithm.\r\n   * @param {!(Array.<number>|Uint32Array)} freqs sorted probability.\r\n   * @param {number} symbols number of symbols.\r\n   * @param {number} limit code length limit.\r\n   * @return {!(Array.<number>|Uint8Array)} code lengths.\r\n   */\r\n  RawDeflate.prototype.reversePackageMerge_ = function(freqs, symbols, limit) {\r\n    /** @type {!(Array.<number>|Uint16Array)} */\r\n    var minimumCost = new (USE_TYPEDARRAY ? Uint16Array : Array)(limit);\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var flag = new (USE_TYPEDARRAY ? Uint8Array : Array)(limit);\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var codeLength = new (USE_TYPEDARRAY ? Uint8Array : Array)(symbols);\r\n    /** @type {Array} */\r\n    var value = new Array(limit);\r\n    /** @type {Array} */\r\n    var type  = new Array(limit);\r\n    /** @type {Array.<number>} */\r\n    var currentPosition = new Array(limit);\r\n    /** @type {number} */\r\n    var excess = (1 << limit) - symbols;\r\n    /** @type {number} */\r\n    var half = (1 << (limit - 1));\r\n    /** @type {number} */\r\n    var i;\r\n    /** @type {number} */\r\n    var j;\r\n    /** @type {number} */\r\n    var t;\r\n    /** @type {number} */\r\n    var weight;\r\n    /** @type {number} */\r\n    var next;\r\n\r\n    /**\r\n     * @param {number} j\r\n     */\r\n    function takePackage(j) {\r\n      /** @type {number} */\r\n      var x = type[j][currentPosition[j]];\r\n\r\n      if (x === symbols) {\r\n        takePackage(j+1);\r\n        takePackage(j+1);\r\n      } else {\r\n        --codeLength[x];\r\n      }\r\n\r\n      ++currentPosition[j];\r\n    }\r\n\r\n    minimumCost[limit-1] = symbols;\r\n\r\n    for (j = 0; j < limit; ++j) {\r\n      if (excess < half) {\r\n        flag[j] = 0;\r\n      } else {\r\n        flag[j] = 1;\r\n        excess -= half;\r\n      }\r\n      excess <<= 1;\r\n      minimumCost[limit-2-j] = (minimumCost[limit-1-j] / 2 | 0) + symbols;\r\n    }\r\n    minimumCost[0] = flag[0];\r\n\r\n    value[0] = new Array(minimumCost[0]);\r\n    type[0]  = new Array(minimumCost[0]);\r\n    for (j = 1; j < limit; ++j) {\r\n      if (minimumCost[j] > 2 * minimumCost[j-1] + flag[j]) {\r\n        minimumCost[j] = 2 * minimumCost[j-1] + flag[j];\r\n      }\r\n      value[j] = new Array(minimumCost[j]);\r\n      type[j]  = new Array(minimumCost[j]);\r\n    }\r\n\r\n    for (i = 0; i < symbols; ++i) {\r\n      codeLength[i] = limit;\r\n    }\r\n\r\n    for (t = 0; t < minimumCost[limit-1]; ++t) {\r\n      value[limit-1][t] = freqs[t];\r\n      type[limit-1][t]  = t;\r\n    }\r\n\r\n    for (i = 0; i < limit; ++i) {\r\n      currentPosition[i] = 0;\r\n    }\r\n    if (flag[limit-1] === 1) {\r\n      --codeLength[0];\r\n      ++currentPosition[limit-1];\r\n    }\r\n\r\n    for (j = limit-2; j >= 0; --j) {\r\n      i = 0;\r\n      weight = 0;\r\n      next = currentPosition[j+1];\r\n\r\n      for (t = 0; t < minimumCost[j]; t++) {\r\n        weight = value[j+1][next] + value[j+1][next+1];\r\n\r\n        if (weight > freqs[i]) {\r\n          value[j][t] = weight;\r\n          type[j][t] = symbols;\r\n          next += 2;\r\n        } else {\r\n          value[j][t] = freqs[i];\r\n          type[j][t] = i;\r\n          ++i;\r\n        }\r\n      }\r\n\r\n      currentPosition[j] = 0;\r\n      if (flag[j] === 1) {\r\n        takePackage(j);\r\n      }\r\n    }\r\n\r\n    return codeLength;\r\n  };\r\n\r\n  /**\r\n   * 符号長配列からハフマン符号を取得する\r\n   * reference: PuTTY Deflate implementation\r\n   * @param {!(Array.<number>|Uint8Array)} lengths 符号長配列.\r\n   * @return {!(Array.<number>|Uint16Array)} ハフマン符号配列.\r\n   * @private\r\n   */\r\n  RawDeflate.prototype.getCodesFromLengths_ = function(lengths) {\r\n    var codes = new (USE_TYPEDARRAY ? Uint16Array : Array)(lengths.length),\r\n        count = [],\r\n        startCode = [],\r\n        code = 0, i, il, j, m;\r\n\r\n    // Count the codes of each length.\r\n    for (i = 0, il = lengths.length; i < il; i++) {\r\n      count[lengths[i]] = (count[lengths[i]] | 0) + 1;\r\n    }\r\n\r\n    // Determine the starting code for each length block.\r\n    for (i = 1, il = RawDeflate.MaxCodeLength; i <= il; i++) {\r\n      startCode[i] = code;\r\n      code += count[i] | 0;\r\n      code <<= 1;\r\n    }\r\n\r\n    // Determine the code for each symbol. Mirrored, of course.\r\n    for (i = 0, il = lengths.length; i < il; i++) {\r\n      code = startCode[lengths[i]];\r\n      startCode[lengths[i]] += 1;\r\n      codes[i] = 0;\r\n\r\n      for (j = 0, m = lengths[i]; j < m; j++) {\r\n        codes[i] = (codes[i] << 1) | (code & 1);\r\n        code >>>= 1;\r\n      }\r\n    }\r\n\r\n    return codes;\r\n  };\r\n\r\n  return Zlib.RawDeflate = RawDeflate;\r\n  \r\n});\r\n\r\n\ndefine('skylark-zlib/Deflate',[\r\n  \"./zlib\",\r\n  \"./adler32\",\r\n  \"./RawDeflate\"\r\n\r\n],function(Zlib,Adler32,RawDeflate) {\r\n  /**\r\n   * @fileoverview Deflate (RFC1951) 実装.\r\n   * Deflateアルゴリズム本体は RawDeflate で実装されている.\r\n   */\r\n\r\n   const USE_TYPEDARRAY = true;\r\n\r\n  /**\r\n   * Zlib Deflate\r\n   * @constructor\r\n   * @param {!(Array|Uint8Array)} input 符号化する対象の byte array.\r\n   * @param {Object=} opt_params option parameters.\r\n   */\r\n  var Deflate = function(input, opt_params) {\r\n    /** @type {!(Array|Uint8Array)} */\r\n    this.input = input;\r\n    /** @type {!(Array|Uint8Array)} */\r\n    this.output =\r\n      new (USE_TYPEDARRAY ? Uint8Array : Array)(Deflate.DefaultBufferSize);\r\n    /** @type {Deflate.CompressionType} */\r\n    this.compressionType = Deflate.CompressionType.DYNAMIC;\r\n    /** @type {RawDeflate} */\r\n    this.rawDeflate;\r\n    /** @type {Object} */\r\n    var rawDeflateOption = {};\r\n    /** @type {string} */\r\n    var prop;\r\n\r\n    // option parameters\r\n    if (opt_params || !(opt_params = {})) {\r\n      if (typeof opt_params['compressionType'] === 'number') {\r\n        this.compressionType = opt_params['compressionType'];\r\n      }\r\n    }\r\n\r\n    // copy options\r\n    for (prop in opt_params) {\r\n      rawDeflateOption[prop] = opt_params[prop];\r\n    }\r\n\r\n    // set raw-deflate output buffer\r\n    rawDeflateOption['outputBuffer'] = this.output;\r\n\r\n    this.rawDeflate = new RawDeflate(this.input, rawDeflateOption);\r\n  };\r\n\r\n  /**\r\n   * @const\r\n   * @type {number} デフォルトバッファサイズ.\r\n   */\r\n  Deflate.DefaultBufferSize = 0x8000;\r\n\r\n  /**\r\n   * @enum {number}\r\n   */\r\n  Deflate.CompressionType = RawDeflate.CompressionType;\r\n\r\n  /**\r\n   * 直接圧縮に掛ける.\r\n   * @param {!(Array|Uint8Array)} input target buffer.\r\n   * @param {Object=} opt_params option parameters.\r\n   * @return {!(Array|Uint8Array)} compressed data byte array.\r\n   */\r\n  Deflate.compress = function(input, opt_params) {\r\n    return (new Deflate(input, opt_params)).compress();\r\n  };\r\n\r\n  /**\r\n   * Deflate Compression.\r\n   * @return {!(Array|Uint8Array)} compressed data byte array.\r\n   */\r\n  Deflate.prototype.compress = function() {\r\n    /** @type {CompressionMethod} */\r\n    var cm;\r\n    /** @type {number} */\r\n    var cinfo;\r\n    /** @type {number} */\r\n    var cmf;\r\n    /** @type {number} */\r\n    var flg;\r\n    /** @type {number} */\r\n    var fcheck;\r\n    /** @type {number} */\r\n    var fdict;\r\n    /** @type {number} */\r\n    var flevel;\r\n    /** @type {number} */\r\n    var clevel;\r\n    /** @type {number} */\r\n    var adler;\r\n    /** @type {boolean} */\r\n    var error = false;\r\n    /** @type {!(Array|Uint8Array)} */\r\n    var output;\r\n    /** @type {number} */\r\n    var pos = 0;\r\n\r\n    output = this.output;\r\n\r\n    // Compression Method and Flags\r\n    cm = Zlib.CompressionMethod.DEFLATE;\r\n    switch (cm) {\r\n      case Zlib.CompressionMethod.DEFLATE:\r\n        cinfo = Math.LOG2E * Math.log(RawDeflate.WindowSize) - 8;\r\n        break;\r\n      default:\r\n        throw new Error('invalid compression method');\r\n    }\r\n    cmf = (cinfo << 4) | cm;\r\n    output[pos++] = cmf;\r\n\r\n    // Flags\r\n    fdict = 0;\r\n    switch (cm) {\r\n      case Zlib.CompressionMethod.DEFLATE:\r\n        switch (this.compressionType) {\r\n          case Deflate.CompressionType.NONE: flevel = 0; break;\r\n          case Deflate.CompressionType.FIXED: flevel = 1; break;\r\n          case Deflate.CompressionType.DYNAMIC: flevel = 2; break;\r\n          default: throw new Error('unsupported compression type');\r\n        }\r\n        break;\r\n      default:\r\n        throw new Error('invalid compression method');\r\n    }\r\n    flg = (flevel << 6) | (fdict << 5);\r\n    fcheck = 31 - (cmf * 256 + flg) % 31;\r\n    flg |= fcheck;\r\n    output[pos++] = flg;\r\n\r\n    // Adler-32 checksum\r\n    adler = Adler32(this.input);\r\n\r\n    this.rawDeflate.op = pos;\r\n    output = this.rawDeflate.compress();\r\n    pos = output.length;\r\n\r\n    if (USE_TYPEDARRAY) {\r\n      // subarray 分を元にもどす\r\n      output = new Uint8Array(output.buffer);\r\n      // expand buffer\r\n      if (output.length <= pos + 4) {\r\n        this.output = new Uint8Array(output.length + 4);\r\n        this.output.set(output);\r\n        output = this.output;\r\n      }\r\n      output = output.subarray(0, pos + 4);\r\n    }\r\n\r\n    // adler32\r\n    output[pos++] = (adler >> 24) & 0xff;\r\n    output[pos++] = (adler >> 16) & 0xff;\r\n    output[pos++] = (adler >>  8) & 0xff;\r\n    output[pos++] = (adler      ) & 0xff;\r\n\r\n    return output;\r\n  };\r\n\r\n  return Zlib.Deflate = Deflate;\r\n\r\n});\r\n\ndefine('skylark-zlib/Gzip',[\r\n  \"./zlib\",\r\n  \"./crc32\",\r\n  \"./RawDeflate\"\r\n],function(Zlib,CRC32,RawDeflate) {\r\n  /**\r\n   * @fileoverview GZIP (RFC1952) 実装.\r\n   */\r\n\r\n  const USE_TYPEDARRAY = true;\r\n\r\n  /**\r\n   * @constructor\r\n   * @param {!(Array|Uint8Array)} input input buffer.\r\n   * @param {Object=} opt_params option parameters.\r\n   */\r\n  var Gzip = function(input, opt_params) {\r\n    /** @type {!(Array.<number>|Uint8Array)} input buffer. */\r\n    this.input = input;\r\n    /** @type {number} input buffer pointer. */\r\n    this.ip = 0;\r\n    /** @type {!(Array.<number>|Uint8Array)} output buffer. */\r\n    this.output;\r\n    /** @type {number} output buffer. */\r\n    this.op = 0;\r\n    /** @type {!Object} flags option flags. */\r\n    this.flags = {};\r\n    /** @type {!string} filename. */\r\n    this.filename;\r\n    /** @type {!string} comment. */\r\n    this.comment;\r\n    /** @type {!Object} deflate options. */\r\n    this.deflateOptions;\r\n\r\n    // option parameters\r\n    if (opt_params) {\r\n      if (opt_params['flags']) {\r\n        this.flags = opt_params['flags'];\r\n      }\r\n      if (typeof opt_params['filename'] === 'string') {\r\n        this.filename = opt_params['filename'];\r\n      }\r\n      if (typeof opt_params['comment'] === 'string') {\r\n        this.comment = opt_params['comment'];\r\n      }\r\n      if (opt_params['deflateOptions']) {\r\n        this.deflateOptions = opt_params['deflateOptions'];\r\n      }\r\n    }\r\n\r\n    if (!this.deflateOptions) {\r\n      this.deflateOptions = {};\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @type {number}\r\n   * @const\r\n   */\r\n  Gzip.DefaultBufferSize = 0x8000;\r\n\r\n  /**\r\n   * encode gzip members.\r\n   * @return {!(Array|Uint8Array)} gzip binary array.\r\n   */\r\n  Gzip.prototype.compress = function() {\r\n    /** @type {number} flags. */\r\n    var flg;\r\n    /** @type {number} modification time. */\r\n    var mtime;\r\n    /** @type {number} CRC-16 value for FHCRC flag. */\r\n    var crc16;\r\n    /** @type {number} CRC-32 value for verification. */\r\n    var crc32;\r\n    /** @type {!RawDeflate} raw deflate object. */\r\n    var rawdeflate;\r\n    /** @type {number} character code */\r\n    var c;\r\n    /** @type {number} loop counter. */\r\n    var i;\r\n    /** @type {number} loop limiter. */\r\n    var il;\r\n    /** @type {!(Array|Uint8Array)} output buffer. */\r\n    var output =\r\n      new (USE_TYPEDARRAY ? Uint8Array : Array)(Gzip.DefaultBufferSize);\r\n    /** @type {number} output buffer pointer. */\r\n    var op = 0;\r\n\r\n    var input = this.input;\r\n    var ip = this.ip;\r\n    var filename = this.filename;\r\n    var comment = this.comment;\r\n\r\n    // check signature\r\n    output[op++] = 0x1f;\r\n    output[op++] = 0x8b;\r\n\r\n    // check compression method\r\n    output[op++] = 8; /* XXX: use Zlib const */\r\n\r\n    // flags\r\n    flg = 0;\r\n    if (this.flags['fname'])    flg |= Gzip.FlagsMask.FNAME;\r\n    if (this.flags['fcomment']) flg |= Gzip.FlagsMask.FCOMMENT;\r\n    if (this.flags['fhcrc'])    flg |= Gzip.FlagsMask.FHCRC;\r\n    // XXX: FTEXT\r\n    // XXX: FEXTRA\r\n    output[op++] = flg;\r\n\r\n    // modification time\r\n    mtime = (Date.now ? Date.now() : +new Date()) / 1000 | 0;\r\n    output[op++] = mtime        & 0xff;\r\n    output[op++] = mtime >>>  8 & 0xff;\r\n    output[op++] = mtime >>> 16 & 0xff;\r\n    output[op++] = mtime >>> 24 & 0xff;\r\n\r\n    // extra flags\r\n    output[op++] = 0;\r\n\r\n    // operating system\r\n    output[op++] = Gzip.OperatingSystem.UNKNOWN;\r\n\r\n    // extra\r\n    /* NOP */\r\n\r\n    // fname\r\n    if (this.flags['fname'] !== void 0) {\r\n      for (i = 0, il = filename.length; i < il; ++i) {\r\n        c = filename.charCodeAt(i);\r\n        if (c > 0xff) { output[op++] = (c >>> 8) & 0xff; }\r\n        output[op++] = c & 0xff;\r\n      }\r\n      output[op++] = 0; // null termination\r\n    }\r\n\r\n    // fcomment\r\n    if (this.flags['comment']) {\r\n      for (i = 0, il = comment.length; i < il; ++i) {\r\n        c = comment.charCodeAt(i);\r\n        if (c > 0xff) { output[op++] = (c >>> 8) & 0xff; }\r\n        output[op++] = c & 0xff;\r\n      }\r\n      output[op++] = 0; // null termination\r\n    }\r\n\r\n    // fhcrc\r\n    if (this.flags['fhcrc']) {\r\n      crc16 = CRC32.calc(output, 0, op) & 0xffff;\r\n      output[op++] = (crc16      ) & 0xff;\r\n      output[op++] = (crc16 >>> 8) & 0xff;\r\n    }\r\n\r\n    // add compress option\r\n    this.deflateOptions['outputBuffer'] = output;\r\n    this.deflateOptions['outputIndex'] = op;\r\n\r\n    // compress\r\n    rawdeflate = new RawDeflate(input, this.deflateOptions);\r\n    output = rawdeflate.compress();\r\n    op = rawdeflate.op;\r\n\r\n    // expand buffer\r\n    if (USE_TYPEDARRAY) {\r\n      if (op + 8 > output.buffer.byteLength) {\r\n        this.output = new Uint8Array(op + 8);\r\n        this.output.set(new Uint8Array(output.buffer));\r\n        output = this.output;\r\n      } else {\r\n        output = new Uint8Array(output.buffer);\r\n      }\r\n    }\r\n\r\n    // crc32\r\n    crc32 = CRC32.calc(input);\r\n    output[op++] = (crc32       ) & 0xff;\r\n    output[op++] = (crc32 >>>  8) & 0xff;\r\n    output[op++] = (crc32 >>> 16) & 0xff;\r\n    output[op++] = (crc32 >>> 24) & 0xff;\r\n\r\n    // input size\r\n    il = input.length;\r\n    output[op++] = (il       ) & 0xff;\r\n    output[op++] = (il >>>  8) & 0xff;\r\n    output[op++] = (il >>> 16) & 0xff;\r\n    output[op++] = (il >>> 24) & 0xff;\r\n\r\n    this.ip = ip;\r\n\r\n    if (USE_TYPEDARRAY && op < output.length) {\r\n      this.output = output = output.subarray(0, op);\r\n    }\r\n\r\n    return output;\r\n  };\r\n\r\n  /** @enum {number} */\r\n  Gzip.OperatingSystem = {\r\n    FAT: 0,\r\n    AMIGA: 1,\r\n    VMS: 2,\r\n    UNIX: 3,\r\n    VM_CMS: 4,\r\n    ATARI_TOS: 5,\r\n    HPFS: 6,\r\n    MACINTOSH: 7,\r\n    Z_SYSTEM: 8,\r\n    CP_M: 9,\r\n    TOPS_20: 10,\r\n    NTFS: 11,\r\n    QDOS: 12,\r\n    ACORN_RISCOS: 13,\r\n    UNKNOWN: 255\r\n  };\r\n\r\n  /** @enum {number} */\r\n  Gzip.FlagsMask = {\r\n    FTEXT: 0x01,\r\n    FHCRC: 0x02,\r\n    FEXTRA: 0x04,\r\n    FNAME: 0x08,\r\n    FCOMMENT: 0x10\r\n  };\r\n\r\n\r\n  return Zlib.Gzip = Gzip;\r\n\r\n});\r\n\r\n\ndefine('skylark-zlib/RawInflate',[\r\n  \"./zlib\"\r\n],function(Zlib) {\r\n  const USE_TYPEDARRAY = true;\r\n\r\n  //-----------------------------------------------------------------------------\r\n\r\n  /** @define {number} buffer block size. */\r\n  var ZLIB_RAW_INFLATE_BUFFER_SIZE = 0x8000; // [ 0x8000 >= ZLIB_BUFFER_BLOCK_SIZE ]\r\n\r\n  //-----------------------------------------------------------------------------\r\n\r\n  var buildHuffmanTable = Huffman.buildHuffmanTable;\r\n\r\n  /**\r\n   * @constructor\r\n   * @param {!(Uint8Array|Array.<number>)} input input buffer.\r\n   * @param {Object} opt_params option parameter.\r\n   *\r\n   * opt_params は以下のプロパティを指定する事ができます。\r\n   *   - index: input buffer の deflate コンテナの開始位置.\r\n   *   - blockSize: バッファのブロックサイズ.\r\n   *   - bufferType: RawInflate.BufferType の値によってバッファの管理方法を指定する.\r\n   *   - resize: 確保したバッファが実際の大きさより大きかった場合に切り詰める.\r\n   */\r\n  var RawInflate = function(input, opt_params) {\r\n    /** @type {!(Array.<number>|Uint8Array)} inflated buffer */\r\n    this.buffer;\r\n    /** @type {!Array.<(Array.<number>|Uint8Array)>} */\r\n    this.blocks = [];\r\n    /** @type {number} block size. */\r\n    this.bufferSize = ZLIB_RAW_INFLATE_BUFFER_SIZE;\r\n    /** @type {!number} total output buffer pointer. */\r\n    this.totalpos = 0;\r\n    /** @type {!number} input buffer pointer. */\r\n    this.ip = 0;\r\n    /** @type {!number} bit stream reader buffer. */\r\n    this.bitsbuf = 0;\r\n    /** @type {!number} bit stream reader buffer size. */\r\n    this.bitsbuflen = 0;\r\n    /** @type {!(Array.<number>|Uint8Array)} input buffer. */\r\n    this.input = USE_TYPEDARRAY ? new Uint8Array(input) : input;\r\n    /** @type {!(Uint8Array|Array.<number>)} output buffer. */\r\n    this.output;\r\n    /** @type {!number} output buffer pointer. */\r\n    this.op;\r\n    /** @type {boolean} is final block flag. */\r\n    this.bfinal = false;\r\n    /** @type {RawInflate.BufferType} buffer management. */\r\n    this.bufferType = RawInflate.BufferType.ADAPTIVE;\r\n    /** @type {boolean} resize flag for memory size optimization. */\r\n    this.resize = false;\r\n\r\n    // option parameters\r\n    if (opt_params || !(opt_params = {})) {\r\n      if (opt_params['index']) {\r\n        this.ip = opt_params['index'];\r\n      }\r\n      if (opt_params['bufferSize']) {\r\n        this.bufferSize = opt_params['bufferSize'];\r\n      }\r\n      if (opt_params['bufferType']) {\r\n        this.bufferType = opt_params['bufferType'];\r\n      }\r\n      if (opt_params['resize']) {\r\n        this.resize = opt_params['resize'];\r\n      }\r\n    }\r\n\r\n    // initialize\r\n    switch (this.bufferType) {\r\n      case RawInflate.BufferType.BLOCK:\r\n        this.op = RawInflate.MaxBackwardLength;\r\n        this.output =\r\n          new (USE_TYPEDARRAY ? Uint8Array : Array)(\r\n            RawInflate.MaxBackwardLength +\r\n            this.bufferSize +\r\n            RawInflate.MaxCopyLength\r\n          );\r\n        break;\r\n      case RawInflate.BufferType.ADAPTIVE:\r\n        this.op = 0;\r\n        this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(this.bufferSize);\r\n        this.expandBuffer = this.expandBufferAdaptive;\r\n        this.concatBuffer = this.concatBufferDynamic;\r\n        this.decodeHuffman = this.decodeHuffmanAdaptive;\r\n        break;\r\n      default:\r\n        throw new Error('invalid inflate mode');\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @enum {number}\r\n   */\r\n  RawInflate.BufferType = {\r\n    BLOCK: 0,\r\n    ADAPTIVE: 1\r\n  };\r\n\r\n  /**\r\n   * decompress.\r\n   * @return {!(Uint8Array|Array.<number>)} inflated buffer.\r\n   */\r\n  RawInflate.prototype.decompress = function() {\r\n    while (!this.bfinal) {\r\n      this.parseBlock();\r\n    }\r\n\r\n    return this.concatBuffer();\r\n  };\r\n\r\n  /**\r\n   * @const\r\n   * @type {number} max backward length for LZ77.\r\n   */\r\n  RawInflate.MaxBackwardLength = 32768;\r\n\r\n  /**\r\n   * @const\r\n   * @type {number} max copy length for LZ77.\r\n   */\r\n  RawInflate.MaxCopyLength = 258;\r\n\r\n  /**\r\n   * huffman order\r\n   * @const\r\n   * @type {!(Array.<number>|Uint8Array)}\r\n   */\r\n  RawInflate.Order = (function(table) {\r\n    return USE_TYPEDARRAY ? new Uint16Array(table) : table;\r\n  })([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\r\n\r\n  /**\r\n   * huffman length code table.\r\n   * @const\r\n   * @type {!(Array.<number>|Uint16Array)}\r\n   */\r\n  RawInflate.LengthCodeTable = (function(table) {\r\n    return USE_TYPEDARRAY ? new Uint16Array(table) : table;\r\n  })([\r\n    0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,\r\n    0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,\r\n    0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,\r\n    0x00e3, 0x0102, 0x0102, 0x0102\r\n  ]);\r\n\r\n  /**\r\n   * huffman length extra-bits table.\r\n   * @const\r\n   * @type {!(Array.<number>|Uint8Array)}\r\n   */\r\n  RawInflate.LengthExtraTable = (function(table) {\r\n    return USE_TYPEDARRAY ? new Uint8Array(table) : table;\r\n  })([\r\n    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,\r\n    5, 5, 0, 0, 0\r\n  ]);\r\n\r\n  /**\r\n   * huffman dist code table.\r\n   * @const\r\n   * @type {!(Array.<number>|Uint16Array)}\r\n   */\r\n  RawInflate.DistCodeTable = (function(table) {\r\n    return USE_TYPEDARRAY ? new Uint16Array(table) : table;\r\n  })([\r\n    0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,\r\n    0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,\r\n    0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,\r\n    0x3001, 0x4001, 0x6001\r\n  ]);\r\n\r\n  /**\r\n   * huffman dist extra-bits table.\r\n   * @const\r\n   * @type {!(Array.<number>|Uint8Array)}\r\n   */\r\n  RawInflate.DistExtraTable = (function(table) {\r\n    return USE_TYPEDARRAY ? new Uint8Array(table) : table;\r\n  })([\r\n    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,\r\n    11, 12, 12, 13, 13\r\n  ]);\r\n\r\n  /**\r\n   * fixed huffman length code table\r\n   * @const\r\n   * @type {!Array}\r\n   */\r\n  RawInflate.FixedLiteralLengthTable = (function(table) {\r\n    return table;\r\n  })((function() {\r\n    var lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(288);\r\n    var i, il;\r\n\r\n    for (i = 0, il = lengths.length; i < il; ++i) {\r\n      lengths[i] =\r\n        (i <= 143) ? 8 :\r\n        (i <= 255) ? 9 :\r\n        (i <= 279) ? 7 :\r\n        8;\r\n    }\r\n\r\n    return buildHuffmanTable(lengths);\r\n  })());\r\n\r\n  /**\r\n   * fixed huffman distance code table\r\n   * @const\r\n   * @type {!Array}\r\n   */\r\n  RawInflate.FixedDistanceTable = (function(table) {\r\n    return table;\r\n  })((function() {\r\n    var lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(30);\r\n    var i, il;\r\n\r\n    for (i = 0, il = lengths.length; i < il; ++i) {\r\n      lengths[i] = 5;\r\n    }\r\n\r\n    return buildHuffmanTable(lengths);\r\n  })());\r\n\r\n  /**\r\n   * parse deflated block.\r\n   */\r\n  RawInflate.prototype.parseBlock = function() {\r\n    /** @type {number} header */\r\n    var hdr = this.readBits(3);\r\n\r\n    // BFINAL\r\n    if (hdr & 0x1) {\r\n      this.bfinal = true;\r\n    }\r\n\r\n    // BTYPE\r\n    hdr >>>= 1;\r\n    switch (hdr) {\r\n      // uncompressed\r\n      case 0:\r\n        this.parseUncompressedBlock();\r\n        break;\r\n      // fixed huffman\r\n      case 1:\r\n        this.parseFixedHuffmanBlock();\r\n        break;\r\n      // dynamic huffman\r\n      case 2:\r\n        this.parseDynamicHuffmanBlock();\r\n        break;\r\n      // reserved or other\r\n      default:\r\n        throw new Error('unknown BTYPE: ' + hdr);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * read inflate bits\r\n   * @param {number} length bits length.\r\n   * @return {number} read bits.\r\n   */\r\n  RawInflate.prototype.readBits = function(length) {\r\n    var bitsbuf = this.bitsbuf;\r\n    var bitsbuflen = this.bitsbuflen;\r\n    var input = this.input;\r\n    var ip = this.ip;\r\n\r\n    /** @type {number} */\r\n    var inputLength = input.length;\r\n    /** @type {number} input and output byte. */\r\n    var octet;\r\n\r\n    // not enough buffer\r\n    while (bitsbuflen < length) {\r\n      // input byte\r\n      if (ip >= inputLength) {\r\n        throw new Error('input buffer is broken');\r\n      }\r\n\r\n      // concat octet\r\n      bitsbuf |= input[ip++] << bitsbuflen;\r\n      bitsbuflen += 8;\r\n    }\r\n\r\n    // output byte\r\n    octet = bitsbuf & /* MASK */ ((1 << length) - 1);\r\n    bitsbuf >>>= length;\r\n    bitsbuflen -= length;\r\n\r\n    this.bitsbuf = bitsbuf;\r\n    this.bitsbuflen = bitsbuflen;\r\n    this.ip = ip;\r\n\r\n    return octet;\r\n  };\r\n\r\n  /**\r\n   * read huffman code using table\r\n   * @param {!(Array.<number>|Uint8Array|Uint16Array)} table huffman code table.\r\n   * @return {number} huffman code.\r\n   */\r\n  RawInflate.prototype.readCodeByTable = function(table) {\r\n    var bitsbuf = this.bitsbuf;\r\n    var bitsbuflen = this.bitsbuflen;\r\n    var input = this.input;\r\n    var ip = this.ip;\r\n\r\n    /** @type {number} */\r\n    var inputLength = input.length;\r\n    /** @type {!(Array.<number>|Uint8Array)} huffman code table */\r\n    var codeTable = table[0];\r\n    /** @type {number} */\r\n    var maxCodeLength = table[1];\r\n    /** @type {number} code length & code (16bit, 16bit) */\r\n    var codeWithLength;\r\n    /** @type {number} code bits length */\r\n    var codeLength;\r\n\r\n    // not enough buffer\r\n    while (bitsbuflen < maxCodeLength) {\r\n      if (ip >= inputLength) {\r\n        break;\r\n      }\r\n      bitsbuf |= input[ip++] << bitsbuflen;\r\n      bitsbuflen += 8;\r\n    }\r\n\r\n    // read max length\r\n    codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];\r\n    codeLength = codeWithLength >>> 16;\r\n\r\n    if (codeLength > bitsbuflen) {\r\n      throw new Error('invalid code length: ' + codeLength);\r\n    }\r\n\r\n    this.bitsbuf = bitsbuf >> codeLength;\r\n    this.bitsbuflen = bitsbuflen - codeLength;\r\n    this.ip = ip;\r\n\r\n    return codeWithLength & 0xffff;\r\n  };\r\n\r\n  /**\r\n   * parse uncompressed block.\r\n   */\r\n  RawInflate.prototype.parseUncompressedBlock = function() {\r\n    var input = this.input;\r\n    var ip = this.ip;\r\n    var output = this.output;\r\n    var op = this.op;\r\n\r\n    /** @type {number} */\r\n    var inputLength = input.length;\r\n    /** @type {number} block length */\r\n    var len;\r\n    /** @type {number} number for check block length */\r\n    var nlen;\r\n    /** @type {number} output buffer length */\r\n    var olength = output.length;\r\n    /** @type {number} copy counter */\r\n    var preCopy;\r\n\r\n    // skip buffered header bits\r\n    this.bitsbuf = 0;\r\n    this.bitsbuflen = 0;\r\n\r\n    // len\r\n    if (ip + 1 >= inputLength) {\r\n      throw new Error('invalid uncompressed block header: LEN');\r\n    }\r\n    len = input[ip++] | (input[ip++] << 8);\r\n\r\n    // nlen\r\n    if (ip + 1 >= inputLength) {\r\n      throw new Error('invalid uncompressed block header: NLEN');\r\n    }\r\n    nlen = input[ip++] | (input[ip++] << 8);\r\n\r\n    // check len & nlen\r\n    if (len === ~nlen) {\r\n      throw new Error('invalid uncompressed block header: length verify');\r\n    }\r\n\r\n    // check size\r\n    if (ip + len > input.length) { throw new Error('input buffer is broken'); }\r\n\r\n    // expand buffer\r\n    switch (this.bufferType) {\r\n      case RawInflate.BufferType.BLOCK:\r\n        // pre copy\r\n        while (op + len > output.length) {\r\n          preCopy = olength - op;\r\n          len -= preCopy;\r\n          if (USE_TYPEDARRAY) {\r\n            output.set(input.subarray(ip, ip + preCopy), op);\r\n            op += preCopy;\r\n            ip += preCopy;\r\n          } else {\r\n            while (preCopy--) {\r\n              output[op++] = input[ip++];\r\n            }\r\n          }\r\n          this.op = op;\r\n          output = this.expandBuffer();\r\n          op = this.op;\r\n        }\r\n        break;\r\n      case RawInflate.BufferType.ADAPTIVE:\r\n        while (op + len > output.length) {\r\n          output = this.expandBuffer({fixRatio: 2});\r\n        }\r\n        break;\r\n      default:\r\n        throw new Error('invalid inflate mode');\r\n    }\r\n\r\n    // copy\r\n    if (USE_TYPEDARRAY) {\r\n      output.set(input.subarray(ip, ip + len), op);\r\n      op += len;\r\n      ip += len;\r\n    } else {\r\n      while (len--) {\r\n        output[op++] = input[ip++];\r\n      }\r\n    }\r\n\r\n    this.ip = ip;\r\n    this.op = op;\r\n    this.output = output;\r\n  };\r\n\r\n  /**\r\n   * parse fixed huffman block.\r\n   */\r\n  RawInflate.prototype.parseFixedHuffmanBlock = function() {\r\n    this.decodeHuffman(\r\n      RawInflate.FixedLiteralLengthTable,\r\n      RawInflate.FixedDistanceTable\r\n    );\r\n  };\r\n\r\n  /**\r\n   * parse dynamic huffman block.\r\n   */\r\n  RawInflate.prototype.parseDynamicHuffmanBlock = function() {\r\n    /** @type {number} number of literal and length codes. */\r\n    var hlit = this.readBits(5) + 257;\r\n    /** @type {number} number of distance codes. */\r\n    var hdist = this.readBits(5) + 1;\r\n    /** @type {number} number of code lengths. */\r\n    var hclen = this.readBits(4) + 4;\r\n    /** @type {!(Uint8Array|Array.<number>)} code lengths. */\r\n    var codeLengths =\r\n      new (USE_TYPEDARRAY ? Uint8Array : Array)(RawInflate.Order.length);\r\n    /** @type {!Array} code lengths table. */\r\n    var codeLengthsTable;\r\n    /** @type {!(Uint8Array|Array.<number>)} literal and length code table. */\r\n    var litlenTable;\r\n    /** @type {!(Uint8Array|Array.<number>)} distance code table. */\r\n    var distTable;\r\n    /** @type {!(Uint8Array|Array.<number>)} code length table. */\r\n    var lengthTable;\r\n    /** @type {number} */\r\n    var code;\r\n    /** @type {number} */\r\n    var prev;\r\n    /** @type {number} */\r\n    var repeat;\r\n    /** @type {number} loop counter. */\r\n    var i;\r\n    /** @type {number} loop limit. */\r\n    var il;\r\n\r\n    // decode code lengths\r\n    for (i = 0; i < hclen; ++i) {\r\n      codeLengths[RawInflate.Order[i]] = this.readBits(3);\r\n    }\r\n    if (!USE_TYPEDARRAY) {\r\n      for (i = hclen, hclen = codeLengths.length; i < hclen; ++i) {\r\n        codeLengths[RawInflate.Order[i]] = 0;\r\n      }\r\n    }\r\n\r\n    // decode length table\r\n    codeLengthsTable = buildHuffmanTable(codeLengths);\r\n    lengthTable = new (USE_TYPEDARRAY ? Uint8Array : Array)(hlit + hdist);\r\n    for (i = 0, il = hlit + hdist; i < il;) {\r\n      code = this.readCodeByTable(codeLengthsTable);\r\n      switch (code) {\r\n        case 16:\r\n          repeat = 3 + this.readBits(2);\r\n          while (repeat--) { lengthTable[i++] = prev; }\r\n          break;\r\n        case 17:\r\n          repeat = 3 + this.readBits(3);\r\n          while (repeat--) { lengthTable[i++] = 0; }\r\n          prev = 0;\r\n          break;\r\n        case 18:\r\n          repeat = 11 + this.readBits(7);\r\n          while (repeat--) { lengthTable[i++] = 0; }\r\n          prev = 0;\r\n          break;\r\n        default:\r\n          lengthTable[i++] = code;\r\n          prev = code;\r\n          break;\r\n      }\r\n    }\r\n\r\n    litlenTable = USE_TYPEDARRAY\r\n      ? buildHuffmanTable(lengthTable.subarray(0, hlit))\r\n      : buildHuffmanTable(lengthTable.slice(0, hlit));\r\n    distTable = USE_TYPEDARRAY\r\n      ? buildHuffmanTable(lengthTable.subarray(hlit))\r\n      : buildHuffmanTable(lengthTable.slice(hlit));\r\n\r\n    this.decodeHuffman(litlenTable, distTable);\r\n  };\r\n\r\n  /**\r\n   * decode huffman code\r\n   * @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.\r\n   * @param {!(Array.<number>|Uint8Array)} dist distination code table.\r\n   */\r\n  RawInflate.prototype.decodeHuffman = function(litlen, dist) {\r\n    var output = this.output;\r\n    var op = this.op;\r\n\r\n    this.currentLitlenTable = litlen;\r\n\r\n    /** @type {number} output position limit. */\r\n    var olength = output.length - RawInflate.MaxCopyLength;\r\n    /** @type {number} huffman code. */\r\n    var code;\r\n    /** @type {number} table index. */\r\n    var ti;\r\n    /** @type {number} huffman code distination. */\r\n    var codeDist;\r\n    /** @type {number} huffman code length. */\r\n    var codeLength;\r\n\r\n    while ((code = this.readCodeByTable(litlen)) !== 256) {\r\n      // literal\r\n      if (code < 256) {\r\n        if (op >= olength) {\r\n          this.op = op;\r\n          output = this.expandBuffer();\r\n          op = this.op;\r\n        }\r\n        output[op++] = code;\r\n\r\n        continue;\r\n      }\r\n\r\n      // length code\r\n      ti = code - 257;\r\n      codeLength = RawInflate.LengthCodeTable[ti];\r\n      if (RawInflate.LengthExtraTable[ti] > 0) {\r\n        codeLength += this.readBits(RawInflate.LengthExtraTable[ti]);\r\n      }\r\n\r\n      // dist code\r\n      code = this.readCodeByTable(dist);\r\n      codeDist = RawInflate.DistCodeTable[code];\r\n      if (RawInflate.DistExtraTable[code] > 0) {\r\n        codeDist += this.readBits(RawInflate.DistExtraTable[code]);\r\n      }\r\n\r\n      // lz77 decode\r\n      if (op >= olength) {\r\n        this.op = op;\r\n        output = this.expandBuffer();\r\n        op = this.op;\r\n      }\r\n      while (codeLength--) {\r\n        output[op] = output[(op++) - codeDist];\r\n      }\r\n    }\r\n\r\n    while (this.bitsbuflen >= 8) {\r\n      this.bitsbuflen -= 8;\r\n      this.ip--;\r\n    }\r\n    this.op = op;\r\n  };\r\n\r\n  /**\r\n   * decode huffman code (adaptive)\r\n   * @param {!(Array.<number>|Uint16Array)} litlen literal and length code table.\r\n   * @param {!(Array.<number>|Uint8Array)} dist distination code table.\r\n   */\r\n  RawInflate.prototype.decodeHuffmanAdaptive = function(litlen, dist) {\r\n    var output = this.output;\r\n    var op = this.op;\r\n\r\n    this.currentLitlenTable = litlen;\r\n\r\n    /** @type {number} output position limit. */\r\n    var olength = output.length;\r\n    /** @type {number} huffman code. */\r\n    var code;\r\n    /** @type {number} table index. */\r\n    var ti;\r\n    /** @type {number} huffman code distination. */\r\n    var codeDist;\r\n    /** @type {number} huffman code length. */\r\n    var codeLength;\r\n\r\n    while ((code = this.readCodeByTable(litlen)) !== 256) {\r\n      // literal\r\n      if (code < 256) {\r\n        if (op >= olength) {\r\n          output = this.expandBuffer();\r\n          olength = output.length;\r\n        }\r\n        output[op++] = code;\r\n\r\n        continue;\r\n      }\r\n\r\n      // length code\r\n      ti = code - 257;\r\n      codeLength = RawInflate.LengthCodeTable[ti];\r\n      if (RawInflate.LengthExtraTable[ti] > 0) {\r\n        codeLength += this.readBits(RawInflate.LengthExtraTable[ti]);\r\n      }\r\n\r\n      // dist code\r\n      code = this.readCodeByTable(dist);\r\n      codeDist = RawInflate.DistCodeTable[code];\r\n      if (RawInflate.DistExtraTable[code] > 0) {\r\n        codeDist += this.readBits(RawInflate.DistExtraTable[code]);\r\n      }\r\n\r\n      // lz77 decode\r\n      if (op + codeLength > olength) {\r\n        output = this.expandBuffer();\r\n        olength = output.length;\r\n      }\r\n      while (codeLength--) {\r\n        output[op] = output[(op++) - codeDist];\r\n      }\r\n    }\r\n\r\n    while (this.bitsbuflen >= 8) {\r\n      this.bitsbuflen -= 8;\r\n      this.ip--;\r\n    }\r\n    this.op = op;\r\n  };\r\n\r\n  /**\r\n   * expand output buffer.\r\n   * @param {Object=} opt_param option parameters.\r\n   * @return {!(Array.<number>|Uint8Array)} output buffer.\r\n   */\r\n  RawInflate.prototype.expandBuffer = function(opt_param) {\r\n    /** @type {!(Array.<number>|Uint8Array)} store buffer. */\r\n    var buffer =\r\n      new (USE_TYPEDARRAY ? Uint8Array : Array)(\r\n          this.op - RawInflate.MaxBackwardLength\r\n      );\r\n    /** @type {number} backward base point */\r\n    var backward = this.op - RawInflate.MaxBackwardLength;\r\n    /** @type {number} copy index. */\r\n    var i;\r\n    /** @type {number} copy limit */\r\n    var il;\r\n\r\n    var output = this.output;\r\n\r\n    // copy to output buffer\r\n    if (USE_TYPEDARRAY) {\r\n      buffer.set(output.subarray(RawInflate.MaxBackwardLength, buffer.length));\r\n    } else {\r\n      for (i = 0, il = buffer.length; i < il; ++i) {\r\n        buffer[i] = output[i + RawInflate.MaxBackwardLength];\r\n      }\r\n    }\r\n\r\n    this.blocks.push(buffer);\r\n    this.totalpos += buffer.length;\r\n\r\n    // copy to backward buffer\r\n    if (USE_TYPEDARRAY) {\r\n      output.set(\r\n        output.subarray(backward, backward + RawInflate.MaxBackwardLength)\r\n      );\r\n    } else {\r\n      for (i = 0; i < RawInflate.MaxBackwardLength; ++i) {\r\n        output[i] = output[backward + i];\r\n      }\r\n    }\r\n\r\n    this.op = RawInflate.MaxBackwardLength;\r\n\r\n    return output;\r\n  };\r\n\r\n  /**\r\n   * expand output buffer. (adaptive)\r\n   * @param {Object=} opt_param option parameters.\r\n   * @return {!(Array.<number>|Uint8Array)} output buffer pointer.\r\n   */\r\n  RawInflate.prototype.expandBufferAdaptive = function(opt_param) {\r\n    /** @type {!(Array.<number>|Uint8Array)} store buffer. */\r\n    var buffer;\r\n    /** @type {number} expantion ratio. */\r\n    var ratio = (this.input.length / this.ip + 1) | 0;\r\n    /** @type {number} maximum number of huffman code. */\r\n    var maxHuffCode;\r\n    /** @type {number} new output buffer size. */\r\n    var newSize;\r\n    /** @type {number} max inflate size. */\r\n    var maxInflateSize;\r\n\r\n    var input = this.input;\r\n    var output = this.output;\r\n\r\n    if (opt_param) {\r\n      if (typeof opt_param.fixRatio === 'number') {\r\n        ratio = opt_param.fixRatio;\r\n      }\r\n      if (typeof opt_param.addRatio === 'number') {\r\n        ratio += opt_param.addRatio;\r\n      }\r\n    }\r\n\r\n    // calculate new buffer size\r\n    if (ratio < 2) {\r\n      maxHuffCode =\r\n        (input.length - this.ip) / this.currentLitlenTable[2];\r\n      maxInflateSize = (maxHuffCode / 2 * 258) | 0;\r\n      newSize = maxInflateSize < output.length ?\r\n        output.length + maxInflateSize :\r\n        output.length << 1;\r\n    } else {\r\n      newSize = output.length * ratio;\r\n    }\r\n\r\n    // buffer expantion\r\n    if (USE_TYPEDARRAY) {\r\n      buffer = new Uint8Array(newSize);\r\n      buffer.set(output);\r\n    } else {\r\n      buffer = output;\r\n    }\r\n\r\n    this.output = buffer;\r\n\r\n    return this.output;\r\n  };\r\n\r\n  /**\r\n   * concat output buffer.\r\n   * @return {!(Array.<number>|Uint8Array)} output buffer.\r\n   */\r\n  RawInflate.prototype.concatBuffer = function() {\r\n    /** @type {number} buffer pointer. */\r\n    var pos = 0;\r\n    /** @type {number} buffer pointer. */\r\n    var limit = this.totalpos + (this.op - RawInflate.MaxBackwardLength);\r\n    /** @type {!(Array.<number>|Uint8Array)} output block array. */\r\n    var output = this.output;\r\n    /** @type {!Array} blocks array. */\r\n    var blocks = this.blocks;\r\n    /** @type {!(Array.<number>|Uint8Array)} output block array. */\r\n    var block;\r\n    /** @type {!(Array.<number>|Uint8Array)} output buffer. */\r\n    var buffer = new (USE_TYPEDARRAY ? Uint8Array : Array)(limit);\r\n    /** @type {number} loop counter. */\r\n    var i;\r\n    /** @type {number} loop limiter. */\r\n    var il;\r\n    /** @type {number} loop counter. */\r\n    var j;\r\n    /** @type {number} loop limiter. */\r\n    var jl;\r\n\r\n    // single buffer\r\n    if (blocks.length === 0) {\r\n      return USE_TYPEDARRAY ?\r\n        this.output.subarray(RawInflate.MaxBackwardLength, this.op) :\r\n        this.output.slice(RawInflate.MaxBackwardLength, this.op);\r\n    }\r\n\r\n    // copy to buffer\r\n    for (i = 0, il = blocks.length; i < il; ++i) {\r\n      block = blocks[i];\r\n      for (j = 0, jl = block.length; j < jl; ++j) {\r\n        buffer[pos++] = block[j];\r\n      }\r\n    }\r\n\r\n    // current buffer\r\n    for (i = RawInflate.MaxBackwardLength, il = this.op; i < il; ++i) {\r\n      buffer[pos++] = output[i];\r\n    }\r\n\r\n    this.blocks = [];\r\n    this.buffer = buffer;\r\n\r\n    return this.buffer;\r\n  };\r\n\r\n  /**\r\n   * concat output buffer. (dynamic)\r\n   * @return {!(Array.<number>|Uint8Array)} output buffer.\r\n   */\r\n  RawInflate.prototype.concatBufferDynamic = function() {\r\n    /** @type {Array.<number>|Uint8Array} output buffer. */\r\n    var buffer;\r\n    var op = this.op;\r\n\r\n    if (USE_TYPEDARRAY) {\r\n      if (this.resize) {\r\n        buffer = new Uint8Array(op);\r\n        buffer.set(this.output.subarray(0, op));\r\n      } else {\r\n        buffer = this.output.subarray(0, op);\r\n      }\r\n    } else {\r\n      if (this.output.length > op) {\r\n        this.output.length = op;\r\n      }\r\n      buffer = this.output;\r\n    }\r\n\r\n    this.buffer = buffer;\r\n\r\n    return this.buffer;\r\n  };\r\n\r\n  return Zlib.RawInflate = RawInflate;\r\n});\r\n\r\n\r\n\r\n\ndefine('skylark-zlib/GunzipMember',[\r\n  \"./zlib\"\r\n],function(Zlib) {\r\n  /**\r\n   * @constructor\r\n   */\r\n  var GunzipMember = function() {\r\n    /** @type {number} signature first byte. */\r\n    this.id1;\r\n    /** @type {number} signature second byte. */\r\n    this.id2;\r\n    /** @type {number} compression method. */\r\n    this.cm;\r\n    /** @type {number} flags. */\r\n    this.flg;\r\n    /** @type {Date} modification time. */\r\n    this.mtime;\r\n    /** @type {number} extra flags. */\r\n    this.xfl;\r\n    /** @type {number} operating system number. */\r\n    this.os;\r\n    /** @type {number} CRC-16 value for FHCRC flag. */\r\n    this.crc16;\r\n    /** @type {number} extra length. */\r\n    this.xlen;\r\n    /** @type {number} CRC-32 value for verification. */\r\n    this.crc32;\r\n    /** @type {number} input size modulo 32 value. */\r\n    this.isize;\r\n    /** @type {string} filename. */\r\n    this.name;\r\n    /** @type {string} comment. */\r\n    this.comment;\r\n    /** @type {!(Uint8Array|Array.<number>)} */\r\n    this.data;\r\n  };\r\n\r\n  GunzipMember.prototype.getName = function() {\r\n    return this.name;\r\n  };\r\n\r\n  GunzipMember.prototype.getData = function() {\r\n    return this.data;\r\n  };\r\n\r\n  GunzipMember.prototype.getMtime = function() {\r\n    return this.mtime;\r\n  }\r\n\r\n  return Zlib.GunzipMembe = GunzipMember;\r\n\r\n});\r\n\r\n\ndefine('skylark-zlib/Gunzip',[\r\n  \"./zlib\",\r\n  \"./crc32\",\r\n  \"./Gzip\",\r\n  \"./RawInflate\",\r\n  \"./GunzipMember\"\r\n],function(Zlib,CRC32,Gzip,RawInflate,GunzipMember) {\r\n  /**\r\n   * @fileoverview GZIP (RFC1952) 展開コンテナ実装.\r\n   */\r\n\r\n\r\n   const USE_TYPEDARRAY = true;\r\n\r\n  /**\r\n   * @constructor\r\n   * @param {!(Array|Uint8Array)} input input buffer.\r\n   * @param {Object=} opt_params option parameters.\r\n   */\r\n  var Gunzip = function(input, opt_params) {\r\n    /** @type {!(Array.<number>|Uint8Array)} input buffer. */\r\n    this.input = input;\r\n    /** @type {number} input buffer pointer. */\r\n    this.ip = 0;\r\n    /** @type {Array.<GunzipMember>} */\r\n    this.member = [];\r\n    /** @type {boolean} */\r\n    this.decompressed = false;\r\n  };\r\n\r\n  /**\r\n   * @return {Array.<GunzipMember>}\r\n   */\r\n  Gunzip.prototype.getMembers = function() {\r\n    if (!this.decompressed) {\r\n      this.decompress();\r\n    }\r\n\r\n    return this.member.slice();\r\n  };\r\n\r\n  /**\r\n   * inflate gzip data.\r\n   * @return {!(Array.<number>|Uint8Array)} inflated buffer.\r\n   */\r\n  Gunzip.prototype.decompress = function() {\r\n    /** @type {number} input length. */\r\n    var il = this.input.length;\r\n\r\n    while (this.ip < il) {\r\n      this.decodeMember();\r\n    }\r\n\r\n    this.decompressed = true;\r\n\r\n    return this.concatMember();\r\n  };\r\n\r\n  /**\r\n   * decode gzip member.\r\n   */\r\n  Gunzip.prototype.decodeMember = function() {\r\n    /** @type {GunzipMember} */\r\n    var member = new GunzipMember();\r\n    /** @type {number} */\r\n    var isize;\r\n    /** @type {RawInflate} RawInflate implementation. */\r\n    var rawinflate;\r\n    /** @type {!(Array.<number>|Uint8Array)} inflated data. */\r\n    var inflated;\r\n    /** @type {number} inflate size */\r\n    var inflen;\r\n    /** @type {number} character code */\r\n    var c;\r\n    /** @type {number} character index in string. */\r\n    var ci;\r\n    /** @type {Array.<string>} character array. */\r\n    var str;\r\n    /** @type {number} modification time. */\r\n    var mtime;\r\n    /** @type {number} */\r\n    var crc32;\r\n\r\n    var input = this.input;\r\n    var ip = this.ip;\r\n\r\n    member.id1 = input[ip++];\r\n    member.id2 = input[ip++];\r\n\r\n    // check signature\r\n    if (member.id1 !== 0x1f || member.id2 !== 0x8b) {\r\n      throw new Error('invalid file signature:' + member.id1 + ',' + member.id2);\r\n    }\r\n\r\n    // check compression method\r\n    member.cm = input[ip++];\r\n    switch (member.cm) {\r\n      case 8: /* XXX: use Zlib const */\r\n        break;\r\n      default:\r\n        throw new Error('unknown compression method: ' + member.cm);\r\n    }\r\n\r\n    // flags\r\n    member.flg = input[ip++];\r\n\r\n    // modification time\r\n    mtime = (input[ip++])       |\r\n            (input[ip++] << 8)  |\r\n            (input[ip++] << 16) |\r\n            (input[ip++] << 24);\r\n    member.mtime = new Date(mtime * 1000);\r\n\r\n    // extra flags\r\n    member.xfl = input[ip++];\r\n\r\n    // operating system\r\n    member.os = input[ip++];\r\n\r\n    // extra\r\n    if ((member.flg & Gzip.FlagsMask.FEXTRA) > 0) {\r\n      member.xlen = input[ip++] | (input[ip++] << 8);\r\n      ip = this.decodeSubField(ip, member.xlen);\r\n    }\r\n\r\n    // fname\r\n    if ((member.flg & Gzip.FlagsMask.FNAME) > 0) {\r\n      for(str = [], ci = 0; (c = input[ip++]) > 0;) {\r\n        str[ci++] = String.fromCharCode(c);\r\n      }\r\n      member.name = str.join('');\r\n    }\r\n\r\n    // fcomment\r\n    if ((member.flg & Gzip.FlagsMask.FCOMMENT) > 0) {\r\n      for(str = [], ci = 0; (c = input[ip++]) > 0;) {\r\n        str[ci++] = String.fromCharCode(c);\r\n      }\r\n      member.comment = str.join('');\r\n    }\r\n\r\n    // fhcrc\r\n    if ((member.flg & Gzip.FlagsMask.FHCRC) > 0) {\r\n      member.crc16 = CRC32.calc(input, 0, ip) & 0xffff;\r\n      if (member.crc16 !== (input[ip++] | (input[ip++] << 8))) {\r\n        throw new Error('invalid header crc16');\r\n      }\r\n    }\r\n\r\n    // isize を事前に取得すると展開後のサイズが分かるため、\r\n    // inflate処理のバッファサイズが事前に分かり、高速になる\r\n    isize = (input[input.length - 4])       | (input[input.length - 3] << 8) |\r\n            (input[input.length - 2] << 16) | (input[input.length - 1] << 24);\r\n\r\n    // isize の妥当性チェック\r\n    // ハフマン符号では最小 2-bit のため、最大で 1/4 になる\r\n    // LZ77 符号では 長さと距離 2-Byte で最大 258-Byte を表現できるため、\r\n    // 1/128 になるとする\r\n    // ここから入力バッファの残りが isize の 512 倍以上だったら\r\n    // サイズ指定のバッファ確保は行わない事とする\r\n    if (input.length - ip - /* CRC-32 */4 - /* ISIZE */4 < isize * 512) {\r\n      inflen = isize;\r\n    }\r\n\r\n    // compressed block\r\n    rawinflate = new RawInflate(input, {'index': ip, 'bufferSize': inflen});\r\n    member.data = inflated = rawinflate.decompress();\r\n    ip = rawinflate.ip;\r\n\r\n    // crc32\r\n    member.crc32 = crc32 =\r\n      ((input[ip++])       | (input[ip++] << 8) |\r\n       (input[ip++] << 16) | (input[ip++] << 24)) >>> 0;\r\n    if (CRC32.calc(inflated) !== crc32) {\r\n      throw new Error('invalid CRC-32 checksum: 0x' +\r\n          CRC32.calc(inflated).toString(16) + ' / 0x' + crc32.toString(16));\r\n    }\r\n\r\n    // input size\r\n    member.isize = isize =\r\n      ((input[ip++])       | (input[ip++] << 8) |\r\n       (input[ip++] << 16) | (input[ip++] << 24)) >>> 0;\r\n    if ((inflated.length & 0xffffffff) !== isize) {\r\n      throw new Error('invalid input size: ' +\r\n          (inflated.length & 0xffffffff) + ' / ' + isize);\r\n    }\r\n\r\n    this.member.push(member);\r\n    this.ip = ip;\r\n  };\r\n\r\n  /**\r\n   * サブフィールドのデコード\r\n   * XXX: 現在は何もせずスキップする\r\n   */\r\n  Gunzip.prototype.decodeSubField = function(ip, length) {\r\n    return ip + length;\r\n  };\r\n\r\n  /**\r\n   * @return {!(Array.<number>|Uint8Array)}\r\n   */\r\n  Gunzip.prototype.concatMember = function() {\r\n    /** @type {Array.<GunzipMember>} */\r\n    var member = this.member;\r\n    /** @type {number} */\r\n    var i;\r\n    /** @type {number} */\r\n    var il;\r\n    /** @type {number} */\r\n    var p = 0;\r\n    /** @type {number} */\r\n    var size = 0;\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var buffer;\r\n\r\n    for (i = 0, il = member.length; i < il; ++i) {\r\n      size += member[i].data.length;\r\n    }\r\n\r\n    if (USE_TYPEDARRAY) {\r\n      buffer = new Uint8Array(size);\r\n      for (i = 0; i < il; ++i) {\r\n        buffer.set(member[i].data, p);\r\n        p += member[i].data.length;\r\n      }\r\n    } else {\r\n      buffer = [];\r\n      for (i = 0; i < il; ++i) {\r\n        buffer[i] = member[i].data;\r\n      }\r\n      buffer = Array.prototype.concat.apply([], buffer);\r\n    }\r\n\r\n    return buffer;\r\n  };\r\n\r\n  return Zlib.Gunzip = Gunzip;\r\n});\r\n\ndefine('skylark-zlib/huffman',[\r\n  \"./zlib\"\r\n],function(Zlib) {\r\n  const USE_TYPEDARRAY = true;\r\n\r\n  var Huffman = {};\r\n\r\n  /**\r\n   * build huffman table from length list.\r\n   * @param {!(Array.<number>|Uint8Array)} lengths length list.\r\n   * @return {!Array} huffman table.\r\n   */\r\n  Huffman.buildHuffmanTable = function(lengths) {\r\n    /** @type {number} length list size. */\r\n    var listSize = lengths.length;\r\n    /** @type {number} max code length for table size. */\r\n    var maxCodeLength = 0;\r\n    /** @type {number} min code length for table size. */\r\n    var minCodeLength = Number.POSITIVE_INFINITY;\r\n    /** @type {number} table size. */\r\n    var size;\r\n    /** @type {!(Array|Uint8Array)} huffman code table. */\r\n    var table;\r\n    /** @type {number} bit length. */\r\n    var bitLength;\r\n    /** @type {number} huffman code. */\r\n    var code;\r\n    /**\r\n     * サイズが 2^maxlength 個のテーブルを埋めるためのスキップ長.\r\n     * @type {number} skip length for table filling.\r\n     */\r\n    var skip;\r\n    /** @type {number} reversed code. */\r\n    var reversed;\r\n    /** @type {number} reverse temp. */\r\n    var rtemp;\r\n    /** @type {number} loop counter. */\r\n    var i;\r\n    /** @type {number} loop limit. */\r\n    var il;\r\n    /** @type {number} loop counter. */\r\n    var j;\r\n    /** @type {number} table value. */\r\n    var value;\r\n\r\n    // Math.max は遅いので最長の値は for-loop で取得する\r\n    for (i = 0, il = listSize; i < il; ++i) {\r\n      if (lengths[i] > maxCodeLength) {\r\n        maxCodeLength = lengths[i];\r\n      }\r\n      if (lengths[i] < minCodeLength) {\r\n        minCodeLength = lengths[i];\r\n      }\r\n    }\r\n\r\n    size = 1 << maxCodeLength;\r\n    table = new (USE_TYPEDARRAY ? Uint32Array : Array)(size);\r\n\r\n    // ビット長の短い順からハフマン符号を割り当てる\r\n    for (bitLength = 1, code = 0, skip = 2; bitLength <= maxCodeLength;) {\r\n      for (i = 0; i < listSize; ++i) {\r\n        if (lengths[i] === bitLength) {\r\n          // ビットオーダーが逆になるためビット長分並びを反転する\r\n          for (reversed = 0, rtemp = code, j = 0; j < bitLength; ++j) {\r\n            reversed = (reversed << 1) | (rtemp & 1);\r\n            rtemp >>= 1;\r\n          }\r\n\r\n          // 最大ビット長をもとにテーブルを作るため、\r\n          // 最大ビット長以外では 0 / 1 どちらでも良い箇所ができる\r\n          // そのどちらでも良い場所は同じ値で埋めることで\r\n          // 本来のビット長以上のビット数取得しても問題が起こらないようにする\r\n          value = (bitLength << 16) | i;\r\n          for (j = reversed; j < size; j += skip) {\r\n            table[j] = value;\r\n          }\r\n\r\n          ++code;\r\n        }\r\n      }\r\n\r\n      // 次のビット長へ\r\n      ++bitLength;\r\n      code <<= 1;\r\n      skip <<= 1;\r\n    }\r\n\r\n    return [table, maxCodeLength, minCodeLength];\r\n  };\r\n\r\n  return Zlib.Huffman = Huffman;\r\n});\r\n\r\n\ndefine('skylark-zlib/Inflate',[\r\n  \"./zlib\",\r\n  \"./adler32\",\r\n  \"./RawInflate\"\r\n],function(\r\n  Zlib,\r\n  Adler32,\r\n  RawInflate\r\n) {\r\n  /**\r\n   * @constructor\r\n   * @param {!(Uint8Array|Array)} input deflated buffer.\r\n   * @param {Object=} opt_params option parameters.\r\n   *\r\n   * opt_params は以下のプロパティを指定する事ができます。\r\n   *   - index: input buffer の deflate コンテナの開始位置.\r\n   *   - blockSize: バッファのブロックサイズ.\r\n   *   - verify: 伸張が終わった後 adler-32 checksum の検証を行うか.\r\n   *   - bufferType: Inflate.BufferType の値によってバッファの管理方法を指定する.\r\n   *       Inflate.BufferType は RawInflate.BufferType のエイリアス.\r\n   */\r\n  var Inflate = function(input, opt_params) {\r\n    /** @type {number} */\r\n    var bufferSize;\r\n    /** @type {Inflate.BufferType} */\r\n    var bufferType;\r\n    /** @type {number} */\r\n    var cmf;\r\n    /** @type {number} */\r\n    var flg;\r\n\r\n    /** @type {!(Uint8Array|Array)} */\r\n    this.input = input;\r\n    /** @type {number} */\r\n    this.ip = 0;\r\n    /** @type {RawInflate} */\r\n    this.rawinflate;\r\n    /** @type {(boolean|undefined)} verify flag. */\r\n    this.verify;\r\n\r\n    // option parameters\r\n    if (opt_params || !(opt_params = {})) {\r\n      if (opt_params['index']) {\r\n        this.ip = opt_params['index'];\r\n      }\r\n      if (opt_params['verify']) {\r\n        this.verify = opt_params['verify'];\r\n      }\r\n    }\r\n\r\n    // Compression Method and Flags\r\n    cmf = input[this.ip++];\r\n    flg = input[this.ip++];\r\n\r\n    // compression method\r\n    switch (cmf & 0x0f) {\r\n      case Zlib.CompressionMethod.DEFLATE:\r\n        this.method = Zlib.CompressionMethod.DEFLATE;\r\n        break;\r\n      default:\r\n        throw new Error('unsupported compression method');\r\n    }\r\n\r\n    // fcheck\r\n    if (((cmf << 8) + flg) % 31 !== 0) {\r\n      throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);\r\n    }\r\n\r\n    // fdict (not supported)\r\n    if (flg & 0x20) {\r\n      throw new Error('fdict flag is not supported');\r\n    }\r\n\r\n    // RawInflate\r\n    this.rawinflate = new RawInflate(input, {\r\n      'index': this.ip,\r\n      'bufferSize': opt_params['bufferSize'],\r\n      'bufferType': opt_params['bufferType'],\r\n      'resize': opt_params['resize']\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @enum {number}\r\n   */\r\n  Inflate.BufferType = RawInflate.BufferType;\r\n\r\n  /**\r\n   * decompress.\r\n   * @return {!(Uint8Array|Array)} inflated buffer.\r\n   */\r\n  Inflate.prototype.decompress = function() {\r\n    /** @type {!(Array|Uint8Array)} input buffer. */\r\n    var input = this.input;\r\n    /** @type {!(Uint8Array|Array)} inflated buffer. */\r\n    var buffer;\r\n    /** @type {number} adler-32 checksum */\r\n    var adler32;\r\n\r\n    buffer = this.rawinflate.decompress();\r\n    this.ip = this.rawinflate.ip;\r\n\r\n    // verify adler-32\r\n    if (this.verify) {\r\n      adler32 = (\r\n        input[this.ip++] << 24 | input[this.ip++] << 16 |\r\n        input[this.ip++] << 8 | input[this.ip++]\r\n      ) >>> 0;\r\n\r\n      if (adler32 !== Adler32(buffer)) {\r\n        throw new Error('invalid adler-32 checksum');\r\n      }\r\n    }\r\n\r\n    return buffer;\r\n  };\r\n\r\n  return Zlib.Inflate = Inflate;\r\n});\r\n\ndefine('skylark-zlib/RawInflateStream',[\r\n  \"./zlib\",\r\n  \"./huffman\"\r\n],function(Zlib,Huffman) {\r\n  const USE_TYPEDARRAY = true;\r\n\r\n  //-----------------------------------------------------------------------------\r\n\r\n  /** @define {number} buffer block size. */\r\n  var ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE = 0x8000;\r\n\r\n  //-----------------------------------------------------------------------------\r\n\r\n  var buildHuffmanTable = Huffman.buildHuffmanTable;\r\n\r\n  /**\r\n   * @param {!(Uint8Array|Array.<number>)} input input buffer.\r\n   * @param {number} ip input buffer pointer.\r\n   * @param {number=} opt_buffersize buffer block size.\r\n   * @constructor\r\n   */\r\n  var RawInflateStream = function(input, ip, opt_buffersize) {\r\n    /** @type {!Array.<(Array|Uint8Array)>} */\r\n    this.blocks = [];\r\n    /** @type {number} block size. */\r\n    this.bufferSize =\r\n      opt_buffersize ? opt_buffersize : ZLIB_STREAM_RAW_INFLATE_BUFFER_SIZE;\r\n    /** @type {!number} total output buffer pointer. */\r\n    this.totalpos = 0;\r\n    /** @type {!number} input buffer pointer. */\r\n    this.ip = ip === void 0 ? 0 : ip;\r\n    /** @type {!number} bit stream reader buffer. */\r\n    this.bitsbuf = 0;\r\n    /** @type {!number} bit stream reader buffer size. */\r\n    this.bitsbuflen = 0;\r\n    /** @type {!(Array|Uint8Array)} input buffer. */\r\n    this.input = USE_TYPEDARRAY ? new Uint8Array(input) : input;\r\n    /** @type {!(Uint8Array|Array)} output buffer. */\r\n    this.output = new (USE_TYPEDARRAY ? Uint8Array : Array)(this.bufferSize);\r\n    /** @type {!number} output buffer pointer. */\r\n    this.op = 0;\r\n    /** @type {boolean} is final block flag. */\r\n    this.bfinal = false;\r\n    /** @type {number} uncompressed block length. */\r\n    this.blockLength;\r\n    /** @type {boolean} resize flag for memory size optimization. */\r\n    this.resize = false;\r\n    /** @type {Array} */\r\n    this.litlenTable;\r\n    /** @type {Array} */\r\n    this.distTable;\r\n    /** @type {number} */\r\n    this.sp = 0; // stream pointer\r\n    /** @type {RawInflateStream.Status} */\r\n    this.status = RawInflateStream.Status.INITIALIZED;\r\n\r\n    //\r\n    // backup\r\n    //\r\n    /** @type {!number} */\r\n    this.ip_;\r\n    /** @type {!number} */\r\n    this.bitsbuflen_;\r\n    /** @type {!number} */\r\n    this.bitsbuf_;\r\n  };\r\n\r\n  /**\r\n   * @enum {number}\r\n   */\r\n  RawInflateStream.BlockType = {\r\n    UNCOMPRESSED: 0,\r\n    FIXED: 1,\r\n    DYNAMIC: 2\r\n  };\r\n\r\n  /**\r\n   * @enum {number}\r\n   */\r\n  RawInflateStream.Status = {\r\n    INITIALIZED: 0,\r\n    BLOCK_HEADER_START: 1,\r\n    BLOCK_HEADER_END: 2,\r\n    BLOCK_BODY_START: 3,\r\n    BLOCK_BODY_END: 4,\r\n    DECODE_BLOCK_START: 5,\r\n    DECODE_BLOCK_END: 6\r\n  };\r\n\r\n  /**\r\n   * decompress.\r\n   * @return {!(Uint8Array|Array)} inflated buffer.\r\n   */\r\n  RawInflateStream.prototype.decompress = function(newInput, ip) {\r\n    /** @type {boolean} */\r\n    var stop = false;\r\n\r\n    if (newInput !== void 0) {\r\n      this.input = newInput;\r\n    }\r\n\r\n    if (ip !== void 0) {\r\n      this.ip = ip;\r\n    }\r\n\r\n    // decompress\r\n    while (!stop) {\r\n      switch (this.status) {\r\n        // block header\r\n        case RawInflateStream.Status.INITIALIZED:\r\n        case RawInflateStream.Status.BLOCK_HEADER_START:\r\n          if (this.readBlockHeader() < 0) {\r\n            stop = true;\r\n          }\r\n          break;\r\n        // block body\r\n        case RawInflateStream.Status.BLOCK_HEADER_END: /* FALLTHROUGH */\r\n        case RawInflateStream.Status.BLOCK_BODY_START:\r\n          switch(this.currentBlockType) {\r\n            case RawInflateStream.BlockType.UNCOMPRESSED:\r\n              if (this.readUncompressedBlockHeader() < 0) {\r\n                stop = true;\r\n              }\r\n              break;\r\n            case RawInflateStream.BlockType.FIXED:\r\n              if (this.parseFixedHuffmanBlock() < 0) {\r\n                stop = true;\r\n              }\r\n              break;\r\n            case RawInflateStream.BlockType.DYNAMIC:\r\n              if (this.parseDynamicHuffmanBlock() < 0) {\r\n                stop = true;\r\n              }\r\n              break;\r\n          }\r\n          break;\r\n        // decode data\r\n        case RawInflateStream.Status.BLOCK_BODY_END:\r\n        case RawInflateStream.Status.DECODE_BLOCK_START:\r\n          switch(this.currentBlockType) {\r\n            case RawInflateStream.BlockType.UNCOMPRESSED:\r\n              if (this.parseUncompressedBlock() < 0) {\r\n                stop = true;\r\n              }\r\n              break;\r\n            case RawInflateStream.BlockType.FIXED: /* FALLTHROUGH */\r\n            case RawInflateStream.BlockType.DYNAMIC:\r\n              if (this.decodeHuffman() < 0) {\r\n                stop = true;\r\n              }\r\n              break;\r\n          }\r\n          break;\r\n        case RawInflateStream.Status.DECODE_BLOCK_END:\r\n          if (this.bfinal) {\r\n            stop = true;\r\n          } else {\r\n            this.status = RawInflateStream.Status.INITIALIZED;\r\n          }\r\n          break;\r\n      }\r\n    }\r\n\r\n    return this.concatBuffer();\r\n  };\r\n\r\n  /**\r\n   * @const\r\n   * @type {number} max backward length for LZ77.\r\n   */\r\n  RawInflateStream.MaxBackwardLength = 32768;\r\n\r\n  /**\r\n   * @const\r\n   * @type {number} max copy length for LZ77.\r\n   */\r\n  RawInflateStream.MaxCopyLength = 258;\r\n\r\n  /**\r\n   * huffman order\r\n   * @const\r\n   * @type {!(Array.<number>|Uint8Array)}\r\n   */\r\n  RawInflateStream.Order = (function(table) {\r\n    return USE_TYPEDARRAY ? new Uint16Array(table) : table;\r\n  })([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\r\n\r\n  /**\r\n   * huffman length code table.\r\n   * @const\r\n   * @type {!(Array.<number>|Uint16Array)}\r\n   */\r\n  RawInflateStream.LengthCodeTable = (function(table) {\r\n    return USE_TYPEDARRAY ? new Uint16Array(table) : table;\r\n  })([\r\n    0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,\r\n    0x000d, 0x000f, 0x0011, 0x0013, 0x0017, 0x001b, 0x001f, 0x0023, 0x002b,\r\n    0x0033, 0x003b, 0x0043, 0x0053, 0x0063, 0x0073, 0x0083, 0x00a3, 0x00c3,\r\n    0x00e3, 0x0102, 0x0102, 0x0102\r\n  ]);\r\n\r\n  /**\r\n   * huffman length extra-bits table.\r\n   * @const\r\n   * @type {!(Array.<number>|Uint8Array)}\r\n   */\r\n  RawInflateStream.LengthExtraTable = (function(table) {\r\n    return USE_TYPEDARRAY ? new Uint8Array(table) : table;\r\n  })([\r\n    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5,\r\n    5, 5, 0, 0, 0\r\n  ]);\r\n\r\n  /**\r\n   * huffman dist code table.\r\n   * @const\r\n   * @type {!(Array.<number>|Uint16Array)}\r\n   */\r\n  RawInflateStream.DistCodeTable = (function(table) {\r\n    return USE_TYPEDARRAY ? new Uint16Array(table) : table;\r\n  })([\r\n    0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0007, 0x0009, 0x000d, 0x0011,\r\n    0x0019, 0x0021, 0x0031, 0x0041, 0x0061, 0x0081, 0x00c1, 0x0101, 0x0181,\r\n    0x0201, 0x0301, 0x0401, 0x0601, 0x0801, 0x0c01, 0x1001, 0x1801, 0x2001,\r\n    0x3001, 0x4001, 0x6001\r\n  ]);\r\n\r\n  /**\r\n   * huffman dist extra-bits table.\r\n   * @const\r\n   * @type {!(Array.<number>|Uint8Array)}\r\n   */\r\n  RawInflateStream.DistExtraTable = (function(table) {\r\n    return USE_TYPEDARRAY ? new Uint8Array(table) : table;\r\n  })([\r\n    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11,\r\n    11, 12, 12, 13, 13\r\n  ]);\r\n\r\n  /**\r\n   * fixed huffman length code table\r\n   * @const\r\n   * @type {!Array}\r\n   */\r\n  RawInflateStream.FixedLiteralLengthTable = (function(table) {\r\n    return table;\r\n  })((function() {\r\n    var lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(288);\r\n    var i, il;\r\n\r\n    for (i = 0, il = lengths.length; i < il; ++i) {\r\n      lengths[i] =\r\n        (i <= 143) ? 8 :\r\n        (i <= 255) ? 9 :\r\n        (i <= 279) ? 7 :\r\n        8;\r\n    }\r\n\r\n    return buildHuffmanTable(lengths);\r\n  })());\r\n\r\n  /**\r\n   * fixed huffman distance code table\r\n   * @const\r\n   * @type {!Array}\r\n   */\r\n  RawInflateStream.FixedDistanceTable = (function(table) {\r\n    return table;\r\n  })((function() {\r\n    var lengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(30);\r\n    var i, il;\r\n\r\n    for (i = 0, il = lengths.length; i < il; ++i) {\r\n      lengths[i] = 5;\r\n    }\r\n\r\n    return buildHuffmanTable(lengths);\r\n  })());\r\n\r\n  /**\r\n   * parse deflated block.\r\n   */\r\n  RawInflateStream.prototype.readBlockHeader = function() {\r\n    /** @type {number} header */\r\n    var hdr;\r\n\r\n    this.status = RawInflateStream.Status.BLOCK_HEADER_START;\r\n\r\n    this.save_();\r\n    if ((hdr = this.readBits(3)) < 0) {\r\n      this.restore_();\r\n      return -1;\r\n    }\r\n\r\n    // BFINAL\r\n    if (hdr & 0x1) {\r\n      this.bfinal = true;\r\n    }\r\n\r\n    // BTYPE\r\n    hdr >>>= 1;\r\n    switch (hdr) {\r\n      case 0: // uncompressed\r\n        this.currentBlockType = RawInflateStream.BlockType.UNCOMPRESSED;\r\n        break;\r\n      case 1: // fixed huffman\r\n        this.currentBlockType = RawInflateStream.BlockType.FIXED;\r\n        break;\r\n      case 2: // dynamic huffman\r\n        this.currentBlockType = RawInflateStream.BlockType.DYNAMIC;\r\n        break;\r\n      default: // reserved or other\r\n        throw new Error('unknown BTYPE: ' + hdr);\r\n    }\r\n\r\n    this.status = RawInflateStream.Status.BLOCK_HEADER_END;\r\n  };\r\n\r\n  /**\r\n   * read inflate bits\r\n   * @param {number} length bits length.\r\n   * @return {number} read bits.\r\n   */\r\n  RawInflateStream.prototype.readBits = function(length) {\r\n    var bitsbuf = this.bitsbuf;\r\n    var bitsbuflen = this.bitsbuflen;\r\n    var input = this.input;\r\n    var ip = this.ip;\r\n\r\n    /** @type {number} input and output byte. */\r\n    var octet;\r\n\r\n    // not enough buffer\r\n    while (bitsbuflen < length) {\r\n      // input byte\r\n      if (input.length <= ip) {\r\n        return -1;\r\n      }\r\n      octet = input[ip++];\r\n\r\n      // concat octet\r\n      bitsbuf |= octet << bitsbuflen;\r\n      bitsbuflen += 8;\r\n    }\r\n\r\n    // output byte\r\n    octet = bitsbuf & /* MASK */ ((1 << length) - 1);\r\n    bitsbuf >>>= length;\r\n    bitsbuflen -= length;\r\n\r\n    this.bitsbuf = bitsbuf;\r\n    this.bitsbuflen = bitsbuflen;\r\n    this.ip = ip;\r\n\r\n    return octet;\r\n  };\r\n\r\n  /**\r\n   * read huffman code using table\r\n   * @param {Array} table huffman code table.\r\n   * @return {number} huffman code.\r\n   */\r\n  RawInflateStream.prototype.readCodeByTable = function(table) {\r\n    var bitsbuf = this.bitsbuf;\r\n    var bitsbuflen = this.bitsbuflen;\r\n    var input = this.input;\r\n    var ip = this.ip;\r\n\r\n    /** @type {!(Array|Uint8Array)} huffman code table */\r\n    var codeTable = table[0];\r\n    /** @type {number} */\r\n    var maxCodeLength = table[1];\r\n    /** @type {number} input byte */\r\n    var octet;\r\n    /** @type {number} code length & code (16bit, 16bit) */\r\n    var codeWithLength;\r\n    /** @type {number} code bits length */\r\n    var codeLength;\r\n\r\n    // not enough buffer\r\n    while (bitsbuflen < maxCodeLength) {\r\n      if (input.length <= ip) {\r\n        return -1;\r\n      }\r\n      octet = input[ip++];\r\n      bitsbuf |= octet << bitsbuflen;\r\n      bitsbuflen += 8;\r\n    }\r\n\r\n    // read max length\r\n    codeWithLength = codeTable[bitsbuf & ((1 << maxCodeLength) - 1)];\r\n    codeLength = codeWithLength >>> 16;\r\n\r\n    if (codeLength > bitsbuflen) {\r\n      throw new Error('invalid code length: ' + codeLength);\r\n    }\r\n\r\n    this.bitsbuf = bitsbuf >> codeLength;\r\n    this.bitsbuflen = bitsbuflen - codeLength;\r\n    this.ip = ip;\r\n\r\n    return codeWithLength & 0xffff;\r\n  };\r\n\r\n  /**\r\n   * read uncompressed block header\r\n   */\r\n  RawInflateStream.prototype.readUncompressedBlockHeader = function() {\r\n    /** @type {number} block length */\r\n    var len;\r\n    /** @type {number} number for check block length */\r\n    var nlen;\r\n\r\n    var input = this.input;\r\n    var ip = this.ip;\r\n\r\n    this.status = RawInflateStream.Status.BLOCK_BODY_START;\r\n\r\n    if (ip + 4 >= input.length) {\r\n      return -1;\r\n    }\r\n\r\n    len = input[ip++] | (input[ip++] << 8);\r\n    nlen = input[ip++] | (input[ip++] << 8);\r\n\r\n    // check len & nlen\r\n    if (len === ~nlen) {\r\n      throw new Error('invalid uncompressed block header: length verify');\r\n    }\r\n\r\n    // skip buffered header bits\r\n    this.bitsbuf = 0;\r\n    this.bitsbuflen = 0;\r\n\r\n    this.ip = ip;\r\n    this.blockLength = len;\r\n    this.status = RawInflateStream.Status.BLOCK_BODY_END;\r\n  };\r\n\r\n  /**\r\n   * parse uncompressed block.\r\n   */\r\n  RawInflateStream.prototype.parseUncompressedBlock = function() {\r\n    var input = this.input;\r\n    var ip = this.ip;\r\n    var output = this.output;\r\n    var op = this.op;\r\n    var len = this.blockLength;\r\n\r\n    this.status = RawInflateStream.Status.DECODE_BLOCK_START;\r\n\r\n    // copy\r\n    // XXX: とりあえず素直にコピー\r\n    while (len--) {\r\n      if (op === output.length) {\r\n        output = this.expandBuffer({fixRatio: 2});\r\n      }\r\n\r\n      // not enough input buffer\r\n      if (ip >= input.length) {\r\n        this.ip = ip;\r\n        this.op = op;\r\n        this.blockLength = len + 1; // コピーしてないので戻す\r\n        return -1;\r\n      }\r\n\r\n      output[op++] = input[ip++];\r\n    }\r\n\r\n    if (len < 0) {\r\n      this.status = RawInflateStream.Status.DECODE_BLOCK_END;\r\n    }\r\n\r\n    this.ip = ip;\r\n    this.op = op;\r\n\r\n    return 0;\r\n  };\r\n\r\n  /**\r\n   * parse fixed huffman block.\r\n   */\r\n  RawInflateStream.prototype.parseFixedHuffmanBlock = function() {\r\n    this.status = RawInflateStream.Status.BLOCK_BODY_START;\r\n\r\n    this.litlenTable = RawInflateStream.FixedLiteralLengthTable;\r\n    this.distTable = RawInflateStream.FixedDistanceTable;\r\n\r\n    this.status = RawInflateStream.Status.BLOCK_BODY_END;\r\n\r\n    return 0;\r\n  };\r\n\r\n  /**\r\n   * オブジェクトのコンテキストを別のプロパティに退避する.\r\n   * @private\r\n   */\r\n  RawInflateStream.prototype.save_ = function() {\r\n    this.ip_ = this.ip;\r\n    this.bitsbuflen_ = this.bitsbuflen;\r\n    this.bitsbuf_ = this.bitsbuf;\r\n  };\r\n\r\n  /**\r\n   * 別のプロパティに退避したコンテキストを復元する.\r\n   * @private\r\n   */\r\n  RawInflateStream.prototype.restore_ = function() {\r\n    this.ip = this.ip_;\r\n    this.bitsbuflen = this.bitsbuflen_;\r\n    this.bitsbuf = this.bitsbuf_;\r\n  };\r\n\r\n  /**\r\n   * parse dynamic huffman block.\r\n   */\r\n  RawInflateStream.prototype.parseDynamicHuffmanBlock = function() {\r\n    /** @type {number} number of literal and length codes. */\r\n    var hlit;\r\n    /** @type {number} number of distance codes. */\r\n    var hdist;\r\n    /** @type {number} number of code lengths. */\r\n    var hclen;\r\n    /** @type {!(Uint8Array|Array)} code lengths. */\r\n    var codeLengths =\r\n      new (USE_TYPEDARRAY ? Uint8Array : Array)(RawInflateStream.Order.length);\r\n    /** @type {!Array} code lengths table. */\r\n    var codeLengthsTable;\r\n    /** @type {!(Uint32Array|Array)} literal and length code lengths. */\r\n    var litlenLengths;\r\n    /** @type {!(Uint32Array|Array)} distance code lengths. */\r\n    var distLengths;\r\n\r\n    this.status = RawInflateStream.Status.BLOCK_BODY_START;\r\n\r\n    this.save_();\r\n    hlit = this.readBits(5) + 257;\r\n    hdist = this.readBits(5) + 1;\r\n    hclen = this.readBits(4) + 4;\r\n    if (hlit < 0 || hdist < 0 || hclen < 0) {\r\n      this.restore_();\r\n      return -1;\r\n    }\r\n\r\n    try {\r\n      parseDynamicHuffmanBlockImpl.call(this);\r\n    } catch(e) {\r\n      this.restore_();\r\n      return -1;\r\n    }\r\n\r\n    function parseDynamicHuffmanBlockImpl() {\r\n      /** @type {number} */\r\n      var bits;\r\n      var code;\r\n      var prev = 0;\r\n      var repeat;\r\n      /** @type {!(Uint8Array|Array.<number>)} code length table. */\r\n      var lengthTable;\r\n      /** @type {number} loop counter. */\r\n      var i;\r\n      /** @type {number} loop limit. */\r\n      var il;\r\n\r\n      // decode code lengths\r\n      for (i = 0; i < hclen; ++i) {\r\n        if ((bits = this.readBits(3)) < 0) {\r\n          throw new Error('not enough input');\r\n        }\r\n        codeLengths[RawInflateStream.Order[i]] = bits;\r\n      }\r\n\r\n      // decode length table\r\n      codeLengthsTable = buildHuffmanTable(codeLengths);\r\n      lengthTable = new (USE_TYPEDARRAY ? Uint8Array : Array)(hlit + hdist);\r\n      for (i = 0, il = hlit + hdist; i < il;) {\r\n        code = this.readCodeByTable(codeLengthsTable);\r\n        if (code < 0) {\r\n          throw new Error('not enough input');\r\n        }\r\n        switch (code) {\r\n          case 16:\r\n            if ((bits = this.readBits(2)) < 0) {\r\n              throw new Error('not enough input');\r\n            }\r\n            repeat = 3 + bits;\r\n            while (repeat--) { lengthTable[i++] = prev; }\r\n            break;\r\n          case 17:\r\n            if ((bits = this.readBits(3)) < 0) {\r\n              throw new Error('not enough input');\r\n            }\r\n            repeat = 3 + bits;\r\n            while (repeat--) { lengthTable[i++] = 0; }\r\n            prev = 0;\r\n            break;\r\n          case 18:\r\n            if ((bits = this.readBits(7)) < 0) {\r\n              throw new Error('not enough input');\r\n            }\r\n            repeat = 11 + bits;\r\n            while (repeat--) { lengthTable[i++] = 0; }\r\n            prev = 0;\r\n            break;\r\n          default:\r\n            lengthTable[i++] = code;\r\n            prev = code;\r\n            break;\r\n        }\r\n      }\r\n\r\n      // literal and length code\r\n      litlenLengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(hlit);\r\n\r\n      // distance code\r\n      distLengths = new (USE_TYPEDARRAY ? Uint8Array : Array)(hdist);\r\n\r\n      this.litlenTable = USE_TYPEDARRAY\r\n        ? buildHuffmanTable(lengthTable.subarray(0, hlit))\r\n        : buildHuffmanTable(lengthTable.slice(0, hlit));\r\n      this.distTable = USE_TYPEDARRAY\r\n        ? buildHuffmanTable(lengthTable.subarray(hlit))\r\n        : buildHuffmanTable(lengthTable.slice(hlit));\r\n    }\r\n\r\n    this.status = RawInflateStream.Status.BLOCK_BODY_END;\r\n\r\n    return 0;\r\n  };\r\n\r\n  /**\r\n   * decode huffman code (dynamic)\r\n   * @return {(number|undefined)} -1 is error.\r\n   */\r\n  RawInflateStream.prototype.decodeHuffman = function() {\r\n    var output = this.output;\r\n    var op = this.op;\r\n\r\n    /** @type {number} huffman code. */\r\n    var code;\r\n    /** @type {number} table index. */\r\n    var ti;\r\n    /** @type {number} huffman code distination. */\r\n    var codeDist;\r\n    /** @type {number} huffman code length. */\r\n    var codeLength;\r\n\r\n    var litlen = this.litlenTable;\r\n    var dist = this.distTable;\r\n\r\n    var olength = output.length;\r\n    var bits;\r\n\r\n    this.status = RawInflateStream.Status.DECODE_BLOCK_START;\r\n\r\n    while (true) {\r\n      this.save_();\r\n\r\n      code = this.readCodeByTable(litlen);\r\n      if (code < 0) {\r\n        this.op = op;\r\n        this.restore_();\r\n        return -1;\r\n      }\r\n\r\n      if (code === 256) {\r\n        break;\r\n      }\r\n\r\n      // literal\r\n      if (code < 256) {\r\n        if (op === olength) {\r\n          output = this.expandBuffer();\r\n          olength = output.length;\r\n        }\r\n        output[op++] = code;\r\n\r\n        continue;\r\n      }\r\n\r\n      // length code\r\n      ti = code - 257;\r\n      codeLength = RawInflateStream.LengthCodeTable[ti];\r\n      if (RawInflateStream.LengthExtraTable[ti] > 0) {\r\n        bits = this.readBits(RawInflateStream.LengthExtraTable[ti]);\r\n        if (bits < 0) {\r\n          this.op = op;\r\n          this.restore_();\r\n          return -1;\r\n        }\r\n        codeLength += bits;\r\n      }\r\n\r\n      // dist code\r\n      code = this.readCodeByTable(dist);\r\n      if (code < 0) {\r\n        this.op = op;\r\n        this.restore_();\r\n        return -1;\r\n      }\r\n      codeDist = RawInflateStream.DistCodeTable[code];\r\n      if (RawInflateStream.DistExtraTable[code] > 0) {\r\n        bits = this.readBits(RawInflateStream.DistExtraTable[code]);\r\n        if (bits < 0) {\r\n          this.op = op;\r\n          this.restore_();\r\n          return -1;\r\n        }\r\n        codeDist += bits;\r\n      }\r\n\r\n      // lz77 decode\r\n      if (op + codeLength >= olength) {\r\n        output = this.expandBuffer();\r\n        olength = output.length;\r\n      }\r\n\r\n      while (codeLength--) {\r\n        output[op] = output[(op++) - codeDist];\r\n      }\r\n\r\n      // break\r\n      if (this.ip === this.input.length) {\r\n        this.op = op;\r\n        return -1;\r\n      }\r\n    }\r\n\r\n    while (this.bitsbuflen >= 8) {\r\n      this.bitsbuflen -= 8;\r\n      this.ip--;\r\n    }\r\n\r\n    this.op = op;\r\n    this.status = RawInflateStream.Status.DECODE_BLOCK_END;\r\n  };\r\n\r\n  /**\r\n   * expand output buffer. (dynamic)\r\n   * @param {Object=} opt_param option parameters.\r\n   * @return {!(Array|Uint8Array)} output buffer pointer.\r\n   */\r\n  RawInflateStream.prototype.expandBuffer = function(opt_param) {\r\n    /** @type {!(Array|Uint8Array)} store buffer. */\r\n    var buffer;\r\n    /** @type {number} expantion ratio. */\r\n    var ratio = (this.input.length / this.ip + 1) | 0;\r\n    /** @type {number} maximum number of huffman code. */\r\n    var maxHuffCode;\r\n    /** @type {number} new output buffer size. */\r\n    var newSize;\r\n    /** @type {number} max inflate size. */\r\n    var maxInflateSize;\r\n\r\n    var input = this.input;\r\n    var output = this.output;\r\n\r\n    if (opt_param) {\r\n      if (typeof opt_param.fixRatio === 'number') {\r\n        ratio = opt_param.fixRatio;\r\n      }\r\n      if (typeof opt_param.addRatio === 'number') {\r\n        ratio += opt_param.addRatio;\r\n      }\r\n    }\r\n\r\n    // calculate new buffer size\r\n    if (ratio < 2) {\r\n      maxHuffCode =\r\n        (input.length - this.ip) / this.litlenTable[2];\r\n      maxInflateSize = (maxHuffCode / 2 * 258) | 0;\r\n      newSize = maxInflateSize < output.length ?\r\n        output.length + maxInflateSize :\r\n        output.length << 1;\r\n    } else {\r\n      newSize = output.length * ratio;\r\n    }\r\n\r\n    // buffer expantion\r\n    if (USE_TYPEDARRAY) {\r\n      buffer = new Uint8Array(newSize);\r\n      buffer.set(output);\r\n    } else {\r\n      buffer = output;\r\n    }\r\n\r\n    this.output = buffer;\r\n\r\n    return this.output;\r\n  };\r\n\r\n  /**\r\n   * concat output buffer. (dynamic)\r\n   * @return {!(Array|Uint8Array)} output buffer.\r\n   */\r\n  RawInflateStream.prototype.concatBuffer = function() {\r\n    /** @type {!(Array|Uint8Array)} output buffer. */\r\n    var buffer;\r\n    /** @type {number} */\r\n    var op = this.op;\r\n    /** @type {Uint8Array} */\r\n    var tmp;\r\n\r\n    if (this.resize) {\r\n      if (USE_TYPEDARRAY) {\r\n        buffer = new Uint8Array(this.output.subarray(this.sp, op));\r\n      } else {\r\n        buffer = this.output.slice(this.sp, op);\r\n      }\r\n    } else {\r\n      buffer =\r\n        USE_TYPEDARRAY ? this.output.subarray(this.sp, op) : this.output.slice(this.sp, op);\r\n    }\r\n\r\n    this.sp = op;\r\n\r\n    // compaction\r\n    if (op > RawInflateStream.MaxBackwardLength + this.bufferSize) {\r\n      this.op = this.sp = RawInflateStream.MaxBackwardLength;\r\n      if (USE_TYPEDARRAY) {\r\n        tmp = /** @type {Uint8Array} */(this.output);\r\n        this.output = new Uint8Array(this.bufferSize + RawInflateStream.MaxBackwardLength);\r\n        this.output.set(tmp.subarray(op - RawInflateStream.MaxBackwardLength, op));\r\n      } else {\r\n        this.output = this.output.slice(op - RawInflateStream.MaxBackwardLength);\r\n      }\r\n    }\r\n\r\n    return buffer;\r\n  };\r\n\r\n  return Zlib.RawInflateStream = RawInflateStream;\r\n  \r\n});\r\n\r\n\r\n\ndefine('skylark-zlib/InflateStream',[\r\n  \"./zlib\",\r\n  \"./RawInflateStream\"\r\n],function(Zlib,RawInflateStream) {\r\n  const USE_TYPEDARRAY = true;\r\n\r\n/**\r\n * @param {!(Uint8Array|Array)} input deflated buffer.\r\n * @constructor\r\n */\r\nvar InflateStream = function(input) {\r\n  /** @type {!(Uint8Array|Array)} */\r\n  this.input = input === void 0 ? new (USE_TYPEDARRAY ? Uint8Array : Array)() : input;\r\n  /** @type {number} */\r\n  this.ip = 0;\r\n  /** @type {RawInflateStream} */\r\n  this.rawinflate = new RawInflateStream(this.input, this.ip);\r\n  /** @type {Zlib.CompressionMethod} */\r\n  this.method;\r\n  /** @type {!(Array|Uint8Array)} */\r\n  this.output = this.rawinflate.output;\r\n};\r\n\r\n/**\r\n * decompress.\r\n * @return {!(Uint8Array|Array)} inflated buffer.\r\n */\r\nInflateStream.prototype.decompress = function(input) {\r\n  /** @type {!(Uint8Array|Array)} inflated buffer. */\r\n  var buffer;\r\n  /** @type {number} adler-32 checksum */\r\n  var adler32;\r\n\r\n  // 新しい入力を入力バッファに結合する\r\n  // XXX Array, Uint8Array のチェックを行うか確認する\r\n  if (input !== void 0) {\r\n    if (USE_TYPEDARRAY) {\r\n      var tmp = new Uint8Array(this.input.length + input.length);\r\n      tmp.set(this.input, 0);\r\n      tmp.set(input, this.input.length);\r\n      this.input = tmp;\r\n    } else {\r\n      this.input = this.input.concat(input);\r\n    }\r\n  }\r\n\r\n  if (this.method === void 0) {\r\n    if(this.readHeader() < 0) {\r\n      return new (USE_TYPEDARRAY ? Uint8Array : Array)();\r\n    }\r\n  }\r\n\r\n  buffer = this.rawinflate.decompress(this.input, this.ip);\r\n  if (this.rawinflate.ip !== 0) {\r\n    this.input = USE_TYPEDARRAY ?\r\n      this.input.subarray(this.rawinflate.ip) :\r\n      this.input.slice(this.rawinflate.ip);\r\n    this.ip = 0;\r\n  }\r\n\r\n  // verify adler-32\r\n  /*\r\n  if (this.verify) {\r\n    adler32 =\r\n      input[this.ip++] << 24 | input[this.ip++] << 16 |\r\n      input[this.ip++] << 8 | input[this.ip++];\r\n\r\n    if (adler32 !== Adler32(buffer)) {\r\n      throw new Error('invalid adler-32 checksum');\r\n    }\r\n  }\r\n  */\r\n\r\n  return buffer;\r\n};\r\n\r\nInflateStream.prototype.readHeader = function() {\r\n  var ip = this.ip;\r\n  var input = this.input;\r\n\r\n  // Compression Method and Flags\r\n  var cmf = input[ip++];\r\n  var flg = input[ip++];\r\n\r\n  if (cmf === void 0 || flg === void 0) {\r\n    return -1;\r\n  }\r\n\r\n  // compression method\r\n  switch (cmf & 0x0f) {\r\n    case Zlib.CompressionMethod.DEFLATE:\r\n      this.method = Zlib.CompressionMethod.DEFLATE;\r\n      break;\r\n    default:\r\n      throw new Error('unsupported compression method');\r\n  }\r\n\r\n  // fcheck\r\n  if (((cmf << 8) + flg) % 31 !== 0) {\r\n    throw new Error('invalid fcheck flag:' + ((cmf << 8) + flg) % 31);\r\n  }\r\n\r\n  // fdict (not supported)\r\n  if (flg & 0x20) {\r\n    throw new Error('fdict flag is not supported');\r\n  }\r\n\r\n  this.ip = ip;\r\n};  \r\n\r\n  return Zlib.InflateStream = InflateStream;\r\n});\r\n\r\n\r\n\r\n\ndefine('skylark-zlib/Zip',[\r\n  \"./zlib\",\r\n  \"./crc32\",\r\n  \"./RawDeflate\"\r\n],function(Zlib,CRC32,RawDeflate) {\r\n  const USE_TYPEDARRAY = true;\r\n\r\n  /**\r\n   * @param {Object=} opt_params options.\r\n   * @constructor\r\n   */\r\n  Zip = function(opt_params) {\r\n    opt_params = opt_params || {};\r\n    /** @type {Array.<{\r\n     *   buffer: !(Array.<number>|Uint8Array),\r\n     *   option: Object,\r\n     *   compressed: boolean,\r\n     *   encrypted: boolean,\r\n     *   size: number,\r\n     *   crc32: number\r\n     * }>} */\r\n    this.files = [];\r\n    /** @type {(Array.<number>|Uint8Array)} */\r\n    this.comment = opt_params['comment'];\r\n    /** @type {(Array.<number>|Uint8Array)} */\r\n    this.password;\r\n  };\r\n\r\n\r\n  /**\r\n   * @enum {number}\r\n   */\r\n  Zip.CompressionMethod = {\r\n    STORE: 0,\r\n    DEFLATE: 8\r\n  };\r\n\r\n  /**\r\n   * @enum {number}\r\n   */\r\n  Zip.OperatingSystem = {\r\n    MSDOS: 0,\r\n    UNIX: 3,\r\n    MACINTOSH: 7\r\n  };\r\n\r\n  /**\r\n   * @enum {number}\r\n   */\r\n  Zip.Flags = {\r\n    ENCRYPT:    0x0001,\r\n    DESCRIPTOR: 0x0008,\r\n    UTF8:       0x0800\r\n  };\r\n\r\n  /**\r\n   * @type {Array.<number>}\r\n   * @const\r\n   */\r\n  Zip.FileHeaderSignature = [0x50, 0x4b, 0x01, 0x02];\r\n\r\n  /**\r\n   * @type {Array.<number>}\r\n   * @const\r\n   */\r\n  Zip.LocalFileHeaderSignature = [0x50, 0x4b, 0x03, 0x04];\r\n\r\n  /**\r\n   * @type {Array.<number>}\r\n   * @const\r\n   */\r\n  Zip.CentralDirectorySignature = [0x50, 0x4b, 0x05, 0x06];\r\n\r\n  /**\r\n   * @param {Array.<number>|Uint8Array} input\r\n   * @param {Object=} opt_params options.\r\n   */\r\n  Zip.prototype.addFile = function(input, opt_params) {\r\n    opt_params = opt_params || {};\r\n    /** @type {string} */\r\n    var filename = '' || opt_params['filename'];\r\n    /** @type {boolean} */\r\n    var compressed;\r\n    /** @type {number} */\r\n    var size = input.length;\r\n    /** @type {number} */\r\n    var crc32 = 0;\r\n\r\n    if (USE_TYPEDARRAY && input instanceof Array) {\r\n      input = new Uint8Array(input);\r\n    }\r\n\r\n    // default\r\n    if (typeof opt_params['compressionMethod'] !== 'number') {\r\n      opt_params['compressionMethod'] = Zip.CompressionMethod.DEFLATE;\r\n    }\r\n\r\n    // その場で圧縮する場合\r\n    if (opt_params['compress']) {\r\n      switch (opt_params['compressionMethod']) {\r\n        case Zip.CompressionMethod.STORE:\r\n          break;\r\n        case Zip.CompressionMethod.DEFLATE:\r\n          crc32 = CRC32.calc(input);\r\n          input = this.deflateWithOption(input, opt_params);\r\n          compressed = true;\r\n          break;\r\n        default:\r\n          throw new Error('unknown compression method:' + opt_params['compressionMethod']);\r\n      }\r\n    }\r\n\r\n    this.files.push({\r\n      buffer: input,\r\n      option: opt_params,\r\n      compressed: compressed,\r\n      encrypted: false,\r\n      size: size,\r\n      crc32: crc32\r\n    });\r\n  };\r\n\r\n  /**\r\n   * @param {(Array.<number>|Uint8Array)} password\r\n   */\r\n  Zip.prototype.setPassword = function(password) {\r\n    this.password = password;\r\n  };\r\n\r\n  Zip.prototype.compress = function() {\r\n    /** @type {Array.<{\r\n     *   buffer: !(Array.<number>|Uint8Array),\r\n     *   option: Object,\r\n     *   compressed: boolean,\r\n     *   encrypted: boolean,\r\n     *   size: number,\r\n     *   crc32: number\r\n     * }>} */\r\n    var files = this.files;\r\n    /** @type {{\r\n     *   buffer: !(Array.<number>|Uint8Array),\r\n     *   option: Object,\r\n     *   compressed: boolean,\r\n     *   encrypted: boolean,\r\n     *   size: number,\r\n     *   crc32: number\r\n     * }} */\r\n    var file;\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var output;\r\n    /** @type {number} */\r\n    var op1;\r\n    /** @type {number} */\r\n    var op2;\r\n    /** @type {number} */\r\n    var op3;\r\n    /** @type {number} */\r\n    var localFileSize = 0;\r\n    /** @type {number} */\r\n    var centralDirectorySize = 0;\r\n    /** @type {number} */\r\n    var endOfCentralDirectorySize;\r\n    /** @type {number} */\r\n    var offset;\r\n    /** @type {number} */\r\n    var needVersion;\r\n    /** @type {number} */\r\n    var flags;\r\n    /** @type {Zip.CompressionMethod} */\r\n    var compressionMethod;\r\n    /** @type {Date} */\r\n    var date;\r\n    /** @type {number} */\r\n    var crc32;\r\n    /** @type {number} */\r\n    var size;\r\n    /** @type {number} */\r\n    var plainSize;\r\n    /** @type {number} */\r\n    var filenameLength;\r\n    /** @type {number} */\r\n    var extraFieldLength;\r\n    /** @type {number} */\r\n    var commentLength;\r\n    /** @type {(Array.<number>|Uint8Array)} */\r\n    var filename;\r\n    /** @type {(Array.<number>|Uint8Array)} */\r\n    var extraField;\r\n    /** @type {(Array.<number>|Uint8Array)} */\r\n    var comment;\r\n    /** @type {(Array.<number>|Uint8Array)} */\r\n    var buffer;\r\n    /** @type {*} */\r\n    var tmp;\r\n    /** @type {Array.<number>|Uint32Array|Object} */\r\n    var key;\r\n    /** @type {number} */\r\n    var i;\r\n    /** @type {number} */\r\n    var il;\r\n    /** @type {number} */\r\n    var j;\r\n    /** @type {number} */\r\n    var jl;\r\n\r\n    // ファイルの圧縮\r\n    for (i = 0, il = files.length; i < il; ++i) {\r\n      file = files[i];\r\n      filenameLength =\r\n        (file.option['filename']) ? file.option['filename'].length : 0;\r\n      extraFieldLength =\r\n        (file.option['extraField']) ? file.option['extraField'].length : 0;\r\n      commentLength =\r\n        (file.option['comment']) ? file.option['comment'].length : 0;\r\n\r\n      // 圧縮されていなかったら圧縮\r\n      if (!file.compressed) {\r\n        // 圧縮前に CRC32 の計算をしておく\r\n        file.crc32 = CRC32.calc(file.buffer);\r\n\r\n        switch (file.option['compressionMethod']) {\r\n          case Zip.CompressionMethod.STORE:\r\n            break;\r\n          case Zip.CompressionMethod.DEFLATE:\r\n            file.buffer = this.deflateWithOption(file.buffer, file.option);\r\n            file.compressed = true;\r\n            break;\r\n          default:\r\n            throw new Error('unknown compression method:' + file.option['compressionMethod']);\r\n        }\r\n      }\r\n\r\n      // encryption\r\n      if (file.option['password'] !== void 0|| this.password !== void 0) {\r\n        // init encryption\r\n        key = this.createEncryptionKey(file.option['password'] || this.password);\r\n\r\n        // add header\r\n        buffer = file.buffer;\r\n        if (USE_TYPEDARRAY) {\r\n          tmp = new Uint8Array(buffer.length + 12);\r\n          tmp.set(buffer, 12);\r\n          buffer = tmp;\r\n        } else {\r\n          buffer.unshift(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\r\n        }\r\n\r\n        for (j = 0; j < 12; ++j) {\r\n          buffer[j] = this.encode(\r\n            key,\r\n            i === 11 ? (file.crc32 & 0xff) : (Math.random() * 256 | 0)\r\n          );\r\n        }\r\n\r\n        // data encryption\r\n        for (jl = buffer.length; j < jl; ++j) {\r\n          buffer[j] = this.encode(key, buffer[j]);\r\n        }\r\n        file.buffer = buffer;\r\n      }\r\n\r\n      // 必要バッファサイズの計算\r\n      localFileSize +=\r\n        // local file header\r\n        30 + filenameLength +\r\n        // file data\r\n        file.buffer.length;\r\n\r\n      centralDirectorySize +=\r\n        // file header\r\n        46 + filenameLength + commentLength;\r\n    }\r\n\r\n    // end of central directory\r\n    endOfCentralDirectorySize = 22 + (this.comment ? this.comment.length : 0);\r\n    output = new (USE_TYPEDARRAY ? Uint8Array : Array)(\r\n      localFileSize + centralDirectorySize + endOfCentralDirectorySize\r\n    );\r\n    op1 = 0;\r\n    op2 = localFileSize;\r\n    op3 = op2 + centralDirectorySize;\r\n\r\n    // ファイルの圧縮\r\n    for (i = 0, il = files.length; i < il; ++i) {\r\n      file = files[i];\r\n      filenameLength =\r\n        file.option['filename'] ? file.option['filename'].length :  0;\r\n      extraFieldLength = 0; // TODO\r\n      commentLength =\r\n        file.option['comment'] ? file.option['comment'].length : 0;\r\n\r\n      //-------------------------------------------------------------------------\r\n      // local file header & file header\r\n      //-------------------------------------------------------------------------\r\n\r\n      offset = op1;\r\n\r\n      // signature\r\n      // local file header\r\n      output[op1++] = Zip.LocalFileHeaderSignature[0];\r\n      output[op1++] = Zip.LocalFileHeaderSignature[1];\r\n      output[op1++] = Zip.LocalFileHeaderSignature[2];\r\n      output[op1++] = Zip.LocalFileHeaderSignature[3];\r\n      // file header\r\n      output[op2++] = Zip.FileHeaderSignature[0];\r\n      output[op2++] = Zip.FileHeaderSignature[1];\r\n      output[op2++] = Zip.FileHeaderSignature[2];\r\n      output[op2++] = Zip.FileHeaderSignature[3];\r\n\r\n      // compressor info\r\n      needVersion = 20;\r\n      output[op2++] = needVersion & 0xff;\r\n      output[op2++] =\r\n        /** @type {Zip.OperatingSystem} */\r\n        (file.option['os']) ||\r\n        Zip.OperatingSystem.MSDOS;\r\n\r\n      // need version\r\n      output[op1++] = output[op2++] =  needVersion       & 0xff;\r\n      output[op1++] = output[op2++] = (needVersion >> 8) & 0xff;\r\n\r\n      // general purpose bit flag\r\n      flags = 0;\r\n      if (file.option['password'] || this.password) {\r\n        flags |= Zip.Flags.ENCRYPT;\r\n      }\r\n      output[op1++] = output[op2++] =  flags       & 0xff;\r\n      output[op1++] = output[op2++] = (flags >> 8) & 0xff;\r\n\r\n      // compression method\r\n      compressionMethod =\r\n        /** @type {Zip.CompressionMethod} */\r\n        (file.option['compressionMethod']);\r\n      output[op1++] = output[op2++] =  compressionMethod       & 0xff;\r\n      output[op1++] = output[op2++] = (compressionMethod >> 8) & 0xff;\r\n\r\n      // date\r\n      date = /** @type {(Date|undefined)} */(file.option['date']) || new Date();\r\n      output[op1++] = output[op2++] =\r\n        ((date.getMinutes() & 0x7) << 5) |\r\n        (date.getSeconds() / 2 | 0);\r\n      output[op1++] = output[op2++] =\r\n        (date.getHours()   << 3) |\r\n        (date.getMinutes() >> 3);\r\n      //\r\n      output[op1++] = output[op2++] =\r\n        ((date.getMonth() + 1 & 0x7) << 5) |\r\n        (date.getDate());\r\n      output[op1++] = output[op2++] =\r\n        ((date.getFullYear() - 1980 & 0x7f) << 1) |\r\n        (date.getMonth() + 1 >> 3);\r\n\r\n      // CRC-32\r\n      crc32 = file.crc32;\r\n      output[op1++] = output[op2++] =  crc32        & 0xff;\r\n      output[op1++] = output[op2++] = (crc32 >>  8) & 0xff;\r\n      output[op1++] = output[op2++] = (crc32 >> 16) & 0xff;\r\n      output[op1++] = output[op2++] = (crc32 >> 24) & 0xff;\r\n\r\n      // compressed size\r\n      size = file.buffer.length;\r\n      output[op1++] = output[op2++] =  size        & 0xff;\r\n      output[op1++] = output[op2++] = (size >>  8) & 0xff;\r\n      output[op1++] = output[op2++] = (size >> 16) & 0xff;\r\n      output[op1++] = output[op2++] = (size >> 24) & 0xff;\r\n\r\n      // uncompressed size\r\n      plainSize = file.size;\r\n      output[op1++] = output[op2++] =  plainSize        & 0xff;\r\n      output[op1++] = output[op2++] = (plainSize >>  8) & 0xff;\r\n      output[op1++] = output[op2++] = (plainSize >> 16) & 0xff;\r\n      output[op1++] = output[op2++] = (plainSize >> 24) & 0xff;\r\n\r\n      // filename length\r\n      output[op1++] = output[op2++] =  filenameLength       & 0xff;\r\n      output[op1++] = output[op2++] = (filenameLength >> 8) & 0xff;\r\n\r\n      // extra field length\r\n      output[op1++] = output[op2++] =  extraFieldLength       & 0xff;\r\n      output[op1++] = output[op2++] = (extraFieldLength >> 8) & 0xff;\r\n\r\n      // file comment length\r\n      output[op2++] =  commentLength       & 0xff;\r\n      output[op2++] = (commentLength >> 8) & 0xff;\r\n\r\n      // disk number start\r\n      output[op2++] = 0;\r\n      output[op2++] = 0;\r\n\r\n      // internal file attributes\r\n      output[op2++] = 0;\r\n      output[op2++] = 0;\r\n\r\n      // external file attributes\r\n      output[op2++] = 0;\r\n      output[op2++] = 0;\r\n      output[op2++] = 0;\r\n      output[op2++] = 0;\r\n\r\n      // relative offset of local header\r\n      output[op2++] =  offset        & 0xff;\r\n      output[op2++] = (offset >>  8) & 0xff;\r\n      output[op2++] = (offset >> 16) & 0xff;\r\n      output[op2++] = (offset >> 24) & 0xff;\r\n\r\n      // filename\r\n      filename = file.option['filename'];\r\n      if (filename) {\r\n        if (USE_TYPEDARRAY) {\r\n          output.set(filename, op1);\r\n          output.set(filename, op2);\r\n          op1 += filenameLength;\r\n          op2 += filenameLength;\r\n        } else {\r\n          for (j = 0; j < filenameLength; ++j) {\r\n            output[op1++] = output[op2++] = filename[j];\r\n          }\r\n        }\r\n      }\r\n\r\n      // extra field\r\n      extraField = file.option['extraField'];\r\n      if (extraField) {\r\n        if (USE_TYPEDARRAY) {\r\n          output.set(extraField, op1);\r\n          output.set(extraField, op2);\r\n          op1 += extraFieldLength;\r\n          op2 += extraFieldLength;\r\n        } else {\r\n          for (j = 0; j < commentLength; ++j) {\r\n            output[op1++] = output[op2++] = extraField[j];\r\n          }\r\n        }\r\n      }\r\n\r\n      // comment\r\n      comment = file.option['comment'];\r\n      if (comment) {\r\n        if (USE_TYPEDARRAY) {\r\n          output.set(comment, op2);\r\n          op2 += commentLength;\r\n        } else {\r\n          for (j = 0; j < commentLength; ++j) {\r\n            output[op2++] = comment[j];\r\n          }\r\n        }\r\n      }\r\n\r\n      //-------------------------------------------------------------------------\r\n      // file data\r\n      //-------------------------------------------------------------------------\r\n\r\n      if (USE_TYPEDARRAY) {\r\n        output.set(file.buffer, op1);\r\n        op1 += file.buffer.length;\r\n      } else {\r\n        for (j = 0, jl = file.buffer.length; j < jl; ++j) {\r\n          output[op1++] = file.buffer[j];\r\n        }\r\n      }\r\n    }\r\n\r\n    //-------------------------------------------------------------------------\r\n    // end of central directory\r\n    //-------------------------------------------------------------------------\r\n\r\n    // signature\r\n    output[op3++] = Zip.CentralDirectorySignature[0];\r\n    output[op3++] = Zip.CentralDirectorySignature[1];\r\n    output[op3++] = Zip.CentralDirectorySignature[2];\r\n    output[op3++] = Zip.CentralDirectorySignature[3];\r\n\r\n    // number of this disk\r\n    output[op3++] = 0;\r\n    output[op3++] = 0;\r\n\r\n    // number of the disk with the start of the central directory\r\n    output[op3++] = 0;\r\n    output[op3++] = 0;\r\n\r\n    // total number of entries in the central directory on this disk\r\n    output[op3++] =  il       & 0xff;\r\n    output[op3++] = (il >> 8) & 0xff;\r\n\r\n    // total number of entries in the central directory\r\n    output[op3++] =  il       & 0xff;\r\n    output[op3++] = (il >> 8) & 0xff;\r\n\r\n    // size of the central directory\r\n    output[op3++] =  centralDirectorySize        & 0xff;\r\n    output[op3++] = (centralDirectorySize >>  8) & 0xff;\r\n    output[op3++] = (centralDirectorySize >> 16) & 0xff;\r\n    output[op3++] = (centralDirectorySize >> 24) & 0xff;\r\n\r\n    // offset of start of central directory with respect to the starting disk number\r\n    output[op3++] =  localFileSize        & 0xff;\r\n    output[op3++] = (localFileSize >>  8) & 0xff;\r\n    output[op3++] = (localFileSize >> 16) & 0xff;\r\n    output[op3++] = (localFileSize >> 24) & 0xff;\r\n\r\n    // .ZIP file comment length\r\n    commentLength = this.comment ? this.comment.length : 0;\r\n    output[op3++] =  commentLength       & 0xff;\r\n    output[op3++] = (commentLength >> 8) & 0xff;\r\n\r\n    // .ZIP file comment\r\n    if (this.comment) {\r\n      if (USE_TYPEDARRAY) {\r\n        output.set(this.comment, op3);\r\n        op3 += commentLength;\r\n      } else {\r\n        for (j = 0, jl = commentLength; j < jl; ++j) {\r\n          output[op3++] = this.comment[j];\r\n        }\r\n      }\r\n    }\r\n\r\n    return output;\r\n  };\r\n\r\n  /**\r\n   * @param {!(Array.<number>|Uint8Array)} input\r\n   * @param {Object=} opt_params options.\r\n   * @return {!(Array.<number>|Uint8Array)}\r\n   */\r\n  Zip.prototype.deflateWithOption = function(input, opt_params) {\r\n    /** @type {RawDeflate} */\r\n    var deflator = new RawDeflate(input, opt_params['deflateOption']);\r\n\r\n    return deflator.compress();\r\n  };\r\n\r\n  /**\r\n   * @param {(Array.<number>|Uint32Array)} key\r\n   * @return {number}\r\n   */\r\n  Zip.prototype.getByte = function(key) {\r\n    /** @type {number} */\r\n    var tmp = ((key[2] & 0xffff) | 2);\r\n\r\n    return ((tmp * (tmp ^ 1)) >> 8) & 0xff;\r\n  };\r\n\r\n  /**\r\n   * @param {(Array.<number>|Uint32Array|Object)} key\r\n   * @param {number} n\r\n   * @return {number}\r\n   */\r\n  Zip.prototype.encode = function(key, n) {\r\n    /** @type {number} */\r\n    var tmp = this.getByte(/** @type {(Array.<number>|Uint32Array)} */(key));\r\n\r\n    this.updateKeys(/** @type {(Array.<number>|Uint32Array)} */(key), n);\r\n\r\n    return tmp ^ n;\r\n  };\r\n\r\n  /**\r\n   * @param {(Array.<number>|Uint32Array)} key\r\n   * @param {number} n\r\n   */\r\n  Zip.prototype.updateKeys = function(key, n) {\r\n    key[0] = CRC32.single(key[0], n);\r\n    key[1] =\r\n      (((((key[1] + (key[0] & 0xff)) * 20173 >>> 0) * 6681) >>> 0) + 1) >>> 0;\r\n    key[2] = CRC32.single(key[2], key[1] >>> 24);\r\n  };\r\n\r\n  /**\r\n   * @param {(Array.<number>|Uint8Array)} password\r\n   * @return {!(Array.<number>|Uint32Array|Object)}\r\n   */\r\n  Zip.prototype.createEncryptionKey = function(password) {\r\n    /** @type {!(Array.<number>|Uint32Array)} */\r\n    var key = [305419896, 591751049, 878082192];\r\n    /** @type {number} */\r\n    var i;\r\n    /** @type {number} */\r\n    var il;\r\n\r\n    if (USE_TYPEDARRAY) {\r\n      key = new Uint32Array(key);\r\n    }\r\n\r\n    for (i = 0, il = password.length; i < il; ++i) {\r\n      this.updateKeys(key, password[i] & 0xff);\r\n    }\r\n\r\n    return key;\r\n  };\r\n\r\n  return Zlib.Zip = Zip;\r\n});\r\n\r\n\ndefine('skylark-zlib/Unzip',[\r\n  \"./zlib\",\r\n  \"./crc32\",\r\n  \"./RawInflate\",\r\n  \"./Zip\"\r\n],function(Zlib,RawInflate,Zip) {\r\n  const USE_TYPEDARRAY = true;\r\n\r\n  /**\r\n   * @param {!(Array.<number>|Uint8Array)} input input buffer.\r\n   * @param {Object=} opt_params options.\r\n   * @constructor\r\n   */\r\n  var Unzip = function(input, opt_params) {\r\n    opt_params = opt_params || {};\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    this.input =\r\n      (USE_TYPEDARRAY && (input instanceof Array)) ?\r\n      new Uint8Array(input) : input;\r\n    /** @type {number} */\r\n    this.ip = 0;\r\n    /** @type {number} */\r\n    this.eocdrOffset;\r\n    /** @type {number} */\r\n    this.numberOfThisDisk;\r\n    /** @type {number} */\r\n    this.startDisk;\r\n    /** @type {number} */\r\n    this.totalEntriesThisDisk;\r\n    /** @type {number} */\r\n    this.totalEntries;\r\n    /** @type {number} */\r\n    this.centralDirectorySize;\r\n    /** @type {number} */\r\n    this.centralDirectoryOffset;\r\n    /** @type {number} */\r\n    this.commentLength;\r\n    /** @type {(Array.<number>|Uint8Array)} */\r\n    this.comment;\r\n    /** @type {Array.<Unzip.FileHeader>} */\r\n    this.fileHeaderList;\r\n    /** @type {Object.<string, number>} */\r\n    this.filenameToIndex;\r\n    /** @type {boolean} */\r\n    this.verify = opt_params['verify'] || false;\r\n    /** @type {(Array.<number>|Uint8Array)} */\r\n    this.password = opt_params['password'];\r\n  };\r\n\r\n  Unzip.CompressionMethod = Zip.CompressionMethod;\r\n\r\n  /**\r\n   * @type {Array.<number>}\r\n   * @const\r\n   */\r\n  Unzip.FileHeaderSignature = Zip.FileHeaderSignature;\r\n\r\n  /**\r\n   * @type {Array.<number>}\r\n   * @const\r\n   */\r\n  Unzip.LocalFileHeaderSignature = Zip.LocalFileHeaderSignature;\r\n\r\n  /**\r\n   * @type {Array.<number>}\r\n   * @const\r\n   */\r\n  Unzip.CentralDirectorySignature = Zip.CentralDirectorySignature;\r\n\r\n  /**\r\n   * @param {!(Array.<number>|Uint8Array)} input input buffer.\r\n   * @param {number} ip input position.\r\n   * @constructor\r\n   */\r\n  Unzip.FileHeader = function(input, ip) {\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    this.input = input;\r\n    /** @type {number} */\r\n    this.offset = ip;\r\n    /** @type {number} */\r\n    this.length;\r\n    /** @type {number} */\r\n    this.version;\r\n    /** @type {number} */\r\n    this.os;\r\n    /** @type {number} */\r\n    this.needVersion;\r\n    /** @type {number} */\r\n    this.flags;\r\n    /** @type {number} */\r\n    this.compression;\r\n    /** @type {number} */\r\n    this.time;\r\n    /** @type {number} */\r\n    this.date;\r\n    /** @type {number} */\r\n    this.crc32;\r\n    /** @type {number} */\r\n    this.compressedSize;\r\n    /** @type {number} */\r\n    this.plainSize;\r\n    /** @type {number} */\r\n    this.fileNameLength;\r\n    /** @type {number} */\r\n    this.extraFieldLength;\r\n    /** @type {number} */\r\n    this.fileCommentLength;\r\n    /** @type {number} */\r\n    this.diskNumberStart;\r\n    /** @type {number} */\r\n    this.internalFileAttributes;\r\n    /** @type {number} */\r\n    this.externalFileAttributes;\r\n    /** @type {number} */\r\n    this.relativeOffset;\r\n    /** @type {string} */\r\n    this.filename;\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    this.extraField;\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    this.comment;\r\n  };\r\n\r\n  Unzip.FileHeader.prototype.parse = function() {\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var input = this.input;\r\n    /** @type {number} */\r\n    var ip = this.offset;\r\n\r\n    // central file header signature\r\n    if (input[ip++] !== Unzip.FileHeaderSignature[0] ||\r\n        input[ip++] !== Unzip.FileHeaderSignature[1] ||\r\n        input[ip++] !== Unzip.FileHeaderSignature[2] ||\r\n        input[ip++] !== Unzip.FileHeaderSignature[3]) {\r\n      throw new Error('invalid file header signature');\r\n    }\r\n\r\n    // version made by\r\n    this.version = input[ip++];\r\n    this.os = input[ip++];\r\n\r\n    // version needed to extract\r\n    this.needVersion = input[ip++] | (input[ip++] << 8);\r\n\r\n    // general purpose bit flag\r\n    this.flags = input[ip++] | (input[ip++] << 8);\r\n\r\n    // compression method\r\n    this.compression = input[ip++] | (input[ip++] << 8);\r\n\r\n    // last mod file time\r\n    this.time = input[ip++] | (input[ip++] << 8);\r\n\r\n    //last mod file date\r\n    this.date = input[ip++] | (input[ip++] << 8);\r\n\r\n    // crc-32\r\n    this.crc32 = (\r\n      (input[ip++]      ) | (input[ip++] <<  8) |\r\n      (input[ip++] << 16) | (input[ip++] << 24)\r\n    ) >>> 0;\r\n\r\n    // compressed size\r\n    this.compressedSize = (\r\n      (input[ip++]      ) | (input[ip++] <<  8) |\r\n      (input[ip++] << 16) | (input[ip++] << 24)\r\n    ) >>> 0;\r\n\r\n    // uncompressed size\r\n    this.plainSize = (\r\n      (input[ip++]      ) | (input[ip++] <<  8) |\r\n      (input[ip++] << 16) | (input[ip++] << 24)\r\n    ) >>> 0;\r\n\r\n    // file name length\r\n    this.fileNameLength = input[ip++] | (input[ip++] << 8);\r\n\r\n    // extra field length\r\n    this.extraFieldLength = input[ip++] | (input[ip++] << 8);\r\n\r\n    // file comment length\r\n    this.fileCommentLength = input[ip++] | (input[ip++] << 8);\r\n\r\n    // disk number start\r\n    this.diskNumberStart = input[ip++] | (input[ip++] << 8);\r\n\r\n    // internal file attributes\r\n    this.internalFileAttributes = input[ip++] | (input[ip++] << 8);\r\n\r\n    // external file attributes\r\n    this.externalFileAttributes =\r\n      (input[ip++]      ) | (input[ip++] <<  8) |\r\n      (input[ip++] << 16) | (input[ip++] << 24);\r\n\r\n    // relative offset of local header\r\n    this.relativeOffset = (\r\n      (input[ip++]      ) | (input[ip++] <<  8) |\r\n      (input[ip++] << 16) | (input[ip++] << 24)\r\n    ) >>> 0;\r\n\r\n    // file name\r\n    this.filename = String.fromCharCode.apply(null, USE_TYPEDARRAY ?\r\n      input.subarray(ip, ip += this.fileNameLength) :\r\n      input.slice(ip, ip += this.fileNameLength)\r\n    );\r\n\r\n    // extra field\r\n    this.extraField = USE_TYPEDARRAY ?\r\n      input.subarray(ip, ip += this.extraFieldLength) :\r\n      input.slice(ip, ip += this.extraFieldLength);\r\n\r\n    // file comment\r\n    this.comment = USE_TYPEDARRAY ?\r\n      input.subarray(ip, ip + this.fileCommentLength) :\r\n      input.slice(ip, ip + this.fileCommentLength);\r\n\r\n    this.length = ip - this.offset;\r\n  };\r\n\r\n  /**\r\n   * @param {!(Array.<number>|Uint8Array)} input input buffer.\r\n   * @param {number} ip input position.\r\n   * @constructor\r\n   */\r\n  Unzip.LocalFileHeader = function(input, ip) {\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    this.input = input;\r\n    /** @type {number} */\r\n    this.offset = ip;\r\n    /** @type {number} */\r\n    this.length;\r\n    /** @type {number} */\r\n    this.needVersion;\r\n    /** @type {number} */\r\n    this.flags;\r\n    /** @type {number} */\r\n    this.compression;\r\n    /** @type {number} */\r\n    this.time;\r\n    /** @type {number} */\r\n    this.date;\r\n    /** @type {number} */\r\n    this.crc32;\r\n    /** @type {number} */\r\n    this.compressedSize;\r\n    /** @type {number} */\r\n    this.plainSize;\r\n    /** @type {number} */\r\n    this.fileNameLength;\r\n    /** @type {number} */\r\n    this.extraFieldLength;\r\n    /** @type {string} */\r\n    this.filename;\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    this.extraField;\r\n  };\r\n\r\n  Unzip.LocalFileHeader.Flags = Zip.Flags;\r\n\r\n  Unzip.LocalFileHeader.prototype.parse = function() {\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var input = this.input;\r\n    /** @type {number} */\r\n    var ip = this.offset;\r\n\r\n    // local file header signature\r\n    if (input[ip++] !== Unzip.LocalFileHeaderSignature[0] ||\r\n        input[ip++] !== Unzip.LocalFileHeaderSignature[1] ||\r\n        input[ip++] !== Unzip.LocalFileHeaderSignature[2] ||\r\n        input[ip++] !== Unzip.LocalFileHeaderSignature[3]) {\r\n      throw new Error('invalid local file header signature');\r\n    }\r\n\r\n    // version needed to extract\r\n    this.needVersion = input[ip++] | (input[ip++] << 8);\r\n\r\n    // general purpose bit flag\r\n    this.flags = input[ip++] | (input[ip++] << 8);\r\n\r\n    // compression method\r\n    this.compression = input[ip++] | (input[ip++] << 8);\r\n\r\n    // last mod file time\r\n    this.time = input[ip++] | (input[ip++] << 8);\r\n\r\n    //last mod file date\r\n    this.date = input[ip++] | (input[ip++] << 8);\r\n\r\n    // crc-32\r\n    this.crc32 = (\r\n      (input[ip++]      ) | (input[ip++] <<  8) |\r\n      (input[ip++] << 16) | (input[ip++] << 24)\r\n    ) >>> 0;\r\n\r\n    // compressed size\r\n    this.compressedSize = (\r\n      (input[ip++]      ) | (input[ip++] <<  8) |\r\n      (input[ip++] << 16) | (input[ip++] << 24)\r\n    ) >>> 0;\r\n\r\n    // uncompressed size\r\n    this.plainSize = (\r\n      (input[ip++]      ) | (input[ip++] <<  8) |\r\n      (input[ip++] << 16) | (input[ip++] << 24)\r\n    ) >>> 0;\r\n\r\n    // file name length\r\n    this.fileNameLength = input[ip++] | (input[ip++] << 8);\r\n\r\n    // extra field length\r\n    this.extraFieldLength = input[ip++] | (input[ip++] << 8);\r\n\r\n    // file name\r\n    this.filename = String.fromCharCode.apply(null, USE_TYPEDARRAY ?\r\n      input.subarray(ip, ip += this.fileNameLength) :\r\n      input.slice(ip, ip += this.fileNameLength)\r\n    );\r\n\r\n    // extra field\r\n    this.extraField = USE_TYPEDARRAY ?\r\n      input.subarray(ip, ip += this.extraFieldLength) :\r\n      input.slice(ip, ip += this.extraFieldLength);\r\n\r\n    this.length = ip - this.offset;\r\n  };\r\n\r\n\r\n  Unzip.prototype.searchEndOfCentralDirectoryRecord = function() {\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var input = this.input;\r\n    /** @type {number} */\r\n    var ip;\r\n\r\n    for (ip = input.length - 12; ip > 0; --ip) {\r\n      if (input[ip  ] === Unzip.CentralDirectorySignature[0] &&\r\n          input[ip+1] === Unzip.CentralDirectorySignature[1] &&\r\n          input[ip+2] === Unzip.CentralDirectorySignature[2] &&\r\n          input[ip+3] === Unzip.CentralDirectorySignature[3]) {\r\n        this.eocdrOffset = ip;\r\n        return;\r\n      }\r\n    }\r\n\r\n    throw new Error('End of Central Directory Record not found');\r\n  };\r\n\r\n  Unzip.prototype.parseEndOfCentralDirectoryRecord = function() {\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var input = this.input;\r\n    /** @type {number} */\r\n    var ip;\r\n\r\n    if (!this.eocdrOffset) {\r\n      this.searchEndOfCentralDirectoryRecord();\r\n    }\r\n    ip = this.eocdrOffset;\r\n\r\n    // signature\r\n    if (input[ip++] !== Unzip.CentralDirectorySignature[0] ||\r\n        input[ip++] !== Unzip.CentralDirectorySignature[1] ||\r\n        input[ip++] !== Unzip.CentralDirectorySignature[2] ||\r\n        input[ip++] !== Unzip.CentralDirectorySignature[3]) {\r\n      throw new Error('invalid signature');\r\n    }\r\n\r\n    // number of this disk\r\n    this.numberOfThisDisk = input[ip++] | (input[ip++] << 8);\r\n\r\n    // number of the disk with the start of the central directory\r\n    this.startDisk = input[ip++] | (input[ip++] << 8);\r\n\r\n    // total number of entries in the central directory on this disk\r\n    this.totalEntriesThisDisk = input[ip++] | (input[ip++] << 8);\r\n\r\n    // total number of entries in the central directory\r\n    this.totalEntries = input[ip++] | (input[ip++] << 8);\r\n\r\n    // size of the central directory\r\n    this.centralDirectorySize = (\r\n      (input[ip++]      ) | (input[ip++] <<  8) |\r\n      (input[ip++] << 16) | (input[ip++] << 24)\r\n    ) >>> 0;\r\n\r\n    // offset of start of central directory with respect to the starting disk number\r\n    this.centralDirectoryOffset = (\r\n      (input[ip++]      ) | (input[ip++] <<  8) |\r\n      (input[ip++] << 16) | (input[ip++] << 24)\r\n    ) >>> 0;\r\n\r\n    // .ZIP file comment length\r\n    this.commentLength = input[ip++] | (input[ip++] << 8);\r\n\r\n    // .ZIP file comment\r\n    this.comment = USE_TYPEDARRAY ?\r\n      input.subarray(ip, ip + this.commentLength) :\r\n      input.slice(ip, ip + this.commentLength);\r\n  };\r\n\r\n  Unzip.prototype.parseFileHeader = function() {\r\n    /** @type {Array.<Unzip.FileHeader>} */\r\n    var filelist = [];\r\n    /** @type {Object.<string, number>} */\r\n    var filetable = {};\r\n    /** @type {number} */\r\n    var ip;\r\n    /** @type {Unzip.FileHeader} */\r\n    var fileHeader;\r\n    /*: @type {number} */\r\n    var i;\r\n    /*: @type {number} */\r\n    var il;\r\n\r\n    if (this.fileHeaderList) {\r\n      return;\r\n    }\r\n\r\n    if (this.centralDirectoryOffset === void 0) {\r\n      this.parseEndOfCentralDirectoryRecord();\r\n    }\r\n    ip = this.centralDirectoryOffset;\r\n\r\n    for (i = 0, il = this.totalEntries; i < il; ++i) {\r\n      fileHeader = new Unzip.FileHeader(this.input, ip);\r\n      fileHeader.parse();\r\n      ip += fileHeader.length;\r\n      filelist[i] = fileHeader;\r\n      filetable[fileHeader.filename] = i;\r\n    }\r\n\r\n    if (this.centralDirectorySize < ip - this.centralDirectoryOffset) {\r\n      throw new Error('invalid file header size');\r\n    }\r\n\r\n    this.fileHeaderList = filelist;\r\n    this.filenameToIndex = filetable;\r\n  };\r\n\r\n  /**\r\n   * @param {number} index file header index.\r\n   * @param {Object=} opt_params\r\n   * @return {!(Array.<number>|Uint8Array)} file data.\r\n   */\r\n  Unzip.prototype.getFileData = function(index, opt_params) {\r\n    opt_params = opt_params || {};\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var input = this.input;\r\n    /** @type {Array.<Unzip.FileHeader>} */\r\n    var fileHeaderList = this.fileHeaderList;\r\n    /** @type {Unzip.LocalFileHeader} */\r\n    var localFileHeader;\r\n    /** @type {number} */\r\n    var offset;\r\n    /** @type {number} */\r\n    var length;\r\n    /** @type {!(Array.<number>|Uint8Array)} */\r\n    var buffer;\r\n    /** @type {number} */\r\n    var crc32;\r\n    /** @type {Array.<number>|Uint32Array|Object} */\r\n    var key;\r\n    /** @type {number} */\r\n    var i;\r\n    /** @type {number} */\r\n    var il;\r\n\r\n    if (!fileHeaderList) {\r\n      this.parseFileHeader();\r\n    }\r\n\r\n    if (fileHeaderList[index] === void 0) {\r\n      throw new Error('wrong index');\r\n    }\r\n\r\n    offset = fileHeaderList[index].relativeOffset;\r\n    localFileHeader = new Unzip.LocalFileHeader(this.input, offset);\r\n    localFileHeader.parse();\r\n    offset += localFileHeader.length;\r\n    length = localFileHeader.compressedSize;\r\n\r\n    // decryption\r\n    if ((localFileHeader.flags & Unzip.LocalFileHeader.Flags.ENCRYPT) !== 0) {\r\n      if (!(opt_params['password'] || this.password)) {\r\n        throw new Error('please set password');\r\n      }\r\n      key =  this.createDecryptionKey(opt_params['password'] || this.password);\r\n\r\n      // encryption header\r\n      for(i = offset, il = offset + 12; i < il; ++i) {\r\n        this.decode(key, input[i]);\r\n      }\r\n      offset += 12;\r\n      length -= 12;\r\n\r\n      // decryption\r\n      for (i = offset, il = offset + length; i < il; ++i) {\r\n        input[i] = this.decode(key, input[i]);\r\n      }\r\n    }\r\n\r\n    switch (localFileHeader.compression) {\r\n      case Unzip.CompressionMethod.STORE:\r\n        buffer = USE_TYPEDARRAY ?\r\n          this.input.subarray(offset, offset + length) :\r\n          this.input.slice(offset, offset + length);\r\n        break;\r\n      case Unzip.CompressionMethod.DEFLATE:\r\n        buffer = new RawInflate(this.input, {\r\n          'index': offset,\r\n          'bufferSize': localFileHeader.plainSize\r\n        }).decompress();\r\n        break;\r\n      default:\r\n        throw new Error('unknown compression type');\r\n    }\r\n\r\n    if (this.verify) {\r\n      crc32 = CRC32.calc(buffer);\r\n      if (localFileHeader.crc32 !== crc32) {\r\n        throw new Error(\r\n          'wrong crc: file=0x' + localFileHeader.crc32.toString(16) +\r\n          ', data=0x' + crc32.toString(16)\r\n        );\r\n      }\r\n    }\r\n\r\n    return buffer;\r\n  };\r\n\r\n  /**\r\n   * @return {Array.<string>}\r\n   */\r\n  Unzip.prototype.getFilenames = function() {\r\n    /** @type {Array.<string>} */\r\n    var filenameList = [];\r\n    /** @type {number} */\r\n    var i;\r\n    /** @type {number} */\r\n    var il;\r\n    /** @type {Array.<Unzip.FileHeader>} */\r\n    var fileHeaderList;\r\n\r\n    if (!this.fileHeaderList) {\r\n      this.parseFileHeader();\r\n    }\r\n    fileHeaderList = this.fileHeaderList;\r\n\r\n    for (i = 0, il = fileHeaderList.length; i < il; ++i) {\r\n      filenameList[i] = fileHeaderList[i].filename;\r\n    }\r\n\r\n    return filenameList;\r\n  };\r\n\r\n  /**\r\n   * @param {string} filename extract filename.\r\n   * @param {Object=} opt_params\r\n   * @return {!(Array.<number>|Uint8Array)} decompressed data.\r\n   */\r\n  Unzip.prototype.decompress = function(filename, opt_params) {\r\n    /** @type {number} */\r\n    var index;\r\n\r\n    if (!this.filenameToIndex) {\r\n      this.parseFileHeader();\r\n    }\r\n    index = this.filenameToIndex[filename];\r\n\r\n    if (index === void 0) {\r\n      throw new Error(filename + ' not found');\r\n    }\r\n\r\n    return this.getFileData(index, opt_params);\r\n  };\r\n\r\n  /**\r\n   * @param {(Array.<number>|Uint8Array)} password\r\n   */\r\n  Unzip.prototype.setPassword = function(password) {\r\n    this.password = password;\r\n  };\r\n\r\n  /**\r\n   * @param {(Array.<number>|Uint32Array|Object)} key\r\n   * @param {number} n\r\n   * @return {number}\r\n   */\r\n  Unzip.prototype.decode = function(key, n) {\r\n    n ^= this.getByte(/** @type {(Array.<number>|Uint32Array)} */(key));\r\n    this.updateKeys(/** @type {(Array.<number>|Uint32Array)} */(key), n);\r\n\r\n    return n;\r\n  };\r\n\r\n  // common method\r\n  Unzip.prototype.updateKeys = Zip.prototype.updateKeys;\r\n  Unzip.prototype.createDecryptionKey = Zip.prototype.createEncryptionKey;\r\n  Unzip.prototype.getByte = Zip.prototype.getByte;\r\n\r\n  return Zlib.Unzip = Unzip;\r\n\r\n});\r\n\r\n\r\n\ndefine('skylark-zlib/Util',[\r\n  \"./zlib\"\r\n],function(Zlib) {\r\n  /**\r\n   * @fileoverview 雑多な関数群をまとめたモジュール実装.\r\n   */\r\n  var Util = {};\r\n\r\n  /**\r\n   * Byte String から Byte Array に変換.\r\n   * @param {!string} str byte string.\r\n   * @return {!Array.<number>} byte array.\r\n   */\r\n  Util.stringToByteArray = function(str) {\r\n    /** @type {!Array.<(string|number)>} */\r\n    var tmp = str.split('');\r\n    /** @type {number} */\r\n    var i;\r\n    /** @type {number} */\r\n    var il;\r\n\r\n    for (i = 0, il = tmp.length; i < il; i++) {\r\n      tmp[i] = (tmp[i].charCodeAt(0) & 0xff) >>> 0;\r\n    }\r\n\r\n    return tmp;\r\n  };\r\n\r\n  return Zlib.Util = Util;\r\n\r\n});\r\n\r\n\r\n\ndefine('skylark-zlib/main',[\r\n\t\"./zlib\",\r\n\t\"./adler32\",\r\n\t\"./BitStream\",\r\n\t\"./crc32\",\r\n\t\"./Deflate\",\r\n\t\"./Gunzip\",\r\n\t\"./GunzipMember\",\r\n\t\"./Gzip\",\r\n\t\"./Heap\",\r\n\t\"./huffman\",\r\n\t\"./Inflate\",\r\n\t\"./InflateStream\",\r\n\t\"./RawDeflate\",\r\n\t\"./RawInflate\",\r\n\t\"./RawInflateStream\",\r\n\t\"./Unzip\",\r\n\t\"./Util\",\r\n\t\"./Zip\"\r\n],function(zlib){\r\n\treturn zlib\r\n});\ndefine('skylark-zlib', ['skylark-zlib/main'], function (main) { return main; });\n\n"]}